//Процедура проверяет ведение однофирменности и при необходимости запрещает изменять организацию в ограничениях
Процедура ПроизвестиПроверкуНаВедениеОднофирменности(Организация)
	
	ОргПоУмолчанию = УправлениеПользователями.ПолучитьЗначениеПоУмолчанию(ПараметрыСеанса.ТекущийПользователь, "ОсновнаяОрганизация");
	Если ЗначениеЗаполнено(ОргПоУмолчанию) Тогда
		Организация = ОргПоУмолчанию;
	КонецЕсли;
    
КонецПроцедуры

//Процедура рассчитывает конечные данные по начальным данным и оборотам
Процедура РассчитатьКонечныеДанныеПоВидуСчетаИНачальнымДанным(Знач ТекущийВидСчета, ИтогДт, ИтогКт, Знач НачДт, Знач НачКт,
	Знач ОборотДт, Знач ОборотКт) Экспорт
	
	// расчет итоговой суммы
	Если ТекущийВидСчета = ВидСчета.Активный Тогда 
			
		ИтогДт = НачДт + ОборотДт - ОборотКт;
		ИтогКт = 0;
					
	ИначеЕсли ТекущийВидСчета = ВидСчета.Пассивный Тогда
			
		ИтогДт = 0;
		ИтогКт = НачКт + ОборотКт - ОборотДт;
					
	Иначе
			
		ИтогДт = НачДт + ОборотДт;
		ИтогКт = НачКт + ОборотКт;
			
		Если ИтогДт > ИтогКт Тогда
			
			ИтогДт = ИтогДт - ИтогКт;
			ИтогКт = 0;
			
		Иначе
			
			ИтогКт = ИтогКт - ИтогДт;
			ИтогДт = 0;
			
		КонецЕсли;
					
	КонецЕсли;
	
КонецПроцедуры

// Создание копии структуры или соответствия
//
// Параментры:
//   СоотвИсх - Структура/Соответствие - Исходная структура, с которой будет создаваться копия.
//
// Возвращаемое значение:
//   Структура/Соответствие - Копия исходной структуры. Тип данных повторяет тип исходной структуры.
Функция СоздатьКопиюСоответствияСтруктуры(Знач СоответствиеИсточник) Экспорт
	
	Если СоответствиеИсточник = Неопределено Тогда
		
		Возврат Неопределено;
		
	КонецЕсли;
	
	КопияСоответствия = Новый (ТипЗнч(СоответствиеИсточник));
		
	Для Каждого ЭлементОтбора Из СоответствиеИсточник Цикл
				
		КопияСоответствия.Вставить(ЭлементОтбора.Ключ, ЭлементОтбора.Значение);
				
	КонецЦикла;
	
	Возврат КопияСоответствия;
	
КонецФункции

//Функция создает по структуре параметров соответсвие
Функция СоздатьПоСтруктуреСоответствие(Знач СтруктураПараметров) Экспорт
	
	Параметры = Новый Соответствие;
	
	Для Каждого Элемент Из СтруктураПараметров Цикл
		
		Параметры.Вставить(Элемент.Ключ, Элемент.Значение);
		
	КонецЦикла;
	
	Возврат Параметры;
	
КонецФункции

// Управляет пометками кнопок ком. панели
//
// Параметры:
//	ФормаОтчета
//  ПоказыватьЗаголовок - булево. Отображать пометку или нет
Процедура УправлениеПометкамиКнопокЗаголовковКоманднойПанели(ФормаОтчета, Знач ПоказыватьЗаголовок) Экспорт
	
	ФормаОтчета.ЭлементыФормы.КоманднаяПанельФормы.Кнопки.Заголовок.Пометка = ПоказыватьЗаголовок;
	ФормаОтчета.ЭлементыФормы.КоманднаяПанельФормы.Кнопки.Подменю.Кнопки.Заголовок.Пометка = ПоказыватьЗаголовок;
    	
КонецПроцедуры

// Формирует строку ограничений по датам отчета для показа в заголовке формы
//
// Параметры:
//	ДатаНач
//  ДатаКон
Функция СформироватьСтрокуОграниченийПоДатамДляФормы(Знач ДатаНач, Знач ДатаКон) Экспорт

	// Вывод заголовка, описателя периода и фильтров и заголовка
	Если ДатаНач = '00010101000000' И ДатаКон = '00010101000000' Тогда

		ОписаниеПериода     = "Период не установлен";

	Иначе

		Если ДатаНач = '00010101000000' ИЛИ ДатаКон = '00010101000000' Тогда

			ОписаниеПериода = "" + Формат(ДатаНач, "ДФ = ""дд.ММ.гггг""; ДП = ""...""") 
							+ " - "      + Формат(ДатаКон, "ДФ = ""дд.ММ.гггг""; ДП = ""...""");

		Иначе

			Если ДатаНач <= ДатаКон Тогда
				ОписаниеПериода = "" + ПредставлениеПериода(НачалоДня(ДатаНач), КонецДня(ДатаКон), "ФП = Истина");
			Иначе
				ОписаниеПериода = "Неправильно задан период!"
			КонецЕсли;

		КонецЕсли;

	КонецЕсли;

	Возврат ОписаниеПериода;

КонецФункции

// Формирует строку ограничений по датам отчета для показа в заголовке формы
//
// Параметры:
//	ДатаНач
//  ДатаКон
Функция СформироватьСтрокуВыводаПараметровПоДатам(Знач ДатаНач, Знач ДатаКон) Экспорт

	Если ДатаНач = '00010101000000' И ДатаКон = '00010101000000' Тогда		
		ОписаниеПериода     = "Период: без ограничения.";		
	Иначе		
		Если ДатаНач = '00010101000000' ИЛИ ДатаКон = '00010101000000' Тогда			
			ОписаниеПериода = "Период: " + Формат(ДатаНач, "ДФ = ""дд.ММ.гггг""; ДП = ""без ограничения""") 
							+ " - "      + Формат(ДатаКон, "ДФ = ""дд.ММ.гггг""; ДП = ""без ограничения""");			
		Иначе
			Если ДатаНач > ДатаКон Тогда
				ОписаниеПериода = "";
			Иначе				
				ОписаниеПериода = "Период: " + ПредставлениеПериода(НачалоДня(ДатаНач), КонецДня(ДатаКон), "ФП = Истина");
			КонецЕсли;
		КонецЕсли;		
	КонецЕсли;

	Возврат ОписаниеПериода;

КонецФункции

//Функция возвращает корректные или нет ограничения по датам для отчета
// в случае если ограничения не корректны - выдается предупреждение
Функция ПроверитьКорректностьОграниченийПоДатам(Знач ДатаНач, Знач ДатаКон, Знач ВыдаватьПредупреждение = Истина) Экспорт
	
	// Проверка на пустые значения
	Если ДатаНач > ДатаКон И ДатаКон <> '00010101000000' Тогда

		Если ВыдаватьПредупреждение Тогда 
			Предупреждение("Дата начала периода не может быть больше даты конца периода");
		КонецЕсли;
	
		Возврат Ложь;

	КонецЕсли;
	
	Возврат Истина;

КонецФункции

// процедура заполняет таблицу настроек свойств
Процедура ЗаполнитьТаблицуНастроекСвойств(ЭтотОбъект, Знач ИмяРеквизита, Структура) Экспорт
	
	Источник = Неопределено;
	Если Структура.Свойство(ИмяРеквизита, Источник) <> Истина Тогда
		Возврат;
	КонецЕсли;
	
	Попытка
		Приемник = ЭтотОбъект[ИмяРеквизита];
	Исключение
    	Возврат;
	КонецПопытки;
	
	Приемник.Очистить();
		
	// Загрузим совпадающие колонки.
	Для Каждого СтрокаТаблицыИсточника Из Источник Цикл
			
		СтрокаТаблицыПриемника = Приемник.Добавить();
		ЗаполнитьЗначенияСвойств(СтрокаТаблицыПриемника, СтрокаТаблицыИсточника); 
			
	КонецЦикла;
		
КонецПроцедуры

// процедура обрабатывает выпод заголовка
Процедура ОбработатьВыводЗаголовка(Форма, ОтчетОбъект, ВысотаЗаголовка, ПоказыватьЗаголовок) Экспорт

	// Перезаполнять заголовок можно только у "чистого" отчета
	Если Форма.ЭлементыФормы.ДокументРезультат.ВысотаТаблицы = 0 Тогда

		ОбластьЗаголовка = ОтчетОбъект.СформироватьЗаголовок();
		ВысотаЗаголовка = ОбластьЗаголовка.ВысотаТаблицы;
		Форма.ЭлементыФормы.ДокументРезультат.Вывести(ОбластьЗаголовка);
		
	КонецЕсли;

    Если ЗначениеЗаполнено(ВысотаЗаголовка) Тогда
		Форма.ЭлементыФормы.ДокументРезультат.Область("R1:R" + ВысотаЗаголовка).Видимость = ПоказыватьЗаголовок;
	КонецЕсли;

	УправлениеПометкамиКнопокЗаголовковКоманднойПанели(Форма, ПоказыватьЗаголовок);
	
КонецПроцедуры

//процедура формирует заголовок отчета
Процедура СформироватьИВывестиЗаголовокОтчета(ОтчетОбъект, ДокументРезультат, ВысотаЗаголовка, ПоказыватьЗаголовок) Экспорт
	
	ОбластьЗаголовка = ОтчетОбъект.СформироватьЗаголовок();
	ВысотаЗаголовка = ОбластьЗаголовка.ВысотаТаблицы;
	ДокументРезультат.Вывести(ОбластьЗаголовка, 1);
	
	Если ЗначениеЗаполнено(ВысотаЗаголовка) Тогда
		ДокументРезультат.Область("R1:R" + ВысотаЗаголовка).Видимость = ПоказыватьЗаголовок;
	КонецЕсли;
	
КонецПроцедуры	

// Редактирование Субконто
Процедура РедактированиеСубконто(Элемент, СписокСубконто)
    	
	Форма = ПолучитьОбщуюФорму("ФормаНастройкаПоСубконто", Элемент);

	// Передача параметров в форму
	Форма.Список = СписокСубконто;
	
	Форма.РежимВыбора = Истина;
	
	Форма.ОткрытьМодально();
	
КонецПроцедуры

// обработка редактирования субконто
Процедура ОбработкаРедактированиеСубконто(Элемент, ТекущиеДанныеТаблицыРедактирования) Экспорт
	
	Если ТекущиеДанныеТаблицыРедактирования = Неопределено Тогда
		Возврат;
	КонецЕсли;
	
	Счет = ТекущиеДанныеТаблицыРедактирования.Счет;
	Если НЕ ЗначениеЗаполнено(Счет) Тогда
		Предупреждение("Не выбран счет!");
		Возврат;
	КонецЕсли;
	
	СписокСубконто = Новый СписокЗначений;
	
	Для Каждого ВидСубконто Из Счет.ВидыСубконто Цикл

		СписокСубконто.Добавить("Субконто" + Строка(ВидСубконто.НомерСтроки), Строка(ВидСубконто.ВидСубконто));
		
	КонецЦикла;

	// Данные этой строки должны быть отмечены
	Для Каждого Строка Из ТекущиеДанныеТаблицыРедактирования.РазворотПоСубконто Цикл
		
		ЭлементСписка = СписокСубконто.НайтиПоЗначению(Строка.Имя);
		Если ЭлементСписка <> Неопределено Тогда
			ЭлементСписка.Пометка = Истина;
		КонецЕсли;
		
	КонецЦикла;

	РедактированиеСубконто(Элемент, СписокСубконто);
	
КонецПроцедуры

//процедура очищает данные разворота по субконто текущей строки настроек
Процедура ОчиститьДанныеНастроекПоСубконтоДляТекущейСтрокиНастроек(РедактируемаяСтрока)
	
	РедактируемаяСтрока.РазворотПоСубконто.Очистить();
	
	Если РедактируемаяСтрока.РазворотПоСубконто.Колонки.Количество() = 0 Тогда
		
		ОписаниеТиповСтрока = Новый ОписаниеТипов("Строка",, Новый КвалификаторыСтроки(100));

		РедактируемаяСтрока.РазворотПоСубконто.Колонки.Добавить("Имя",           ОписаниеТиповСтрока);
		РедактируемаяСтрока.РазворотПоСубконто.Колонки.Добавить("Представление", ОписаниеТиповСтрока);
		
	КонецЕсли;

	РедактируемаяСтрока.ПредставлениеРазворотПоСубконто = "";
	
КонецПроцедуры

//процедура добавляет новое значение субконто в список выбранных
Процедура ДобавитьСубконтоВТаблицуВыбранных(ТаблицаВыбораСубконто, Знач ИмяСубконто, Знач ПредставлениеСубконто)
	
	НоваяСтрокаПоСубконто = ТаблицаВыбораСубконто.РазворотПоСубконто.Добавить();
			
	НоваяСтрокаПоСубконто.Имя = ИмяСубконто;
	НоваяСтрокаПоСубконто.Представление = ПредставлениеСубконто;
			
	ТаблицаВыбораСубконто.ПредставлениеРазворотПоСубконто = ТаблицаВыбораСубконто.ПредставлениеРазворотПоСубконто + ", " 
		+ ПредставлениеСубконто;
	
КонецПроцедуры


// Процедура обрабатывает выбор показателей, группировок или фильтров из отдельного окна.
Процедура ОбработкаВыборРазворотаПоСубконто(ВыбранноеЗначение, ТабличноеПоле, СтандартнаяОбработка) Экспорт

	СтандартнаяОбработка = Ложь;
	Если ТабличноеПоле.ТекущиеДанные = Неопределено Тогда
		Возврат;
	КонецЕсли;
	
	ОчиститьДанныеНастроекПоСубконтоДляТекущейСтрокиНастроек(ТабличноеПоле.ТекущиеДанные);

	Для Каждого Строка Из ВыбранноеЗначение Цикл 

		Если Строка.Пометка Тогда
			
			ДобавитьСубконтоВТаблицуВыбранных(ТабличноеПоле.ТекущиеДанные, Строка.Значение, Строка.Представление);
							
		КонецЕсли;

	КонецЦикла;

	ТабличноеПоле.ТекущиеДанные.ПредставлениеРазворотПоСубконто  = Сред(ТабличноеПоле.ТекущиеДанные.ПредставлениеРазворотПоСубконто, 3);

КонецПроцедуры

// процедура обрабатывает окончание редактирования настроек развернутого сальдо
Процедура ПриОкончанииРедактированияПравилаРазвернутогоСальдо(Элемент, НоваяСтрока, ОтменаРедактирования) Экспорт

	ТабличноеПоле = Элемент;

	Если ТабличноеПоле.ТекущиеДанные = Неопределено Тогда
		Возврат;
	КонецЕсли;

	Если НРег(ТабличноеПоле.ТекущаяКолонка.Имя) = НРег("Субсчета") Тогда

		Если ТабличноеПоле.ТекущиеДанные.Субсчета Тогда
			
			ОчиститьДанныеНастроекПоСубконтоДляТекущейСтрокиНастроек(ТабличноеПоле.ТекущиеДанные);
									
		КонецЕсли;
		
	ИначеЕсли НРег(ТабличноеПоле.ТекущаяКолонка.Имя) = НРег("ПредставлениеРазворотПоСубконто") Тогда

		Если ТабличноеПоле.ТекущиеДанные.РазворотПоСубконто.Количество() > 0 Тогда
			
			ТабличноеПоле.ТекущиеДанные.СубСчета = Ложь;
			
		КонецЕсли;
		
	КонецЕсли;
	
КонецПроцедуры

// процедура - обработчик при изменении счета в таблицах детализации или развернутого сальдо
Процедура ОбработчикПриИзмененииСчета(ТабличноеПоле, Знач ТабПолеРазвернутогоСальдо) Экспорт

	РедактируемаяСтрока = ТабличноеПоле.ТекущиеДанные; 
	
	Если РедактируемаяСтрока = Неопределено Тогда
		Возврат;
	КонецЕсли;

	ОчиститьДанныеНастроекПоСубконтоДляТекущейСтрокиНастроек(РедактируемаяСтрока);
	
	// Признак того, что счет найден способ развернуть счет
	НайденСпособРазворота = Ложь;

	Счет = РедактируемаяСтрока.Счет;
	Если ЗначениеЗаполнено(Счет) Тогда
		
		ВыборкаПоСчету = ПланыСчетов[Счет.Метаданные().Имя].Выбрать(Счет);
		Если ВыборкаПоСчету.Следующий() Тогда
			
			РедактируемаяСтрока.Субсчета = Истина;
            НайденСпособРазворота = Истина;
			
		КонецЕсли;

		// Развернутое сальдо только по субсчетам
		Если ТабПолеРазвернутогоСальдо 
			И НайденСпособРазворота Тогда
			
			Возврат;
			
		КонецЕсли;
		
		Если Счет.ВидыСубконто.Количество() > 0 Тогда

			// Развернутое сальдо - отключим субсчета
			Если ТабПолеРазвернутогоСальдо Тогда
				РедактируемаяСтрока.Субсчета = Ложь;
			КонецЕсли;

			Для Каждого ВидСубконто Из Счет.ВидыСубконто Цикл

				ДобавитьСубконтоВТаблицуВыбранных(РедактируемаяСтрока, "Субконто" + Строка(ВидСубконто.НомерСтроки), Строка(ВидСубконто.ВидСубконто));
				
			КонецЦикла;

			РедактируемаяСтрока.ПредставлениеРазворотПоСубконто  = Сред(РедактируемаяСтрока.ПредставлениеРазворотПоСубконто, 3);

			НайденСпособРазворота = Истина;

		КонецЕсли;

		// Если у счета нет ни субсчетов, ни субконто, не дадим его выбрать.
		Если НЕ НайденСпособРазворота Тогда
			
			Если ТабПолеРазвернутогоСальдо Тогда
				ВидНастройки = "развернутого сальдо ";
			Иначе
				ВидНастройки = "итогов по субсчетам и субконто ";
			КонецЕсли;
			Предупреждение("Счет """ + Счет.Код + """ не имеет ни субсчетов, ни субконто." + Символы.ПС + "Настройка " + ВидНастройки + "не имеет смысла!");
			РедактируемаяСтрока.Счет = Неопределено;
			
		КонецЕсли;

	КонецЕсли;
	
КонецПроцедуры

// процедура обработки очистки разворота по субконто
Процедура ОбработкаОчисткиРазворотПоСубконтоТабПоля(ТабличноеПоле) Экспорт

	Если ТабличноеПоле.ТекущиеДанные = Неопределено Тогда
		Возврат;
	КонецЕсли;

	ОчиститьДанныеНастроекПоСубконтоДляТекущейСтрокиНастроек(ТабличноеПоле.ТекущиеДанные);
	
КонецПроцедуры

// процедура устанавливает связывание данных и визуальных объектов отображения
// настроек Бух отчетов
Процедура УстановитьСвязываниеДанныхФормыНастроек(ПравилаВыводаИтогов, ПравилаРазвернутогоСальдо) Экспорт
	
	// Связывание с данными колонок "Счет": тип определяется типом колонки у таблицы
	Если ПравилаВыводаИтогов <> Неопределено Тогда
		ПравилаВыводаИтогов.Колонки.Счет.Данные = "Счет";
		ПравилаВыводаИтогов.Колонки.Счет.ЭлементУправления.КнопкаВыбора = Истина;
		ПравилаВыводаИтогов.Колонки.Счет.ЭлементУправления.КнопкаОчистки = Ложь;
		ПравилаВыводаИтогов.Колонки.ПредставлениеРазворотПоСубконто.ЭлементУправления.КнопкаОчистки = Истина;
	КонецЕсли;
	
	Если ПравилаРазвернутогоСальдо <> Неопределено Тогда
		ПравилаРазвернутогоСальдо.Колонки.Счет.Данные = "Счет";
		ПравилаРазвернутогоСальдо.Колонки.Счет.ЭлементУправления.КнопкаВыбора = Истина;
		ПравилаРазвернутогоСальдо.Колонки.Счет.ЭлементУправления.КнопкаОчистки = Ложь;
		ПравилаРазвернутогоСальдо.Колонки.ПредставлениеРазворотПоСубконто.ЭлементУправления.КнопкаОчистки = Истина;
	КонецЕсли;
		
КонецПроцедуры

// процедура содает колонки у таблиц правила вывода итогов и правила развернутого сальдо
Процедура СоздатьКолонкиУПравилВыводаИтоговИПравилаРазвернутогоСальдо(ПравилаВыводаИтогов, ПравилаРазвернутогоСальдо, 
	Знач ИмяРегистраБухгалтерии) Экспорт
	
	ОписаниеТиповСтрока = Новый ОписаниеТипов("Строка",, Новый КвалификаторыСтроки(200));

	МассивБулево        = Новый Массив;
	ОписаниеТиповБулево = Новый ОписаниеТипов("Булево");
    
	МассивТаблицаЗначений        = Новый Массив;
	ОписаниеТиповТаблицаЗначений = Новый ОписаниеТипов("ТаблицаЗначений");

	МассивСчет = Новый Массив;
	МассивСчет.Добавить(ТипЗнч(ПланыСчетов[Метаданные.РегистрыБухгалтерии[ИмяРегистраБухгалтерии].ПланСчетов.Имя].ПустаяСсылка()));
	ОписаниеТиповСчет  = Новый ОписаниеТипов(МассивСчет);

	// Создание структуры реквизитов - таблиц
	Если ПравилаВыводаИтогов <> Неопределено Тогда

		ПравилаВыводаИтогов.Колонки.Очистить();
		ПравилаВыводаИтогов.Колонки.Добавить("Счет",     ОписаниеТиповСчет);
		ПравилаВыводаИтогов.Колонки.Добавить("Субсчета", ОписаниеТиповБулево);
		ПравилаВыводаИтогов.Колонки.Добавить("ПредставлениеРазворотПоСубконто", ОписаниеТиповСтрока);
		ПравилаВыводаИтогов.Колонки.Добавить("РазворотПоСубконто", ОписаниеТиповТаблицаЗначений);
		
	КонецЕсли;

	Если ПравилаРазвернутогоСальдо <> Неопределено Тогда 
		
		ПравилаРазвернутогоСальдо.Колонки.Очистить();
		ПравилаРазвернутогоСальдо.Колонки.Добавить("Счет",     ОписаниеТиповСчет);
		ПравилаРазвернутогоСальдо.Колонки.Добавить("Субсчета", ОписаниеТиповБулево);
		ПравилаРазвернутогоСальдо.Колонки.Добавить("ПредставлениеРазворотПоСубконто", ОписаниеТиповСтрока);
		ПравилаРазвернутогоСальдо.Колонки.Добавить("РазворотПоСубконто", ОписаниеТиповТаблицаЗначений);
		
	КонецЕсли;
    	
КонецПроцедуры

//Функция возвращает есть ли для данного счета субсчета или нет
Функция ОпределитьНаличиеСубсчетов(Знач ИмяПланаСчетов, Знач Счет) Экспорт

	Если НЕ ЗначениеЗаполнено(Счет) Тогда
		Возврат Ложь;
	КонецЕсли;
	
	ТекстЗапроса = 
	"ВЫБРАТЬ
	|	Родители.Ссылка
	|ИЗ
	|	ПланСчетов." + ИмяПланаСчетов + " КАК Родители
	|		ВНУТРЕННЕЕ СОЕДИНЕНИЕ ПланСчетов." + ИмяПланаСчетов + " КАК Дети
	|		ПО Родители.Ссылка = Дети.Родитель
	|ГДЕ
	|	Родители.Ссылка = &Счет";
	
	Запрос = Новый Запрос(ТекстЗапроса);
	
	Запрос.УстановитьПараметр("Счет", Счет);
	
	Результат = Запрос.Выполнить();
	
	ЕстьСубсчета = Не Результат.Пустой();
	
	Возврат ЕстьСубсчета;

КонецФункции

//функция возвращает соотвествие подчиненных счетов
Функция ВернутьСоответвиеПодчиненныхСчетов(Знач ИмяПланаСчетов = "", Знач Счет, Знач ДобавлятьСамСчетВСоответсвие = Ложь) Экспорт
	
	СоответсвиеСчетов = Новый Соответствие;
	
	Запрос = Новый Запрос();
	
	Запрос.Текст =
		"ВЫБРАТЬ РАЗРЕШЕННЫЕ ПланСчетовРегистра.Ссылка КАК Ссылка
		|ИЗ	ПланСчетов." + ИмяПланаСчетов + " КАК ПланСчетовРегистра
		|ГДЕ	ПланСчетовРегистра.Ссылка В Иерархии(&Ссылка)";
		
	Запрос.УстановитьПараметр("Ссылка", Счет);
	
	Выборка = Запрос.Выполнить().Выбрать();
	
	Пока Выборка.Следующий() Цикл
		
		Если (НЕ ДобавлятьСамСчетВСоответсвие)
			И (Выборка.Ссылка = Счет) Тогда
			
			Продолжить;
			
		КонецЕсли;
		
		СоответсвиеСчетов.Вставить(Выборка.Ссылка, Выборка.Ссылка);
		
	КонецЦикла;

	Возврат СоответсвиеСчетов;
	
КонецФункции

//Функция возвращает соответствие счетов предков
Функция ВернутьСоответвиеСчетовПредков(Знач ИмяПланаСчетов = "", Знач Счет) Экспорт
	
	ЗапросСчета = Новый Запрос(
		"ВЫБРАТЬ РАЗРЕШЕННЫЕ
		|	ПланСчетовРегистра.Ссылка КАК Ссылка
		|ИЗ
		|	ПланСчетов."+ИмяПланаСчетов+" КАК ПланСчетовРегистра
		|
		|ГДЕ
		|	ПланСчетовРегистра.Ссылка = &Ссылка
		|
		|ИТОГИ ПО
		|	Ссылка ИЕРАРХИЯ");
	
	ЗапросСчета.УстановитьПараметр("Ссылка", Счет);
	
	ВыборкаСчета = ЗапросСчета.Выполнить().Выбрать(ОбходРезультатаЗапроса.Прямой);
	
	СоответсвиеСчетов = Новый Соответствие();
	Пока ВыборкаСчета.Следующий() Цикл
		СоответсвиеСчетов.Вставить(ВыборкаСчета.Ссылка, ВыборкаСчета.Ссылка);
	КонецЦикла;

	Возврат СоответсвиеСчетов;
	
КонецФункции

// Функция проверяет выборку на наличие ненулевых оборотов
Функция ЭтоНулевойОборот(Выборка, ПоКоличеству) Экспорт
		
	СуммаНоль = Выборка.СуммаОборотДт = 0 И Выборка.СуммаОборотКт = 0;
	КоличествоНоль = Не ПоКоличеству ИЛИ Выборка.КоличествоОборотДт = 0 И Выборка.КоличествоОборотКт = 0;
	Возврат СуммаНоль И КоличествоНоль;
	
КонецФункции

//Функция для счета возвращает количество субконто для него
Функция ОпределитьДляСчетаПоСоответсвиеКоличествоСубконто(Знач Счет, СоответсвиеСчетов) Экспорт
	
	СоответсвиеСчетов = Новый Соответствие;
	
	КоличествоСубконтоСчета = СоответсвиеСчетов[Счет];
	Если КоличествоСубконтоСчета = -1
		ИЛИ КоличествоСубконтоСчета = Неопределено Тогда
		
		КоличествоСубконтоСчета = Счет.ВидыСубконто.Количество();
		СоответсвиеСчетов[Счет] = КоличествоСубконтоСчета;
		
	КонецЕсли;

	Возврат КоличествоСубконтоСчета;
	
КонецФункции

// процедура выводит представления субконто для текущей строки отчета в макет
Процедура ВывестиПредставленияСубконтоТекущейСтрокиВМакет(Знач ПрефиксНаименованияКолонки, Проводки, Знач КоличествоСубконтоСчета, 
	ОбластьМакет, ДокументРезультат, СтруктураРасшифровки) Экспорт
	
	Для Индекс = 0 По КоличествоСубконтоСчета - 1 Цикл

		ОбластьМакет.Параметры.Содержание = ?(НЕ ЗначениеЗаполнено(Проводки[ПрефиксНаименованияКолонки + Строка(Индекс + 1)])
			, "<...>"
			, Проводки[ПрефиксНаименованияКолонки + Строка(Индекс + 1) + "Представление"]);

		ОбластьМакет.Параметры.Расшифровка = СтруктураРасшифровки;
		ДокументРезультат.Вывести(ОбластьМакет);

	КонецЦикла;
	
КонецПроцедуры

//Функция определяещая наличие дублирующегося параметра детализации
Функция ОпределитьНаличиеДублирующегосяПараметраВИзмерениях(ПостроительОтчета) Экспорт
	
	СоответствиеТекущихИзмерений = Новый Соответствие;
	Для Сч = 0 По ПостроительОтчета.ИзмеренияСтроки.Количество() - 1  Цикл
		
		ПутьКДанным = ПостроительОтчета.ИзмеренияСтроки[Сч].ПутьКДанным;
		Если СоответствиеТекущихИзмерений[ПутьКДанным] <> Неопределено Тогда
			
			Предупреждение("Повторяющееся поле детализации """ + ПостроительОтчета.ИзмеренияСтроки[Сч].Представление + """!");
			Возврат Истина;
			
		КонецЕсли;
		СоответствиеТекущихИзмерений.Вставить(ПостроительОтчета.ИзмеренияСтроки[Сч].ПутьКДанным, 0);
				
	КонецЦикла;
	
	Возврат Ложь;
	
КонецФункции

//Процедура формирует первоначальные строки отбора построителя по субконто
Процедура СформироватьПервоначальныйОтборПостроителяПоСубконто(ПостроительОтчета, Знач Счет) Экспорт
	
	ПостроительОтчета.ИзмеренияСтроки.Очистить();
	
	Сч = 0;
	Для Каждого СтрокаВидаСубконто Из Счет.ВидыСубконто Цикл
		
		Сч = Сч + 1;
		ИмяСубконто = "Субконто" + Сч;
		
		ЭлементОтбора = ПостроительОтчета.Отбор.Найти(ИмяСубконто);
		Если ЭлементОтбора = Неопределено Тогда
			ЭлементОтбора = ПостроительОтчета.Отбор.Добавить(ИмяСубконто);
			ЭлементОтбора.Использование = Ложь;
		КонецЕсли;
					
		ТипИзмерения = ПолучитьТипИзмеренияПоУмолчанию(СтрокаВидаСубконто.ВидСубконто.ТипЗначения);
		ПостроительОтчета.ИзмеренияСтроки.Добавить(ИмяСубконто, , ТипИзмерения);

	КонецЦикла;
	
КонецПроцедуры

Функция ПолучитьТипИзмеренияПоУмолчанию(ТипЗначения) Экспорт
	
	Для каждого Тип Из ТипЗначения.Типы() Цикл
		ОбъектМетаданных = Метаданные.НайтиПоТипу(Тип);
		Если ОбъектМетаданных = Неопределено Тогда
			Продолжить;
		КонецЕсли;
		
		Если Метаданные.Справочники.Содержит(ОбъектМетаданных) Тогда
			Если ОбъектМетаданных.Иерархический Тогда
				Возврат ПолучитьТипИзмеренияПостроителяОтчетаПоУмолчанию();;
			КонецЕсли;
		КонецЕсли;
	КонецЦикла;
	
	Возврат ТипИзмеренияПостроителяОтчета.Элементы;
	
КонецФункции

Функция ПолучитьТипИзмеренияПостроителяОтчетаПоУмолчанию()
	
	ТипДетализацииПоУмолчанию = УправлениеПользователями.ПолучитьЗначениеПоУмолчанию(ПараметрыСеанса.ТекущийПользователь, "ТипДетализацииСтандартныхОтчетов");
	
	Если ТипДетализацииПоУмолчанию = Перечисления.ТипДетализацииСтандартныхОтчетов.Элементы Тогда
		Возврат ТипИзмеренияПостроителяОтчета.Элементы;
	ИначеЕсли ТипДетализацииПоУмолчанию = Перечисления.ТипДетализацииСтандартныхОтчетов.Иерархия Тогда
		Возврат ТипИзмеренияПостроителяОтчета.Иерархия;
	ИначеЕсли ТипДетализацииПоУмолчанию = Перечисления.ТипДетализацииСтандартныхОтчетов.ТолькоИерархия Тогда
		Возврат ТипИзмеренияПостроителяОтчета.ТолькоИерархия;
	Иначе
		Возврат ТипИзмеренияПостроителяОтчета.Элементы;
	КонецЕсли;
	
КонецФункции

Процедура УстановитьТипИзмеренияПоУмолчанию(ТекущиеДанные, ПостроительОтчета) Экспорт
	
	ПутьКДанным = ТекущиеДанные.ПутьКДанным;
	
	Если Найти(ПутьКДанным, "КорСубконто") > 0 Тогда
		Префикс = "КорСубконто";
	ИначеЕсли Найти(ПутьКДанным, "Субконто") > 0 Тогда
		Префикс = "Субконто";
	Иначе
		Возврат;
	КонецЕсли;
	
	ИндексВидСубконто = Число(Сред(ПутьКДанным, СтрДлина(Префикс) + 1, 1)) - 1;
	Путь = СтрЗаменить(ПутьКДанным, ".", ".Поля."); 
	ТипЗначения = Неопределено;
	Выполнить("ТипЗначения = ПостроительОтчета.ДоступныеПоля." + Путь + ".ТипЗначения");
	ТекущиеДанные.ТипИзмерения = ПолучитьТипИзмеренияПоУмолчанию(ТипЗначения);
	
КонецПроцедуры

// процедура устанавливает отбор посторителю отчетов по параметрам
Процедура ВосстановитьОтборПостроителяОтчетовПоПараметрам(ПостроительОтчета, Знач СтрокиОтбора) Экспорт
	
	Если СтрокиОтбора = Неопределено Тогда
		Возврат;
	КонецЕсли;
	
	Если ТипЗнч(СтрокиОтбора) = Тип("Соответствие")
		ИЛИ ТипЗнч(СтрокиОтбора) = Тип("Структура") Тогда
		
		Для Каждого Строка Из СтрокиОтбора Цикл
			
			ЭлементОтбора = Неопределено;
			
			// Установим существующие элементы, добавим новые
			Для Инд = 0 По ПостроительОтчета.Отбор.Количество()-1 Цикл
				
				Если Строка.Ключ = ПостроительОтчета.Отбор[Инд].ПутьКДанным Тогда
					ЭлементОтбора = ПостроительОтчета.Отбор[Инд];
				КонецЕсли;
			
			КонецЦикла;
			
			Попытка
			
				Если ЭлементОтбора = Неопределено Тогда
					ЭлементОтбора = ПостроительОтчета.Отбор.Добавить(Строка.Ключ);
				КонецЕсли;
				
				Если ТипЗнч(Строка.Значение) = Тип("СписокЗначений")
					ИЛИ ТипЗнч(Строка.Значение) = Тип("Массив") ТОгда
					
					ЭлементОтбора.ВидСравнения = ВидСравнения.ВСписке;
					ЭлементОтбора.Значение = Строка.Значение;	
					ЭлементОтбора.Использование = Истина;
					
				ИначеЕсли ТипЗнч(Строка.Значение) = Тип("Структура") Тогда
					
					ЭлементОтбора.ВидСравнения  = Строка.Значение.ВидСравнения;
					ЭлементОтбора.Значение      = Строка.Значение.Значение;
					ЭлементОтбора.Использование = Истина;	
					
				Иначе
					ЭлементОтбора.Установить(Строка.Значение);
					
					Если Метаданные.Справочники.Содержит(Строка.Значение.Метаданные())
					   И ЗначениеЗаполнено(Строка.Значение) Тогда
						ЭлементОтбора.ВидСравнения = ВидСравнения.ВИерархии;
					Иначе
						ЭлементОтбора.ВидСравнения = ВидСравнения.Равно;
					КонецЕсли;
				   
				КонецЕсли;	
				
			Исключение
				// не смогли ограничение установить
				Продолжить;
			КонецПопытки;
			
		КонецЦикла;
		
	ИначеЕсли ТипЗнч(СтрокиОтбора) = Тип("ТаблицаЗначений") Тогда
		
		// переносим имя отбора из пути к данным
		Для Каждого СтрокаОтбора Из СтрокиОтбора Цикл
			
			СтрокаОтбора.Имя = СтрокаОтбора.ПутьКДанным; 
			
		КонецЦикла;
		
		УправлениеОтчетами.ЗаполнитьОтборИзТаблицыЗначений(ПостроительОтчета.Отбор, СтрокиОтбора, Ложь);
		
	КонецЕсли;
	
КонецПроцедуры

//Функция формирует описание ограничений по измерениям построителя
Функция СформироватьСтрокуОписанияИтоговПоИзмерениямПостроителя(ПостроительОтчета) Экспорт
	
	Если ПостроительОтчета.ИзмеренияСтроки.Количество() = 0 Тогда
		Возврат "";
	КонецЕсли;
	
	ТекстПроИтоги = "субконто: ";
		
	СтрокаИзмерений = "";
	Для Каждого Измерение Из ПостроительОтчета.ИзмеренияСтроки Цикл
		
		СтрокаИзмерений = СтрокаИзмерений + ", " + Измерение.Представление;
		
	КонецЦикла;
	
	ТекстПроИтоги = ТекстПроИтоги + Сред(СтрокаИзмерений, 3);
		
	Возврат ТекстПроИтоги;
	
КонецФункции

///////////////////////////////////////////////////////////////////////////////
//ОБОРОТНО-САЛЬДОВАЯ ВЕДОМОСТЬ
///////////////////////////////////////////////////////////////////////////////

//функция возвращает структуру форматов показателей по массиву показателей
Функция СформироватьСтруктуруФорматовПоказателей(Знач МассивПоказателей, Знач ИмяРегистраБухгалтерии) Экспорт
	
	ФорматПоказателей = Новый Структура();
	
	Для Каждого ИмяПоказателя Из МассивПоказателей Цикл
		
		Ресурс = Метаданные.РегистрыБухгалтерии[ИмяРегистраБухгалтерии].Ресурсы.Найти(ИмяПоказателя);
		Если Ресурс <> Неопределено Тогда
			
			ФорматПоказателей.Вставить(ИмяПоказателя,"ЧЦ = " + Ресурс.Тип.КвалификаторыЧисла.Разрядность
			+ " ; ЧДЦ = " + Ресурс.Тип.КвалификаторыЧисла.РазрядностьДробнойЧасти);
			
		Иначе // по умолчанию - сумма
			ФорматПоказателей.Вставить(ИмяПоказателя ,"ЧЦ = 15 ; ЧДЦ = 2");
			
		КонецЕсли;
		
	КонецЦикла;
	
	Возврат ФорматПоказателей;
	
КонецФункции

//Функция возвращает видсубконто по имени
Функция ВернутьСубконтоПоИмени(Знач Счет, Знач ИмяСубконто)
	
	// Найдем соответствующий вид субконто
	Для Каждого ВидСубконто Из Счет.ВидыСубконто Цикл
			
		Если "Субконто" + ВидСубконто.НомерСтроки = ИмяСубконто Тогда
				
			Возврат ВидСубконто;
				
		КонецЕсли;
			
	КонецЦикла;
	
	Возврат Неопределено;
	
КонецФункции

//Функция возвращает можно ил использовать составной запрос для детализации по субконто
Функция ОпределитьМожноИспользоватьСоставнойЗапросПоСубконто(ПравилаСчета)
	
	// Определим признак использования составного запроса
	Для Каждого СтрокаПоСубконто Из ПравилаСчета.РазворотПоСубконто Цикл
		
		ВидСубконто = ВернутьСубконтоПоИмени(ПравилаСчета.Счет, СтрокаПоСубконто.Имя);
		
		Если (ВидСубконто <> Неопределено)
			 И (ВидСубконто.ВидСубконто.ТипЗначения.Типы().Количество() > 10) Тогда
			 
			Возврат Ложь;
			
		КонецЕсли;
								
	КонецЦикла;

	Возврат Истина;
	
КонецФункции

//Процедура формирует строку ограничений для выборки из таблицы оборотов и остатков регистров бухгалтерии
Процедура ДополнитьСтрокуОграниченийПоРеквизитам(СтрокаОграничения, Знач ИмяОграниченияПоРеквизиту, Знач ОграничениеПоРеквизиту) Экспорт
	
	Если НЕ ЗначениеЗаполнено(ОграничениеПоРеквизиту) и не ТипЗнч(ОграничениеПоРеквизиту) = Тип("СправочникСсылка.СценарииПланирования") Тогда
		Возврат;
	КонецЕсли;
	
	СтрокаНовогоОграничения = ИмяОграниченияПоРеквизиту + " = &" + ИмяОграниченияПоРеквизиту + " ";
	
	СтрокаОграничения = ОбъединитьОграничения(СтрокаОграничения, СтрокаНовогоОграничения);
    
КонецПроцедуры

//Функция Объединяет ограничения
Функция ОбъединитьОграничения(Знач Ограничение1, Знач Ограничение2, Знач СтрокаОбъединенияОграничений = "И") Экспорт
	
	Если ПустаяСтрока(Ограничение1) Тогда
		Возврат Ограничение2;
	КонецЕсли;
	
	Если ПустаяСтрока(Ограничение2) Тогда
		Возврат Ограничение1;
	КонецЕсли;
	
	СтрокаОграничения = Ограничение1 + " " + СтрокаОбъединенияОграничений + " " + Ограничение2;
	
	Возврат СтрокаОграничения;
	
КонецФункции

//Функция формирует текст строки запроса для выборки данных оборотов и остатков регистра бухгалтерии
Функция СформироватьТекстВыборкиИзТаблицыОборотовИОстатковРегистраБухгалтерии(СтруктураПараметров, 
	Знач ИмяАлиасаТаблицы = "ОстаткиИОбороты", Знач ДопОграничениеПоСчету = "" ) Экспорт
	
	СтрокаОграниченийПоРеквизитам = "";
	ДополнитьСтрокуОграниченийПоРеквизитам(СтрокаОграниченийПоРеквизитам, "Организация", СтруктураПараметров.СтруктураОграничений.Организация);
	ДополнитьСтрокуОграниченийПоРеквизитам(СтрокаОграниченийПоРеквизитам, "ВидУчета", СтруктураПараметров.СтруктураОграничений.ВидУчета);
	ДополнитьСтрокуОграниченийПоРеквизитам(СтрокаОграниченийПоРеквизитам, "ОтражениеВНУ", СтруктураПараметров.СтруктураОграничений.ОтражениеВНУ);
	ДополнитьСтрокуОграниченийПоРеквизитам(СтрокаОграниченийПоРеквизитам, "Валюта", СтруктураПараметров.СтруктураОграничений.Валюта);
	ДополнитьСтрокуОграниченийПоРеквизитам(СтрокаОграниченийПоРеквизитам, "Сценарий", СтруктураПараметров.СтруктураОграничений.Сценарий);
		
	СтрокаСвязкиДопОграниченияПоСчету = ?(ПустаяСтрока(ДопОграничениеПоСчету), "", " И ");
	
	СтрокаЧастиЗапроса = "
			|ИЗ
			|	РегистрБухгалтерии." + СтруктураПараметров.СтруктураОграничений.ИмяРегистраБухгалтерии + ".ОстаткиИОбороты( "
			+ ?(СтруктураПараметров.СтруктураОграничений.ДатаНач = '00010101000000', "", "&НачПериода") + ", "
			+ ?(СтруктураПараметров.СтруктураОграничений.ДатаКон = '00010101000000', "", "&КонПериода") 
			+ ", , , " + ДопОграничениеПоСчету  
			+ ?(СтруктураПараметров.СтруктураОграничений.ИспользоватьОграниченияПоЗабалансовымСчетам = Ложь 
				ИЛИ СтруктураПараметров.СтруктураОграничений.ПоЗабалансовымСчетам = Истина, "", СтрокаСвязкиДопОграниченияПоСчету + " НЕ Счет.Забалансовый ") + ", "
			+ ", "
			+ СтрокаОграниченийПоРеквизитам + ") КАК " + ИмяАлиасаТаблицы;
			
	Возврат СтрокаЧастиЗапроса;		
	
КонецФункции

//Функция дополняет текст часть сформированного запроса по определенным полям
Функция ВернутьЧастьЗапросаПоВыборкеПолейОборотноСальдоваяВедомость(МассивПоказателей, Знач ПоляДляВыборки = Истина, 
		Знач ИспользоватьАлиасыПолей = Ложь, Знач ИспользоватьВКачествеПрефиксаАлиасаИмяПоказателя = Ложь, ПолучатьРазвернутыйОстаток = Ложь) Экспорт
		
	СтрокаЗапроса = "";	
	РазвернутыйОстаток = ?(ПолучатьРазвернутыйОстаток, "Развернутый", "");
			
	Если ПоляДляВыборки Тогда
		
		Если ИспользоватьАлиасыПолей Тогда
			// выборка с алиасами
			Для Каждого ИмяПоказателя Из МассивПоказателей Цикл
				
				СтрокаПрефикса = ?(ИспользоватьВКачествеПрефиксаАлиасаИмяПоказателя, ИмяПоказателя, ""); 
							
				СтрокаЗапроса =  СтрокаЗапроса + ",
				|	" + ИмяПоказателя + "Начальный" + РазвернутыйОстаток + "ОстатокДт КАК " + СтрокаПрефикса + "НачальныйОстатокДт,
				|	" + ИмяПоказателя + "Начальный" + РазвернутыйОстаток + "ОстатокКт КАК " + СтрокаПрефикса + "НачальныйОстатокКт,
				|	" + ИмяПоказателя + "ОборотДт КАК "                                     + СтрокаПрефикса + "ОборотДт,
				|	" + ИмяПоказателя + "ОборотКт КАК "                                     + СтрокаПрефикса + "ОборотКт,
				|	" + ИмяПоказателя + "Конечный" + РазвернутыйОстаток + "ОстатокДт КАК "  + СтрокаПрефикса + "КонечныйОстатокДт,
				|	" + ИмяПоказателя + "Конечный" + РазвернутыйОстаток + "ОстатокКт КАК "  + СтрокаПрефикса + "КонечныйОстатокКт";
					
			КонецЦикла;
			
		Иначе	
			// выборка без алиасов
			Для Каждого ИмяПоказателя Из МассивПоказателей Цикл
				
				СтрокаЗапроса =  СтрокаЗапроса + ",
				|	" + ИмяПоказателя + "Начальный" + РазвернутыйОстаток + "ОстатокДт,
				|	" + ИмяПоказателя + "Начальный" + РазвернутыйОстаток + "ОстатокКт,
				|	" + ИмяПоказателя + "ОборотДт,
				|	" + ИмяПоказателя + "ОборотКт,
				|	" + ИмяПоказателя + "Конечный" + РазвернутыйОстаток + "ОстатокДт,
				|	" + ИмяПоказателя + "Конечный" + РазвернутыйОстаток + "ОстатокКт";
								
			КонецЦикла;
            	

		КонецЕсли;	
		
	Иначе
		// выборка для суммирования
		Для Каждого ИмяПоказателя Из МассивПоказателей Цикл
						
			СтрокаЗапроса = СтрокаЗапроса + ",
			|	СУММА(" + ИмяПоказателя + "Начальный" + РазвернутыйОстаток + "ОстатокДт),
			|	СУММА(" + ИмяПоказателя + "Начальный" + РазвернутыйОстаток + "ОстатокКт),
			|	СУММА(" + ИмяПоказателя + "ОборотДт),
			|	СУММА(" + ИмяПоказателя + "ОборотКт),
			|	СУММА(" + ИмяПоказателя + "Конечный" + РазвернутыйОстаток + "ОстатокДт),
			|	СУММА(" + ИмяПоказателя + "Конечный" + РазвернутыйОстаток + "ОстатокКт)";

					
		КонецЦикла;
		
	КонецЕсли;
	
	Возврат СтрокаЗапроса;
	
КонецФункции

//Функция возвращает часть запроса для иерархического вывода результатов отчета
Функция ПолучитьПоТипуИзмеренияПостроителяОтчетаСтрокуЗапроса(Знач ТипИзмерения) Экспорт
	
	Если ТипИзмерения = ТипИзмеренияПостроителяОтчета.Иерархия Тогда
		Возврат " ИЕРАРХИЯ";
	ИначеЕсли ТипИзмерения = ТипИзмеренияПостроителяОтчета.ТолькоИерархия Тогда	
		Возврат " ТОЛЬКО ИЕРАРХИЯ";
	Иначе	
		Возврат "";
	КонецЕсли;
	
КонецФункции

// Формирует запросы по каждому счету, указанному в таблице вывода итогов
//
// Параметры:
//	Нет.
//
// Возвращаемое значение:
//	Таблица запросов
//
Функция СформироватьТаблицуДанныхРазворотаСчетов(СтруктураПараметров, Знач ПравилаВыводаИтогов)

	// Результат функции будут укладываться в таблицу
	ТаблицаРазворотаСчетов = Новый ТаблицаЗначений;
	ТаблицаРазворотаСчетов.Колонки.Добавить("Счет");
	ТаблицаРазворотаСчетов.Колонки.Добавить("Результат");
	ТаблицаРазворотаСчетов.Колонки.Добавить("МассивГруппировок");
	ТаблицаРазворотаСчетов.Колонки.Добавить("СоответсвиеСчетов");

	Если НЕ СтруктураПараметров.СтруктураОграничений.ПоСубсчетамИСубконто
		ИЛИ ПравилаВыводаИтогов.Количество() = 0 Тогда
		
		Возврат ТаблицаРазворотаСчетов;
		
	КонецЕсли;

	Запрос = Новый Запрос;
	Запрос.УстановитьПараметр("НачПериода", НачалоДня(СтруктураПараметров.СтруктураОграничений.ДатаНач));
	Запрос.УстановитьПараметр("КонПериода", КонецДня(СтруктураПараметров.СтруктураОграничений.ДатаКон));
	Запрос.УстановитьПараметр("Организация", СтруктураПараметров.СтруктураОграничений.Организация);
	Запрос.УстановитьПараметр("ВидУчета", СтруктураПараметров.СтруктураОграничений.ВидУчета);
	Запрос.УстановитьПараметр("Валюта",  СтруктураПараметров.СтруктураОграничений.Валюта);
	Запрос.УстановитьПараметр("ОтражениеВНУ",  СтруктураПараметров.СтруктураОграничений.ОтражениеВНУ);
	Запрос.УстановитьПараметр("Сценарий",  СтруктураПараметров.СтруктураОграничений.Сценарий);
		
	// Сформируем текст запроса
	Для Каждого ПравилаСчета из ПравилаВыводаИтогов Цикл
		
		Если ПравилаСчета.Счет.Пустая()
			ИЛИ (НЕ ПравилаСчета.Субсчета
				И ПравилаСчета.РазворотПоСубконто.Количество() = 0) Тогда
				
			Продолжить; // неправильно заполненная строка, не обрабатываем
				
		КонецЕсли;
		
		ТекстЗапроса = "";
		ТекстИтогов  = "";
		ТекстВыбранныеПоля = "";
		ТекстИтогиПо = "";
					
		МассивГруппировок = Новый Массив;
			
		Запрос.УстановитьПараметр("Счет", ПравилаСчета.Счет);

		ТекстЗапроса = 
		"ВЫБРАТЬ
		|	Счет КАК Счет";
			
		ТекстВнеш = 
		"ВЫБРАТЬ РАЗРЕШЕННЫЕ
		|	Счет КАК Счет,
		|	Счет.Код КАК СчетКод,
		|	Счет.Наименование КАК СчетНаименование,
		|	Счет.Представление КАК СчетПредставление,
		|	Счет.Забалансовый КАК СчетЗабалансовый";

		Если СтруктураПараметров.СтруктураОграничений.ПоВалютам Тогда
			ТекстЗапроса = ТекстЗапроса + ",
			|	Валюта КАК Валюта";
				
			ТекстВнеш = ТекстВнеш + ",
			|	Валюта КАК Валюта,
			|	Валюта.Представление КАК ВалютаПредставление ";
		КонецЕсли;
		
		МассивГруппировок.Добавить("Счет");
		Если ПравилаСчета.Субсчета Тогда
			
			ТекстИтогиПо = ТекстИтогиПо + ", Счет ИЕРАРХИЯ";
						
		Иначе
				
			ТекстИтогиПо = ТекстИтогиПо + ", Счет ";
							
		КонецЕсли;
		
		// признак того, что можно использовать вложенный запрос 
		МожноИспользоватьСоставнойЗапрос = ОпределитьМожноИспользоватьСоставнойЗапросПоСубконто(ПравилаСчета);
						
		Для Каждого СтрокаПоСубконто Из ПравилаСчета.РазворотПоСубконто Цикл
			
			ВидСубконто = ВернутьСубконтоПоИмени(ПравилаСчета.Счет, СтрокаПоСубконто.Имя);
			
			Если ВидСубконто = Неопределено Тогда
				Продолжить;
			КонецЕсли;
				
			Сч = ВидСубконто.НомерСтроки;
				
			// Определим тип значения поля и в соответствии с этим типом добавим поле запроса
			ТипыСубконто = ВидСубконто.ВидСубконто.ТипЗначения;
			Выб = "";
			ВыбИначе = "";
			
			ЕстьПредставление = Истина;
			Для Каждого Элемент Из ТипыСубконто.Типы() Цикл
				
				ОбъектМетаданных = Метаданные.НайтиПоТипу(Элемент);
				
				Если ОбъектМетаданных <> Неопределено Тогда
					
					ИмяТаблицы = ОбъектМетаданных.ПолноеИмя();
					Выб = Выб + "КОГДА #Поле ССЫЛКА " + ИмяТаблицы + " ТОГДА ВЫРАЗИТЬ( #Поле КАК (" + ИмяТаблицы + "))";
						
					Если Метаданные.Перечисления.Найти(ОбъектМетаданных.Имя) <> Неопределено Тогда
						ЕстьПредставление = Ложь;
					КонецЕсли;
					
				Иначе
					// Для примитивных типов придется добавлять само значение
					ВыбИначе = " #Поле ";
					ЕстьПредставление = Ложь;
					
				КонецЕсли;
					
			КонецЦикла;
			
			// окончательное формирование строки выбора поля
			Если НЕ ПустаяСтрока(Выб) Тогда
				
				Если НЕ ПустаяСтрока(ВыбИначе) Тогда
					СтрПоле = "
					|	ВЫБОР " + Выб + " ИНАЧЕ " + ВыбИначе + " КОНЕЦ";
				Иначе
					СтрПоле = "
					|	ВЫБОР " + Выб + " КОНЕЦ";
				КонецЕсли;
				
			Иначе
				
				СтрПоле = ВыбИначе;
				
			КонецЕсли;
				
			ТекстВыбранныеПоля = ТекстВыбранныеПоля + ", " + СтрЗаменить(СтрПоле, "#Поле", " ОстаткиИОбороты.Субконто"  + Сч) + " КАК Субконто" + Сч;
			
			СтрокаТипИзмерения = ПолучитьПоТипуИзмеренияПостроителяОтчетаСтрокуЗапроса(ПолучитьТипИзмеренияПостроителяОтчетаПоУмолчанию());
			ТекстИтогиПо = ТекстИтогиПо + ", " + СтрокаПоСубконто.Имя + СтрокаТипИзмерения;
			
			// само поле
			ТекстВнеш  = ТекстВнеш + ", " + СтрокаПоСубконто.Имя;
			// поле представления
			ТекстВнеш  = ТекстВнеш + ", " + СтрокаПоСубконто.Имя;
			
			Если ЕстьПредставление 
				И МожноИспользоватьСоставнойЗапрос Тогда
				
				ТекстВнеш  = ТекстВнеш + ".Представление ";
				
			КонецЕсли;
			
			ТекстВнеш  = ТекстВнеш + " КАК " + СтрокаПоСубконто.Имя + "Представление";
				
			МассивГруппировок.Добавить(СтрокаПоСубконто.Имя);
				
		КонецЦикла; 

		ТекстЗапроса = ТекстЗапроса + ТекстВыбранныеПоля;

			
		// Добавим в текст запроса все выбранные ресурсы 
			
		ТекстЗапроса = ТекстЗапроса + ВернутьЧастьЗапросаПоВыборкеПолейОборотносальдоваяВедомость(СтруктураПараметров.МассивПоказателей, Истина, 
				Истина, Истина);
			
		ТекстВнеш = ТекстВнеш + ВернутьЧастьЗапросаПоВыборкеПолейОборотносальдоваяВедомость(СтруктураПараметров.МассивПоказателей, Истина);
			
		ТекстИтогов = ТекстИтогов + ВернутьЧастьЗапросаПоВыборкеПолейОборотносальдоваяВедомость(СтруктураПараметров.МассивПоказателей, Ложь);
						
		СтрокаТекстаВыборкиИзТаблицы = СформироватьТекстВыборкиИзТаблицыОборотовИОстатковРегистраБухгалтерии(СтруктураПараметров, ,
			"Счет В ИЕРАРХИИ (&Счет)");
		
		Если МожноИспользоватьСоставнойЗапрос Тогда
			
			ТекстЗапроса = ТекстЗапроса + СтрокаТекстаВыборкиИзТаблицы;
							
			ТекстЗапроса = ТекстВнеш + " ИЗ (" + ТекстЗапроса + " ) КАК Подзапрос 
			|	АВТОУПОРЯДОЧИВАНИЕ";
			
		Иначе
				
			ТекстЗапроса = ТекстВнеш + СтрокаТекстаВыборкиИзТаблицы + "
			|	АВТОУПОРЯДОЧИВАНИЕ";;
				
		КонецЕсли;

		Если Не ПустаяСтрока(ТекстИтогиПо) Тогда
			
			ТекстЗапроса = ТекстЗапроса + "
			|ИТОГИ ";

			ТекстЗапроса = ТекстЗапроса + Сред(ТекстИтогов, 2);

			ТекстЗапроса = ТекстЗапроса + "
			|ПО " + Сред(ТекстИтогиПо, 2);

			Если СтруктураПараметров.СтруктураОграничений.ПоВалютам Тогда
				
				ТекстЗапроса = ТекстЗапроса + ",
				|	Валюта КАК Валюта ";
				
			КонецЕсли;

		КонецЕсли;
			
		Запрос.Текст = ТекстЗапроса;

		НоваяСтрока = ТаблицаРазворотаСчетов.Добавить();
		НоваяСтрока.Счет      = ПравилаСчета.Счет;
		НоваяСтрока.Результат = Запрос.Выполнить(); // в таблицу помещается выполненный запрос
		НоваяСтрока.МассивГруппировок = МассивГруппировок;
		
		ИмяПланаСчетов = Метаданные.РегистрыБухгалтерии[СтруктураПараметров.СтруктураОграничений.ИмяРегистраБухгалтерии].ПланСчетов.Имя;
		
		СооответствиеСчетов = ВернутьСоответвиеПодчиненныхСчетов(ИмяПланаСчетов, ПравилаСчета.Счет);
		НоваяСтрока.СоответсвиеСчетов = СооответствиеСчетов;
							
	КонецЦикла;

	Возврат ТаблицаРазворотаСчетов;
	
КонецФункции

// Формирует запросы по каждому из счетов, указанному в таблице развернутого сальдо
//
// Параметры:
//	Нет.
//
// Возвращаемое значение:
//	Таблица запросов
//
Функция СформироватьТаблицуДанныхРазвернутогоСальдо(СтруктураПараметров, ПравилаРазвернутогоСальдо)

	// Результат Каждого запроса будет укладываться в специальную таблицу
	ТаблицаРазвернутогоСальдо = Новый ТаблицаЗначений;
	ТаблицаРазвернутогоСальдо.Колонки.Добавить("Счет");
	ТаблицаРазвернутогоСальдо.Колонки.Добавить("Результат");
	
	Если НЕ СтруктураПараметров.СтруктураОграничений.ВыводитьРазвернутоеСальдо
		ИЛИ (ПравилаРазвернутогоСальдо.Количество() = 0) Тогда
		
		Возврат ТаблицаРазвернутогоСальдо;
		
	КонецЕсли;

	Запрос = Новый Запрос;
	Запрос.УстановитьПараметр("НачПериода", НачалоДня(СтруктураПараметров.СтруктураОграничений.ДатаНач));
	Запрос.УстановитьПараметр("КонПериода", КонецДня(СтруктураПараметров.СтруктураОграничений.ДатаКон));
	Запрос.УстановитьПараметр("Организация", СтруктураПараметров.СтруктураОграничений.Организация);
	Запрос.УстановитьПараметр("ВидУчета", СтруктураПараметров.СтруктураОграничений.ВидУчета);
	Запрос.УстановитьПараметр("Валюта",  СтруктураПараметров.СтруктураОграничений.Валюта);
	Запрос.УстановитьПараметр("ОтражениеВНУ",  СтруктураПараметров.СтруктураОграничений.ОтражениеВНУ);
	Запрос.УстановитьПараметр("Сценарий",  СтруктураПараметров.СтруктураОграничений.Сценарий);
	
	// Сформируем текст запроса
	Для Каждого ПравилаСчета из ПравилаРазвернутогоСальдо Цикл
		
		Если ПравилаСчета.Счет.Пустая()
			ИЛИ (НЕ ПравилаСчета.Субсчета
				И ПравилаСчета.РазворотПоСубконто.Количество() = 0) Тогда
				
			Продолжить; // неправильно заполненная строка, не обрабатываем
				
		КонецЕсли;
		
		ТекстЗапроса = "";
		ТекстИтогов  = "";
		ТекстВыбранныеПоля = "";
			
		ТекстИтогиПо = "";
			
		МассивГруппировок = Новый Массив;
							
		МассивГруппировок.Добавить("Общие"); // всегда есть общий итог
			
		Запрос.УстановитьПараметр("Счет", ПравилаСчета.Счет);
			
		ТекстЗапроса =  
		"ВЫБРАТЬ РАЗРЕШЕННЫЕ
		|	Счет КАК Счет ";
			
		Если СтруктураПараметров.СтруктураОграничений.ПоВалютам Тогда
			ТекстЗапроса = ТекстЗапроса + ",
			|	Валюта КАК Валюта,
			|	Валюта.Представление КАК ВалютаПредставление ";
		КонецЕсли;
			
		// Развернутое сальдо может быть подсчитано либо по субсчетам, либо по субконто
		Если ПравилаСчета.Субсчета Тогда
				
			ТекстИтогиПо = ТекстИтогиПо + ", Счет ТОЛЬКО ИЕРАРХИЯ";
				
			МассивГруппировок.Добавить("Счет");
		Иначе
				
			Для Каждого СтрокаПоСубконто Из ПравилаСчета.РазворотПоСубконто Цикл
					
				ТекстВыбранныеПоля = ТекстВыбранныеПоля + ",
				|	" + СтрокаПоСубконто.Имя + " КАК " + СтрокаПоСубконто.Имя;
					
				ТекстИтогиПо = ТекстИтогиПо + ", " + СтрокаПоСубконто.Имя;
					
				МассивГруппировок.Добавить(СтрокаПоСубконто.Имя);
					
			КонецЦикла; 
				
			ТекстЗапроса = ТекстЗапроса + ТекстВыбранныеПоля;
				
		КонецЕсли;

		// Добавим в текст запроса все выбранные ресурсы 
		Для Каждого ИмяПоказателя Из СтруктураПараметров.МассивПоказателей Цикл
				
			ТекстЗапроса = ТекстЗапроса + ",
			|	" + ИмяПоказателя + "НачальныйРазвернутыйОстатокДт КАК " + ИмяПоказателя + "НачальныйРазвернутыйОстатокДт,
			|	" + ИмяПоказателя + "НачальныйРазвернутыйОстатокКт КАК " + ИмяПоказателя + "НачальныйРазвернутыйОстатокКт,
			|	" + ИмяПоказателя + "КонечныйРазвернутыйОстатокДт КАК "  + ИмяПоказателя + "КонечныйРазвернутыйОстатокДт,
			|	" + ИмяПоказателя + "КонечныйРазвернутыйОстатокКт КАК "  + ИмяПоказателя + "КонечныйРазвернутыйОстатокКт";
				
			ТекстИтогов = ТекстИтогов + ",
			|	СУММА(" + ИмяПоказателя + "НачальныйРазвернутыйОстатокДт),
			|	СУММА(" + ИмяПоказателя + "НачальныйРазвернутыйОстатокКт),
			|	СУММА(" + ИмяПоказателя + "КонечныйРазвернутыйОстатокДт),
			|	СУММА(" + ИмяПоказателя + "КонечныйРазвернутыйОстатокКт)";
				
		КонецЦикла;
			
		СтрокаТекстаВыборкиИзТаблицы = СформироватьТекстВыборкиИзТаблицыОборотовИОстатковРегистраБухгалтерии(СтруктураПараметров, ,
			"Счет В ИЕРАРХИИ (&Счет)");
			
		ТекстЗапроса = ТекстЗапроса + СтрокаТекстаВыборкиИзТаблицы;
 			

		Если Не ПустаяСтрока(ТекстИтогиПо) Тогда
			
			ТекстЗапроса = ТекстЗапроса + "
			|ИТОГИ ";

			ТекстЗапроса = ТекстЗапроса + Сред(ТекстИтогов, 2);

			ТекстЗапроса = ТекстЗапроса + "
			|ПО ОБЩИЕ " + ТекстИтогиПо;

			Если СтруктураПараметров.СтруктураОграничений.ПоВалютам Тогда
				ТекстЗапроса = ТекстЗапроса + ",
				|	Валюта КАК Валюта ";
			КонецЕсли;

		КонецЕсли;

		Запрос.Текст = ТекстЗапроса;

		НоваяСтрока = ТаблицаРазвернутогоСальдо.Добавить();
		НоваяСтрока.Счет      = ПравилаСчета.Счет;
		НоваяСтрока.Результат = Запрос.Выполнить(); // в таблицу помещается выполненный запрос
			
	КонецЦикла;

	Возврат ТаблицаРазвернутогоСальдо;

КонецФункции

//Функция формирует структуру параметров ограничений для оборотно-сальдовой ведомости
Функция СформироватьСтруктуруОграниченийДляОборотноСальдовойВедомости(ОбъектОтчета,
		Знач ПоВалютам, Знач ИспользоватьОграниченияПоЗабалансовымСчетам, Знач ПоЗабалансовымСчетам = Ложь, 
		Знач ВидУчета = Неопределено, Знач Валюта = Неопределено, Знач ОтражениеВНУ = Неопределено,
		Знач Сценарий = Неопределено, Знач ВВалютеСценария = Неопределено)
	
	Структура = Новый Структура();
	Структура.Вставить("ДатаНач", ОбъектОтчета.ДатаНач);
	Структура.Вставить("ДатаКон", ОбъектОтчета.ДатаКон);
	Попытка
		Структура.Вставить("Организация", ОбъектОтчета.Организация);
	Исключение
		Структура.Вставить("Организация", Неопределено);
	КонецПопытки;
	
	Структура.Вставить("ПоСубсчетамИСубконто", ОбъектОтчета.ПоСубсчетамИСубконто);
	Структура.Вставить("ВыводитьРазвернутоеСальдо", ОбъектОтчета.ВыводитьРазвернутоеСальдо);
	
	Структура.Вставить("ПоВалютам", ПоВалютам);
	Структура.Вставить("ИспользоватьОграниченияПоЗабалансовымСчетам", ИспользоватьОграниченияПоЗабалансовымСчетам);
	Структура.Вставить("ПоЗабалансовымСчетам", ПоЗабалансовымСчетам);
	
	Структура.Вставить("ВидУчета", ВидУчета);	
	
	Структура.Вставить("Валюта",  Валюта);
	Структура.Вставить("ОтражениеВНУ",  ОтражениеВНУ);
	
	Структура.Вставить("Сценарий",  Сценарий);
	
	Структура.Вставить("ВВалютеСценария",  ВВалютеСценария);
	
	Структура.Вставить("ИмяРегистраБухгалтерии", ОбъектОтчета.ИмяРегистраБухгалтерии);
	
	Возврат Структура; 
	
КонецФункции

// процедура инициализирует структуру в которой хранятся итоговые суммы документа
Процедура ИнициализироватьСтруктуруХраненияИтоговОборотка(Знач МассивПоказателей, СтруктураОбщийИтог)
	
	Для Каждого ИмяПоказателя Из МассивПоказателей Цикл
		
		СтруктураОбщийИтог.Вставить(ИмяПоказателя + "НачальныйОстатокДт", 0);
		СтруктураОбщийИтог.Вставить(ИмяПоказателя + "НачальныйОстатокКт", 0);
		СтруктураОбщийИтог.Вставить(ИмяПоказателя + "КонечныйОстатокДт", 0);
		СтруктураОбщийИтог.Вставить(ИмяПоказателя + "КонечныйОстатокКт", 0);
		СтруктураОбщийИтог.Вставить(ИмяПоказателя + "ОборотДт", 0);
		СтруктураОбщийИтог.Вставить(ИмяПоказателя + "ОборотКт", 0);
						
	КонецЦикла;
	
КонецПроцедуры

// процедура добавляет в итоговое хранилище сумм текущие данных
Процедура ДополнитьСтруктуруХраненияИтоговОборотка(Знач ИмяПоказателя, СтруктураОбщийИтог,
	Знач НачальныйОстатокДт, Знач НачальныйОстатокКт, Знач КонечныйОстатокДт, Знач КонечныйОстатокКт,
	Знач ОборотДт, Знач ОборотКт)
	
	СтруктураОбщийИтог[ИмяПоказателя + "НачальныйОстатокДт"] = СтруктураОбщийИтог[ИмяПоказателя + "НачальныйОстатокДт"] + НачальныйОстатокДт;
	СтруктураОбщийИтог[ИмяПоказателя + "НачальныйОстатокКт"] = СтруктураОбщийИтог[ИмяПоказателя + "НачальныйОстатокКт"] + НачальныйОстатокКт;
	СтруктураОбщийИтог[ИмяПоказателя + "КонечныйОстатокДт"] =  СтруктураОбщийИтог[ИмяПоказателя + "КонечныйОстатокДт" ] + КонечныйОстатокДт;
	СтруктураОбщийИтог[ИмяПоказателя + "КонечныйОстатокКт"] =  СтруктураОбщийИтог[ИмяПоказателя + "КонечныйОстатокКт" ] + КонечныйОстатокКт;
	СтруктураОбщийИтог[ИмяПоказателя + "ОборотДт"] =           СтруктураОбщийИтог[ИмяПоказателя + "ОборотДт"]           + ОборотДт;
	СтруктураОбщийИтог[ИмяПоказателя + "ОборотКт"] =           СтруктураОбщийИтог[ИмяПоказателя + "ОборотКт"]           + ОборотКт;
	
КонецПроцедуры

// процедура выводит текущие данные оборотки в область вывода
Процедура ЗаполнитьДаннымОблатьВыводаОборотка(Область, Знач ФорматПоказателя, 
	Знач НачальныйОстатокДт, Знач НачальныйОстатокКт, 
	Знач КонечныйОстатокДт, Знач КонечныйОстатокКт, 
	Знач ОборотДт, Знач ОборотКт)
	
	Область.Параметры.НачальныйОстатокДт = Формат(НачальныйОстатокДт, ФорматПоказателя);
	Область.Параметры.НачальныйОстатокКт = Формат(НачальныйОстатокКт, ФорматПоказателя);
	Область.Параметры.КонечныйОстатокДт  = Формат(КонечныйОстатокДт,  ФорматПоказателя);
	Область.Параметры.КонечныйОстатокКт  = Формат(КонечныйОстатокКт,  ФорматПоказателя);
	Область.Параметры.ОборотДт           = Формат(ОборотДт,           ФорматПоказателя);
	Область.Параметры.ОборотКт           = Формат(ОборотКт,           ФорматПоказателя);
	
КонецПроцедуры

// Выводит показатели
//
// Параметры:
//	ДокументРезультат - таблица отчета
//	Макет - используемый макет
//	Результат - выборка
//	Счет - счет выборки
//	ЭтоПерваяСтрока - признак вывода отступов перед субконто
//	СтрокаРазвернутогоСальдо - строка с выборкой - развернутым сальдо по счету
//	СтруктураОбщийИтог - структура, в которой накапливается общий итог.
//
Процедура ВывестиПоказателиОборотноСальдовойВедомости(ДокументРезультат, Выборка, Счет, СтрокаРазвернутогоСальдо, СтруктураОбщийИтог, СтруктураПараметров)

	ВыведеноПоказателей = 0;	
	
	ИмяГруппировки = Выборка.Группировка();
	
	Для Каждого ИмяПоказателя Из СтруктураПараметров.МассивПоказателей Цикл

		// Сумму в валюте выводим только по группировке Валюта
		Если ИмяПоказателя = "ВалютнаяСумма" И ИмяГруппировки <> "Валюта" Тогда
			Продолжить;			
		КонецЕсли;
		
		Если ИмяПоказателя = "НДС" И Счет.НДС = Ложь Тогда
			Продолжить;
		КонецЕсли;

		ФорматПоказателя = "";
		СтруктураПараметров.ФорматПоказателей.Свойство(ИмяПоказателя, ФорматПоказателя);

		ВыведеноПоказателей = ВыведеноПоказателей + 1;
		
		Если ВыведеноПоказателей > 1 Тогда
			// без подчеркивания вверху
			Область = СтруктураПараметров.ОбластьСтрокаПоказателяЧисла;
		Иначе
			// есть подчеркивание вверху
			Область = СтруктураПараметров.ОбластьСтрокаЧисла;
		КонецЕсли;

		ОборотДт = Выборка[ИмяПоказателя + "ОборотДт"];
		ОборотКт = Выборка[ИмяПоказателя + "ОборотКт"];

		Если СтрокаРазвернутогоСальдо = Неопределено Тогда

			НачальныйОстатокДт = Выборка[ИмяПоказателя + "НачальныйОстатокДт"];
			НачальныйОстатокКт = Выборка[ИмяПоказателя + "НачальныйОстатокКт"];
			КонечныйОстатокДт  = Выборка[ИмяПоказателя + "КонечныйОстатокДт"];
			КонечныйОстатокКт  = Выборка[ИмяПоказателя + "КонечныйОстатокКт"];

		Иначе

			// Спозиционируемся на самом верхнем итоге
			ВыборкаОбщиеИтоги = СтрокаРазвернутогоСальдо.Результат.Выбрать(ОбходРезультатаЗапроса.ПоГруппировкам);
			
			Если ВыборкаОбщиеИтоги.Следующий() Тогда
				НачальныйОстатокДт = ВыборкаОбщиеИтоги[ИмяПоказателя + "НачальныйРазвернутыйОстатокДт"];
				НачальныйОстатокКт = ВыборкаОбщиеИтоги[ИмяПоказателя + "НачальныйРазвернутыйОстатокКт"];
				КонечныйОстатокДт  = ВыборкаОбщиеИтоги[ИмяПоказателя + "КонечныйРазвернутыйОстатокДт"];
				КонечныйОстатокКт  = ВыборкаОбщиеИтоги[ИмяПоказателя + "КонечныйРазвернутыйОстатокКт"];
			Иначе
				НачальныйОстатокДт = 0;
				НачальныйОстатокКт = 0;
				КонечныйОстатокДт  = 0;
				КонечныйОстатокКт  = 0;
			КонецЕсли;

		КонецЕсли;

		// Накопление итогов по счетам
		НужноДополнятьИтоги = (ИмяГруппировки = "Счет") И (Выборка.Уровень() = 0);
		Если СтруктураПараметров.СтруктураОграничений.ИспользоватьОграниченияПоЗабалансовымСчетам = Истина Тогда 			
			
			НужноДополнятьИтоги = НужноДополнятьИтоги И	НЕ Выборка.СчетЗабалансовый;
			
		КонецЕсли;
			
		Если НужноДополнятьИтоги Тогда

			ДополнитьСтруктуруХраненияИтоговОборотка(ИмяПоказателя, СтруктураОбщийИтог,
				НачальныйОстатокДт, НачальныйОстатокКт, КонечныйОстатокДт, КонечныйОстатокКт,
				ОборотДт, ОборотКт);
				
		КонецЕсли;

		// заполняет данными область вывода
		ЗаполнитьДаннымОблатьВыводаОборотка(Область, ФорматПоказателя, 
			НачальныйОстатокДт, НачальныйОстатокКт, КонечныйОстатокДт,
			КонечныйОстатокКт, ОборотДт, ОборотКт);
			
		Если ВыведеноПоказателей > 1 Тогда

			ОбластьСтрокаПоказателяСчет = СтруктураПараметров.ОбластьСтрокаПоказателяСчет;
			
			Если ИмяПоказателя = "ВалютнаяСумма" Тогда
				ОбластьСтрокаПоказателяСчет.Параметры.СубконтоПредставление = "Валютная сумма";
			Иначе
				ОбластьСтрокаПоказателяСчет.Параметры.СубконтоПредставление = "";
			КонецЕсли;
				
            ВыведеннаяОбласть = ДокументРезультат.Вывести(ОбластьСтрокаПоказателяСчет);
			
			ВыведеннаяОбласть.ГраницаСверху = СтруктураПараметров.НетЛинии;
			
		КонецЕсли;

		ДокументРезультат.Присоединить(Область);
				
	КонецЦикла;

КонецПроцедуры

// Выводит группировку при развороте счета по субсчетам и/или субконто
//
// Параметры:
//	Выборка         - выборка из результата запроса по выводимой группировке,
//	ИндексТекущейГруппировки - индекс выводимой группировки в массиве группировок,
//	МассивГруппировок - массив, содержащий имена группировок, по которым строится разворот счета,
//	Уровень 		- уровень  группировки верхнего уровня
//	СдвигУровня     - сдвиг уровня группировки отчета относительно уровня группировки запроса,
//	СброситьСдвигУровня - признак сброса сдвига уровня,
//	СтрокаРазвернутогоСальдо - строка таблицы значений с развернутым сальдо по текущему счету.
//	СтруктураОбщийИтог - структура, в которой накапливаются общие итоги,
//	ПоследнийВыведенныйСчет - последний выведенный счет,
//	СтруктураПараметров - структура, содержащая неизменные для разворота счета параметры:
//	                      Области макета табличного документа, линии, уровень группировки, 
//	                      с которой начался вывод отчета.
//
Процедура ВывестиГруппировкуОборотноСальдовойВедомости(Выборка, Знач ИндексТекущейГруппировки, МассивГруппировок, Уровень, СдвигУровня, 
	СброситьСдвигУровня, ПоследнийВыведенныйСчет, СтрокаРазвернутогоСальдо, СтруктураОбщийИтог, СтруктураПараметров, 
	ОтборСубконто)

	Пока Выборка.Следующий() Цикл

		ИмяГруппировки = Выборка.Группировка();
		
		// Итоги более высокого уровня по счету - пропускаем (он уже выведен)
		Если ИмяГруппировки = "Счет" Тогда

			// При выводе субсчетов не делаем отступы
			Если СброситьСдвигУровня Тогда
				
				СброситьСдвигУровня = Ложь;
				СдвигУровня = 0;
				
			КонецЕсли;
			
			Отступ = 0;
			СдвигУровня = СдвигУровня + 1;

			// Уже выведенные счета не выводим
			Если ПоследнийВыведенныйСчет = Выборка.Счет 
				ИЛИ ПоследнийВыведенныйСчет.ПринадлежитЭлементу(Выборка.Счет) Тогда
				
				ВывестиВложеннуюГруппировкуОборотноСальдовойВедомости(Выборка, ИндексТекущейГруппировки, МассивГруппировок, Уровень, СдвигУровня, 
					СброситьСдвигУровня, ПоследнийВыведенныйСчет, СтрокаРазвернутогоСальдо, СтруктураОбщийИтог, СтруктураПараметров, ОтборСубконто);
					
				Продолжить;
				
			КонецЕсли;
			
		Иначе
			
			Отступ = Макс(Выборка.Уровень() - СдвигУровня, 0);
			СброситьСдвигУровня = Истина;
			
		КонецЕсли;
		
		ОбластьСтрокаСчет = СтруктураПараметров.ОбластьСтрокаСчет;
		ОбластьСтрокаСчет.Параметры.Заполнить(Выборка);
		
		ВыводимаяОбласть = ОбластьСтрокаСчет;

		// Заполнение параметров расшифровки
		Если ИмяГруппировки = "Счет" Тогда
			
			ЗаполнитьПараметрыРасшифровкиОборотноСальдовойВедомости(СтруктураПараметров.СтруктураОграничений.ДатаНач, 
				СтруктураПараметров.СтруктураОграничений.ДатаКон, СтруктураПараметров.СтруктураОграничений.ИмяРегистраБухгалтерии,
				ОбластьСтрокаСчет, Выборка, , , СтруктураПараметров.СтруктураОграничений.ВВалютеСценария);
				
		КонецЕсли;

		Если Лев(ИмяГруппировки, СтрДлина(ИмяГруппировки) - 1) = "Субконто" тогда

			// Субконто, которых нет, равны NULL
			Если Выборка[ИмяГруппировки] = NULL Тогда
				Продолжить;
			КонецЕсли;

			ОбластьСтрокаПоказателяСчет = СтруктураПараметров.ОбластьСтрокаПоказателяСчет;

			ОбластьСтрокаПоказателяСчет.Параметры.Заполнить(Выборка);

			ОбластьСтрокаПоказателяСчет.Параметры.СубконтоПредставление = Выборка[ИмяГруппировки + "Представление"];
			
			ВыводимаяОбласть = ОбластьСтрокаПоказателяСчет;

			ЗаполнитьПараметрыРасшифровкиОборотноСальдовойВедомости(СтруктураПараметров.СтруктураОграничений.ДатаНач, 
				СтруктураПараметров.СтруктураОграничений.ДатаКон, СтруктураПараметров.СтруктураОграничений.ИмяРегистраБухгалтерии,
				ВыводимаяОбласть, Выборка, ОтборСубконто, ПоследнийВыведенныйСчет, СтруктураПараметров.СтруктураОграничений.ВВалютеСценария);

			ВыводимаяОбласть.Область(1, 4).Отступ = Отступ;
			
			Если Выборка.ТипЗаписи() = ТипЗаписиЗапроса.ИтогПоИерархии Тогда
				ВыводимаяОбласть.Область(1, 4).Шрифт = Новый Шрифт(ВыводимаяОбласть.Область(1, 4).Шрифт,,,,Истина);
			Иначе
				ВыводимаяОбласть.Область(1, 4).Шрифт = Новый Шрифт(ВыводимаяОбласть.Область(1, 4).Шрифт,,,,Ложь);
			КонецЕсли;

		КонецЕсли;

		ДокументРезультат = СтруктураПараметров.ДокументРезультат;
		ДокументРезультат.Вывести(ВыводимаяОбласть, Уровень + Выборка.Уровень());
		
		ВывестиПоказателиОборотноСальдовойВедомости(ДокументРезультат, Выборка, Выборка.Счет, СтрокаРазвернутогоСальдо, СтруктураОбщийИтог, СтруктураПараметров);

		// вывод данных по валютам
		ОбластьСтрокаПоказателяСчет = СтруктураПараметров.ОбластьСтрокаПоказателяСчет;
		ВывестиДанныеПоВалютамОборотноСальдовойВедомости(СтруктураПараметров, ОбластьСтрокаПоказателяСчет, Выборка, ДокументРезультат, 
			СтрокаРазвернутогоСальдо, СтруктураОбщийИтог, Отступ);
		
		ВывестиВложеннуюГруппировкуОборотноСальдовойВедомости(Выборка, ИндексТекущейГруппировки, МассивГруппировок, Уровень, СдвигУровня, 
			СброситьСдвигУровня, ПоследнийВыведенныйСчет, СтрокаРазвернутогоСальдо, СтруктураОбщийИтог, СтруктураПараметров, ОтборСубконто);
											
	КонецЦикла;

КонецПроцедуры

//процедура выводит вложенную группировку
Процедура ВывестиВложеннуюГруппировкуОборотноСальдовойВедомости(Выборка, Знач ИндексТекущейГруппировки, МассивГруппировок, Уровень, СдвигУровня, 
	СброситьСдвигУровня, ПоследнийВыведенныйСчет, СтрокаРазвернутогоСальдо, СтруктураОбщийИтог, СтруктураПараметров, ОтборСубконто)
	
	Если ИндексТекущейГруппировки + 1 >= МассивГруппировок.Количество() Тогда
		Возврат;
	КонецЕсли;
	
	ВывестиГруппировкуОборотноСальдовойВедомости(Выборка.Выбрать(ОбходРезультатаЗапроса.ПоГруппировкам, МассивГруппировок[ИндексТекущейГруппировки + 1]), 
						ИндексТекущейГруппировки + 1, МассивГруппировок, Уровень, 
						СдвигУровня, СброситьСдвигУровня, ПоследнийВыведенныйСчет, 
						СтрокаРазвернутогоСальдо, СтруктураОбщийИтог, СтруктураПараметров, СоздатьКопиюСоответствияСтруктуры(ОтборСубконто));
		
КонецПроцедуры	
					
// процедура Выводит данные по валютам
Процедура ВывестиДанныеПоВалютамОборотноСальдовойВедомости(СтруктураПараметров, ОбластьСтрокаПоказателяСчет, Выборка, 
	ДокументРезультат, СтрокаРазвернутогоСальдо, СтруктураОбщийИтог, Знач Отступ)
	
	// Если по валютам,
	Если СтруктураПараметров.СтруктураОграничений.ПоВалютам Тогда

		ВыборкаПоВалютам = Выборка.Выбрать(ОбходРезультатаЗапроса.ПоГруппировкам, "Валюта");
			
		Пока ВыборкаПоВалютам.Следующий() Цикл

			ОбластьСтрокаПоказателяСчет.Параметры.Заполнить(Выборка);
			ОбластьСтрокаПоказателяСчет.Параметры.СубконтоПредставление = "Валюта " + ВыборкаПоВалютам["ВалютаПредставление"];

			// Заполнение параметров расшифровки
			ЗаполнитьПараметрыРасшифровкиОборотноСальдовойВедомости(СтруктураПараметров.СтруктураОграничений.ДатаНач, 
				СтруктураПараметров.СтруктураОграничений.ДатаКон, СтруктураПараметров.СтруктураОграничений.ИмяРегистраБухгалтерии,
				ОбластьСтрокаПоказателяСчет, Выборка, , , СтруктураПараметров.СтруктураОграничений.ВВалютеСценария);

			ОбластьСтрокаПоказателяСчет.Область(1, 4).Отступ = Отступ + 1;

			ДокументРезультат.Вывести(ОбластьСтрокаПоказателяСчет, Выборка.Уровень());
				
			ВывестиПоказателиОборотноСальдовойВедомости(ДокументРезультат, ВыборкаПоВалютам, ВыборкаПоВалютам.Счет, СтрокаРазвернутогоСальдо, СтруктураОбщийИтог, СтруктураПараметров);

		КонецЦикла;
			
	КонецЕсли;
	
КонецПроцедуры

// процедура формирует отчет оборотно сальдовой ведомости
Процедура СформироватьОтчетОборотноСальдовойВедомости(ОбъектОтчета, ДокументРезультат, ПоказыватьЗаголовок = Истина, ВысотаЗаголовка = 0,
	Знач ПоВалютам, Знач ИспользоватьОграниченияПоЗабалансовымСчетам, Знач ПоЗабалансовымСчетам, 
	Знач ВидУчета = Неопределено, Знач Валюта = Неопределено, Знач ОтражениеВНУ = Неопределено, 
	Знач Сценарий = Неопределено, Знач ВВалютеСценария = Неопределено) Экспорт
    	
	ОграничениеПоДатамКорректно = ПроверитьКорректностьОграниченийПоДатам(ОбъектОтчета.ДатаНач, ОбъектОтчета.ДатаКон);
	Если НЕ ОграничениеПоДатамКорректно Тогда
        Возврат;
	КонецЕсли;

	ДокументРезультат.Очистить();

	СформироватьИВывестиЗаголовокОтчета(ОбъектОтчета, ДокументРезультат, ВысотаЗаголовка, ПоказыватьЗаголовок);
	
	Макет = ПолучитьОбщийМакет("ОборотноСальдоваяВедомость");
		
	ЗаголовокОтчета = Макет.ПолучитьОбласть("ЗаголовокОтчета");
	
	ДокументРезультат.Вывести(ЗаголовокОтчета, 1);

	ДокументРезультат.НачатьАвтогруппировкуСтрок();

	// Используемые области макета
	ОбластьСтрокаСчет           = Макет.ПолучитьОбласть("Строка|Счет");
	ОбластьСтрокаПоказателяСчет = Макет.ПолучитьОбласть("СтрокаПоказателя|Счет");

	// В этой структуре будут храниться постоянные значения, передаваемые во другие процедуры:
	// - формат, 
	// - области макета
	СтруктураПараметров = Новый Структура;
	
	// Переменная, содержащая имена показателей отчета (ресурсов) в виде массива
	МассивПоказателей = ОбъектОтчета.СформироватьМассивПоказателей();
	СтруктураПараметров.Вставить("МассивПоказателей", МассивПоказателей);
	
	// Области для вывода показателей
	СтруктураПараметров.Вставить("ОбластьСтрокаПоказателяЧисла",Макет.ПолучитьОбласть("СтрокаПоказателя|Числа"));
	СтруктураПараметров.Вставить("ОбластьСтрокаЧисла",          Макет.ПолучитьОбласть("Строка|Числа"));
	СтруктураПараметров.Вставить("ОбластьСтрокаПоказателяСчет", Макет.ПолучитьОбласть("СтрокаПоказателя|Счет"));

	// Линии, используемые при выводе
	СтруктураПараметров.Вставить("НетЛинии",    Новый Линия(ТипЛинииЯчейкиТабличногоДокумента.НетЛинии, 1));

	// Формат показателей
	СтруктураФорматовПоказателей = СформироватьСтруктуруФорматовПоказателей(МассивПоказателей, ОбъектОтчета.ИмяРегистраБухгалтерии);
	СтруктураПараметров.Вставить("ФорматПоказателей", СтруктураФорматовПоказателей);
	
	СтруктураПараметровОграничений = СформироватьСтруктуруОграниченийДляОборотноСальдовойВедомости(ОбъектОтчета,
		ПоВалютам, ИспользоватьОграниченияПоЗабалансовымСчетам, ПоЗабалансовымСчетам, ВидУчета, Валюта, ОтражениеВНУ, 
		Сценарий, ВВалютеСценария);
		
	СтруктураПараметров.Вставить("СтруктураОграничений", СтруктураПараметровОграничений);
	
    СтруктураОбщийИтог = Новый Структура;
	ИнициализироватьСтруктуруХраненияИтоговОборотка(МассивПоказателей, СтруктураОбщийИтог);
		
	СоотвПодчСчета = Новый Соответствие;
	
	Запрос = ОбъектОтчета.СформироватьЗапрос(СтруктураПараметров);

	// Рассчитаем итоги по счетам, заданным в таблице вывода итогов по счетам
	ТаблицаРазворотаСчетов = СформироватьТаблицуДанныхРазворотаСчетов(СтруктураПараметров, ОбъектОтчета.ПравилаВыводаИтогов);
	ТаблицаРазворотаСчетов.Индексы.Добавить("Счет");
		
	// Рассчитаем итоги по счетам, заданным в таблице развернутого сальдо
	ТаблицаРазвернутогоСальдо = СформироватьТаблицуДанныхРазвернутогоСальдо(СтруктураПараметров, ОбъектОтчета.ПравилаРазвернутогоСальдо); 
	ТаблицаРазвернутогоСальдо.Индексы.Добавить("Счет");

	РезультатЗапроса = Запрос.Выполнить();

	Выборка = РезультатЗапроса.Выбрать(ОбходРезультатаЗапроса.ПоГруппировкам, "Счет");

	Пока Выборка.Следующий() Цикл
		
		Уровень = Выборка.Уровень();
		
		Если НЕ ОбъектОтчета.ПоСубсчетамИСубконто
			И Уровень > 0 Тогда
						
			Продолжить;
			
		КонецЕсли;
		
		// Пропускаем подчиненные счета разворачиваемого счета
		Если СоотвПодчСчета[Выборка.Счет] <> Неопределено Тогда
			Продолжить;
		КонецЕсли;
		
		ОбластьСтрокаСчет.Параметры.Заполнить(Выборка);
		
		// Заполнение параметров расшифровки
		ЗаполнитьПараметрыРасшифровкиОборотноСальдовойВедомости(ОбъектОтчета.ДатаНач, ОбъектОтчета.ДатаКон, 
			ОбъектОтчета.ИмяРегистраБухгалтерии, ОбластьСтрокаСчет, Выборка, , , ВВалютеСценария);
		
		// выводим текущую строку отчета
		ДокументРезультат.Вывести(ОбластьСтрокаСчет, Уровень);
		
		// Определим, нужно ли выводить развернутое сальдо по счету и
		// разворачивать счет по субконто
		Если ОбъектОтчета.ВыводитьРазвернутоеСальдо Тогда
			СтрокаРазвернутогоСальдо = ТаблицаРазвернутогоСальдо.Найти(Выборка.Счет, "Счет");
		Иначе	
			СтрокаРазвернутогоСальдо = Неопределено;
		КонецЕсли;
		
		Если ОбъектОтчета.ПоСубсчетамИСубконто Тогда
			СтрокаРазворотаСчета = ТаблицаРазворотаСчетов.Найти(Выборка.Счет, "Счет");
		Иначе
			СтрокаРазворотаСчета = Неопределено;
		КонецЕсли;
		
		ВывестиПоказателиОборотноСальдовойВедомости(ДокументРезультат, Выборка, Выборка.Счет, СтрокаРазвернутогоСальдо, СтруктураОбщийИтог, СтруктураПараметров);
		
		ВывестиДанныеПоВалютамОборотноСальдовойВедомости(СтруктураПараметров, ОбластьСтрокаПоказателяСчет, Выборка, ДокументРезультат, СтрокаРазвернутогоСальдо, 
			СтруктураОбщийИтог, -1);
						
		// Вывод разворота счета по субконто
		Если СтрокаРазворотаСчета <> Неопределено Тогда
			
			СтрокаРазвернутогоСальдо = Неопределено;
			СоотвПодчСчета = СтрокаРазворотаСчета.СоответсвиеСчетов;
			
			// Сдвиг уровня выводимой группировки отчета относительно группировки запроса
			СдвигУровня = 0;
			
			// Флаг сброса сдвига уровня при выводе группировки по счету
			СброситьСдвигУровня = Истина;
			
			ВыборкаПоСчету = СтрокаРазворотаСчета.Результат.Выбрать(ОбходРезультатаЗапроса.ПоГруппировкам, СтрокаРазворотаСчета.МассивГруппировок[0]);
			
			СтруктураПараметров.Вставить("ОбластьСтрокаСчет",           ОбластьСтрокаСчет);
			СтруктураПараметров.Вставить("ОбластьСтрокаПоказателяСчет", ОбластьСтрокаПоказателяСчет);
			СтруктураПараметров.Вставить("ДокументРезультат", ДокументРезультат);
			
			//вывод детализированных данных
			ВывестиГруппировкуОборотноСальдовойВедомости(ВыборкаПоСчету, 0, СтрокаРазворотаСчета.МассивГруппировок, 
				Уровень, СдвигУровня, СброситьСдвигУровня, 
				Выборка.Счет, СтрокаРазвернутогоСальдо, 
				СтруктураОбщийИтог, СтруктураПараметров, Новый Соответствие);
			
		КонецЕсли;

	КонецЦикла;

	ДокументРезультат.ЗакончитьАвтогруппировкуСтрок();

	// Выведем итоговую строку
	ОбластьИтогиСчет = Макет.ПолучитьОбласть("Итоги|Счет");
	ДокументРезультат.Вывести(ОбластьИтогиСчет, 0);
	
	ОбластьИтогиСтрокаЧисла = Макет.ПолучитьОбласть("ИтогиСтрока|Числа");
	ОбластьИтогиЧисла       = Макет.ПолучитьОбласть("Итоги|Числа");
	ОбластьИтогиСтрокаСчет  = Макет.ПолучитьОбласть("ИтогиСтрока|Счет");
	
	НомерТекущейСтрокиИтога = 0;	
	Для Каждого ИмяПоказателя Из МассивПоказателей Цикл

		Если НЕ Метаданные.РегистрыБухгалтерии[ОбъектОтчета.ИмяРегистраБухгалтерии].Ресурсы[ИмяПоказателя].Балансовый Тогда
			Продолжить;
		КонецЕсли;

		Если НомерТекущейСтрокиИтога > 0 Тогда
			Область = ОбластьИтогиСтрокаЧисла
		Иначе
			Область = ОбластьИтогиЧисла;
		КонецЕсли;

		ФорматПоказателя = "";
		СтруктураПараметров.ФорматПоказателей.Свойство(ИмяПоказателя, ФорматПоказателя);

		ЗаполнитьДаннымОблатьВыводаОборотка(Область, ФорматПоказателя, 
			СтруктураОбщийИтог[ИмяПоказателя + "НачальныйОстатокДт"], СтруктураОбщийИтог[ИмяПоказателя + "НачальныйОстатокКт"], 
			СтруктураОбщийИтог[ИмяПоказателя + "КонечныйОстатокДт"], СтруктураОбщийИтог[ИмяПоказателя + "КонечныйОстатокКт"], 
			СтруктураОбщийИтог[ИмяПоказателя + "ОборотДт"], СтруктураОбщийИтог[ИмяПоказателя + "ОборотКт"]);
		
		Если НомерТекущейСтрокиИтога > 0 Тогда
			ДокументРезультат.Вывести(ОбластьИтогиСтрокаСчет, 0);
		КонецЕсли;

		ДокументРезультат.Присоединить(Область);
		
		НомерТекущейСтрокиИтога = НомерТекущейСтрокиИтога + 1;

	КонецЦикла;

	ИтогиПодвал = Макет.ПолучитьОбласть("ИтогиПодвал");
   	ДокументРезультат.Вывести(ИтогиПодвал, 0);
	
		
	// Заполним общую расшифровку:
	СтруктураНастроекОтчета = ОбъектОтчета.СформироватьОбщуюСтруктуруДляРасшифровки();
    СтруктураНастроекОтчета.Вставить("ПоказыватьЗаголовок", ПоказыватьЗаголовок);

	ДокументРезультат.Область(1, 1).Расшифровка = СтруктураНастроекОтчета;

    // Зафиксируем заголовок отчета
	ДокументРезультат.ФиксацияСверху = ВысотаЗаголовка + 3;

	// Первую колонку не печатаем
	ДокументРезультат.ОбластьПечати = ДокументРезультат.Область(1, 2, ДокументРезультат.ВысотаТаблицы, ДокументРезультат.ШиринаТаблицы);
	
	// Выводится по ширине листа
	ДокументРезультат.Автомасштаб   = Истина;

	УправлениеОтчетами.УстановитьКолонтитулыПоУмолчанию(ДокументРезультат, ОбъектОтчета.ЗаголовокОтчета(), Строка(ПараметрыСеанса.ТекущийПользователь));
	
КонецПроцедуры

// Заполняет параметры расшифровки переданной области перед выводом в отчет
//
// Параметры:
//	Область - табличный документ, параметры расшифровки которого заполняются,
//	Выборка - спозиционированная выборка из результата запроса,
//	ОтборСубконто - параметр, содержащий таблицу отбора, которая будет использована
//	при построении отчета по расшифровке.
//
Процедура ЗаполнитьПараметрыРасшифровкиОборотноСальдовойВедомости(Знач ДатаНач, Знач ДатаКон, Знач ИмяРегистраБухгалтерии,
	Область, Выборка, ОтборСубконто = Неопределено, ВыведенныйСчет = Неопределено, Знач ВВалютеСценария = Неопределено)
	
	// Заполение значений для расшифровки
	СчетДляРасшифровки = ?(Выборка.Счет <> NULL, Выборка.Счет, ВыведенныйСчет);
	
	// Заполнение параметров расшифровки
	ПараметрыОСВПоСчету = Новый Соответствие;
	ПараметрыОСВПоСчету.Вставить("ИмяОбъекта", "ОборотноСальдоваяВедомостьПоСчету" + ИмяРегистраБухгалтерии);
	ПараметрыОСВПоСчету.Вставить("ЗаполнитьПоУмолчанию", Истина);
	ПараметрыОСВПоСчету.Вставить("Счет", СчетДляРасшифровки);
	Если ВВалютеСценария <> Неопределено Тогда
		ПараметрыОСВПоСчету.Вставить("ВВалютеСценария", ВВалютеСценария);
	КонецЕсли;

	ПараметрыКарточкиСчета = Новый Соответствие;
	ПараметрыКарточкиСчета.Вставить("ИмяОбъекта", "КарточкаСчета" + ИмяРегистраБухгалтерии);
	ПараметрыКарточкиСчета.Вставить("Счет", СчетДляРасшифровки);
	
	ПараметрыАнализСчета = Новый Соответствие;
	ПараметрыАнализСчета.Вставить("ИмяОбъекта", "АнализСчета" + ИмяРегистраБухгалтерии);
	ПараметрыАнализСчета.Вставить("ЗаполнитьПоУмолчанию", Истина);
	ПараметрыАнализСчета.Вставить("Счет", СчетДляРасшифровки);
	Если ВВалютеСценария <> Неопределено Тогда
		ПараметрыАнализСчета.Вставить("ВВалютеСценария", ВВалютеСценария);
	КонецЕсли;
	
	ПараметрыОборотыСчетаМесяц = Новый Соответствие;
	ПараметрыОборотыСчетаМесяц.Вставить("ИмяОбъекта", "ОборотыСчета" + ИмяРегистраБухгалтерии);
	ПараметрыОборотыСчетаМесяц.Вставить("ЗаполнитьПоУмолчанию", Истина);
	ПараметрыОборотыСчетаМесяц.Вставить("Счет", СчетДляРасшифровки);
	ПараметрыОборотыСчетаМесяц.Вставить("Период", "МЕСЯЦ");
	ПараметрыОборотыСчетаМесяц.Вставить("ВсеПериоды",  Истина);
	Если ВВалютеСценария <> Неопределено Тогда
		ПараметрыОборотыСчетаМесяц.Вставить("ВВалютеСценария", ВВалютеСценария);
	КонецЕсли;
	
	ПараметрыОборотыСчетаДень = Новый Соответствие;
	ПараметрыОборотыСчетаДень.Вставить("ИмяОбъекта", "ОборотыСчета" + ИмяРегистраБухгалтерии);
	ПараметрыОборотыСчетаДень.Вставить("ЗаполнитьПоУмолчанию", Истина);
    ПараметрыОборотыСчетаДень.Вставить("Счет", СчетДляРасшифровки);	
	ПараметрыОборотыСчетаДень.Вставить("Период",  "ДЕНЬ");
	ПараметрыОборотыСчетаДень.Вставить("ВсеПериоды",  Ложь);
	Если ВВалютеСценария <> Неопределено Тогда
		ПараметрыОборотыСчетаДень.Вставить("ВВалютеСценария", ВВалютеСценария);
	КонецЕсли;

	СписокРасшифровки = Новый СписокЗначений;
	ИмяГруппировки = Выборка.Группировка(); 
	
	Если Лев(ИмяГруппировки, СтрДлина(ИмяГруппировки) - 1) = "Субконто" Тогда

		Если ОтборСубконто <> Неопределено Тогда
			
			ОтборСубконто.Вставить(ИмяГруппировки, Выборка[ИмяГруппировки]);
			
			// Область должна содержать свою копию отбора по субконто
			ОтборРасшифровка = СоздатьКопиюСоответствияСтруктуры(ОтборСубконто);
			
			ПараметрыКарточкиСчета.Вставить("Отбор", ОтборРасшифровка);
			
		КонецЕсли;

		СписокРасшифровки.Добавить(ПараметрыКарточкиСчета, "Карточка счета " + Выборка.СчетПредставление);
		
	ИначеЕсли ИмяГруппировки = "Счет" Тогда

		СписокРасшифровки.Добавить(ПараметрыОСВПоСчету,    "ОСВ по счету " + Выборка.СчетПредставление);
		СписокРасшифровки.Добавить(ПараметрыКарточкиСчета, "Карточка счета " + Выборка.СчетПредставление);
		СписокРасшифровки.Добавить(ПараметрыАнализСчета,   "Анализ счета " + Выборка.СчетПредставление);
		
		Если НЕ (Месяц(ДатаНач) = Месяц(ДатаКон) И Год(ДатаНач) = Год(ДатаКон))
			ИЛИ (ДатаНач = '00010101' И ДатаКон = '00010101') Тогда
			
			СписокРасшифровки.Добавить(ПараметрыОборотыСчетаМесяц,  "Обороты счета " + Выборка.СчетПредставление + " по месяцам");
			
		КонецЕсли;
		
		СписокРасшифровки.Добавить(ПараметрыОборотыСчетаДень,  "Обороты счета " + Выборка.СчетПредставление + " по дням");
		
	Иначе
		
		СписокРасшифровки = Неопределено;
		
	КонецЕсли;

	Область.Параметры.Расшифровка = СписокРасшифровки;
	
КонецПроцедуры

// процедура дополняет основной отбор для отчета параметрами из дополнительного отбора
Процедура ДополнитьОтборОтчетаДополнительнымиПараметрами(ОсновнойОтбор, ДопРасшифровка)
	
	Если ДопРасшифровка = Неопределено
		ИЛИ ОсновнойОтбор = Неопределено Тогда
		Возврат;
	КонецЕсли;
	
	Если ТипЗнч(ДопРасшифровка) = Тип("ТаблицаЗначений") Тогда
		
		Для Каждого Элемент Из ДопРасшифровка Цикл
					
			СтрокаОсновногоОтбора = ОсновнойОтбор.Добавить(); 
			ЗаполнитьЗначенияСвойств(СтрокаОсновногоОтбора, Элемент);
					
		КонецЦикла;

		
	Иначе	
			
		Для Каждого Элемент Из ДопРасшифровка Цикл
					
			СтрокаОсновногоОтбора = ОсновнойОтбор.Добавить(); 
						
			СтрокаОсновногоОтбора.Значение = Элемент.Значение;
			СтрокаОсновногоОтбора.ПутьКДанным = Элемент.Ключ;
			СтрокаОсновногоОтбора.Использование = Истина;
			
			ВидСравненияДанных = ПолучитьВидОтбораПоТипуЗначения(СтрокаОсновногоОтбора.Значение);
			СтрокаОсновногоОтбора.ВидСравнения = ВидСравненияДанных;
			СтрокаОсновногоОтбора.ЗначениеС = Null;
			СтрокаОсновногоОтбора.ЗначениеПО = Null;
					
		КонецЦикла;
	
	КонецЕсли;
	
КонецПроцедуры

//Процедура копирует параметры расшифровки из одной структуры в другию
Процедура СкопироватьОбщиеПараметрыРасшифровки(Знач ОбщаяРасшифровка, Знач ВыбраннаяРасшифровка) Экспорт
	
	Если ТипЗнч(ОбщаяРасшифровка) = Тип("Структура") 
		ИЛИ ТипЗнч(ОбщаяРасшифровка) = Тип("Соответствие") Тогда

		Для Каждого Элемент Из ОбщаяРасшифровка Цикл
				
			Если ТипЗнч(Элемент.Значение) = Тип("ТаблицаЗначений") Тогда
				ВыбраннаяРасшифровка.Вставить(Элемент.Ключ, Элемент.Значение.Скопировать());
			Иначе
				ВыбраннаяРасшифровка.Вставить(Элемент.Ключ, Элемент.Значение);
			КонецЕсли;
				
		КонецЦикла;

	КонецЕсли;	
	
КонецПроцедуры

//Процедура дополнить дополнительными отборами пареметры расшифровки отчета
Процедура ДополнитьДопОтборамиРасшифровкуДанных(ВыбраннаяРасшифровка) Экспорт
	
	Если ТипЗнч(ВыбраннаяРасшифровка) = Тип("Структура") Тогда
			
		ОтборыДанных = Неопределено;
		ВыбраннаяРасшифровка.Свойство("Отбор", ОтборыДанных);
			
		ДопОтборыДанных = Неопределено;
		ВыбраннаяРасшифровка.Свойство("ДополнительныеОтборы", ДопОтборыДанных);
			
	Иначе
			
		ОтборыДанных = ВыбраннаяРасшифровка["Отбор"];
		ДопОтборыДанных = ВыбраннаяРасшифровка["ДополнительныеОтборы"];
				
	КонецЕсли;
		
	// дополнительная расшифровка
	ДополнитьОтборОтчетаДополнительнымиПараметрами(ОтборыДанных, ДопОтборыДанных);	
	
КонецПроцедуры


// процедура выводит расшифровку оборотно сальдовой ведомости
Процедура ДокументРезультатОбработкаРасшифровкиОборотноСальдовойВедомости(Элемент, Расшифровка, 
		СтандартнаяОбработка, Знач ПоказыватьЗаголовок) Экспорт
	
	Если ТипЗнч(Расшифровка) = Тип("СписокЗначений") Тогда
		
		Если Расшифровка.Количество() = 1 Тогда
			ВыбранноеЗначение = Расшифровка[0];
		Иначе
			ВыбранноеЗначение = Расшифровка.ВыбратьЭлемент("Выберите расшифровку", Расшифровка[0]);
		КонецЕсли;
		
		Если ВыбранноеЗначение <> Неопределено Тогда
			ВыбраннаяРасшифровка = ВыбранноеЗначение.Значение;
		Иначе
			СтандартнаяОбработка = Ложь;
			Возврат;
		КонецЕсли;
		
	ИначеЕсли ТипЗнч(Расшифровка) = Тип("Структура")
		ИЛИ ТипЗнч(Расшифровка) = Тип("Соответствие") Тогда
		
		ВыбраннаяРасшифровка = Расшифровка;
	КонецЕсли;

	Если ТипЗнч(ВыбраннаяРасшифровка) = Тип("Структура") 
		ИЛИ ТипЗнч(ВыбраннаяРасшифровка) = Тип("Соответствие") Тогда

		// Добавим общую расшифровку из левого верхнего угла
		ОбщаяРасшифровка = Элемент.Область(1, 1).Расшифровка;
		
		СкопироватьОбщиеПараметрыРасшифровки(ОбщаяРасшифровка, ВыбраннаяРасшифровка);
		
		ДополнитьДопОтборамиРасшифровкуДанных(ВыбраннаяРасшифровка);
				
		СтандартнаяОбработка = Ложь;
		
		Отчет = Отчеты[ВыбраннаяРасшифровка["ИмяОбъекта"]].Создать();
		
		Отчет.Настроить(ВыбраннаяРасшифровка);
		

		ФормаОтчета = Отчет.ПолучитьФорму(, , Новый УникальныйИдентификатор());
		
		ФормаОтчета.ПоказыватьЗаголовок = ПоказыватьЗаголовок;
		
		ФормаОтчета.ОбновитьОтчет();
	
		ФормаОтчета.Открыть();
		
	КонецЕсли;

КонецПроцедуры

///////////////////////////////////////////////////////////////////////////////
//КАРТОЧКА СЧЕТА
///////////////////////////////////////////////////////////////////////////////

// процедура устанавливает отборы посторителя по субконто счета
Процедура УстановитьЗапросИОтборПостроителяПоСубконтоДляДвижений(Знач Счет, Знач ИмяРегистраБухгалтерии, Знач ПостроительОтчета,
	Знач ДополнительныеОтборы = "") Экспорт
	
	Пока ПостроительОтчета.Отбор.Количество() > 0 Цикл
		ПостроительОтчета.Отбор.Удалить(0);
	КонецЦикла;
		
	ТекстСубконто = "";
	// Если есть субконто, настроим отбор по субконто
	СтруктураСубконто = Новый Структура;
		
	Для Каждого ВидСубконто Из Счет.ВидыСубконто Цикл

		СтруктураСубконто.Вставить("Субконто" + ВидСубконто.НомерСтроки, ВидСубконто.ВидСубконто);
				
		ТекстСубконто = ТекстСубконто + ", Субконто" + ВидСубконто.НомерСтроки+".*";

	КонецЦикла;
	
	Если Не ПустаяСтрока(ДополнительныеОтборы) Тогда
		
		ТекстСубконто = ТекстСубконто + ", " + ДополнительныеОтборы;
		
	КонецЕсли;
	
	Если Не ПустаяСтрока(ТекстСубконто) Тогда
		СтрокаОграниченийДляПостроителя = "{" + Сред(ТекстСубконто, 3) + "}";
	Иначе
		СтрокаОграниченийДляПостроителя = Сред(ТекстСубконто, 3);
    КонецЕсли;
			
	ПостроительОтчета.Текст = "
		|ВЫБРАТЬ РАЗРЕШЕННЫЕ 1 
		|ИЗ РегистрБухгалтерии." + ИмяРегистраБухгалтерии + ".ДвиженияССубконто(,," + СтрокаОграниченийДляПостроителя + ")";
		
	Для Каждого Элемент Из СтруктураСубконто Цикл
			
		Поле = ПостроительОтчета.ДоступныеПоля.Найти(Элемент.Ключ);
		
		Если Поле <> Неопределено Тогда
		
			Поле.ТипЗначения = Элемент.Значение.ТипЗначения;
			Поле.Представление = Элемент.Значение.Наименование;
				
			Если ПостроительОтчета.Отбор.Найти(Элемент.Ключ) = Неопределено Тогда
				ПостроительОтчета.Отбор.Добавить(Элемент.Ключ);
			КонецЕсли;
		
		КонецЕсли;
			
	КонецЦикла;
	
КонецПроцедуры

// Функция возвращает представление периода строкой
//
// Параметры:
//  ДатаПериода - Дата в интревале опредеяемого периода
//
// Возвращаемое значение:
//  Строковое представление интервала
//
Функция ПолучитьПериодДатСтрокой(Знач Период, Знач ДатаПериода) Экспорт

	ПериодСтр = Период;
	Если ПериодСтр = "ДЕНЬ" тогда
		ДатаНачала    = НачалоДня(ДатаПериода);
		ДатаОкончания = КонецДня(ДатаПериода);
	ИначеЕсли ПериодСтр = "НЕДЕЛЯ" тогда
		ДатаНачала    = НачалоНедели(ДатаПериода);
		ДатаОкончания = КонецНедели (ДатаПериода);
	ИначеЕсли ПериодСтр = "МЕСЯЦ" тогда
		ДатаНачала    = НачалоМесяца(ДатаПериода);
		ДатаОкончания = КонецМесяца (ДатаПериода);
	ИначеЕсли ПериодСтр = "КВАРТАЛ" тогда
		ДатаНачала    = НачалоКвартала(ДатаПериода);
		ДатаОкончания = КонецКвартала (ДатаПериода);
	ИначеЕсли ПериодСтр = "ГОД" тогда
		ДатаНачала    = НачалоГода(ДатаПериода);
		ДатаОкончания = КонецГода (ДатаПериода);
	КонецЕсли;

	Возврат ПредставлениеПериода(ДатаНачала, ДатаОкончания, "ФП=Истина")

КонецФункции

//Функция получает конечную дату по дате и периоду
Функция ПолучитьДатуОкончанияПериода(Знач ДатаОграничений, Знач Период) Экспорт
	
	Если ДатаОграничений = Null
		ИЛИ ДатаОграничений = Неопределено Тогда
		
		Возврат КонецДня(Дата('00010101'));
		
	КонецЕсли;
	
	ПериодПо = ДатаОграничений;
	
	Если Период = "ДЕНЬ" Тогда
		ПериодПо = ДатаОграничений + 24 * 60 * 60 - 1;
	ИначеЕсли Период = "НЕДЕЛЯ" Тогда
		ПериодПо = ДатаОграничений + 7 * 24 * 60 * 60 - 1;
	ИначеЕсли Период = "ДЕКАДА" Тогда
		ПериодПо = ДатаОграничений + 10 * 24 * 60 * 60 - 1;
	ИначеЕсли Период = "МЕСЯЦ" Тогда
		ПериодПо = КонецДня(КонецМесяца(ДатаОграничений));
	ИначеЕсли Период = "КВАРТАЛ" Тогда
		ПериодПо = КонецДня(КонецКвартала(ДатаОграничений));
	ИначеЕсли Период = "ПОЛУГОДИЕ" Тогда
		СерединаГода = КонецМесяца(ДобавитьМесяц(НачалоГода(ДатаОграничений), 6));
		Если ДатаОграничений<= СерединаГода Тогда
			ПериодПо = СерединаГода;
		Иначе
			ПериодПо = КонецДня(КонецГода(ДатаОграничений));
		КонецЕсли;
				
	ИначеЕсли Период = "ГОД" Тогда
		ПериодПо = КонецДня(КонецГода(ДатаОграничений));
	КонецЕсли;
	
	Возврат ПериодПо;
	
КонецФункции

//Процедура устанавливает параметры ограничения запросу из строки ограничений построителя отчета
Процедура УстановитьПараметрыЗапросаПоСтрокеПостроителяОтчета(Запрос, Знач СтрокаОтбора, Знач ПостфиксОграничения) Экспорт
	
	СтрокаПостфикса = Строка(ПостфиксОграничения);
	
	Если СтрокаОтбора.ВидСравнения = ВидСравнения.Содержит
		ИЛИ СтрокаОтбора.ВидСравнения = ВидСравнения.НеСодержит Тогда
		
		// ограничение на содержит отрабатывается отдельным образом
		// надо из значения ограничения лишние символы преобразовать и дополнить ограничение символами %%
		
		ИтоговаяСтрокаОграничения = ОбщегоНазначения.СформироватьСтрокуДляПоискаВЗапросе(СтрокаОтбора.Значение);
		
		ИтоговаяСтрокаОграничения = "%" + ИтоговаяСтрокаОграничения + "%";
		
		Запрос.УстановитьПараметр("Значение" + СтрокаПостфикса, ИтоговаяСтрокаОграничения);
		
	Иначе	
		
		Запрос.УстановитьПараметр("Значение" + СтрокаПостфикса, СтрокаОтбора.Значение);
		Запрос.УстановитьПараметр("ЗначениеС" + СтрокаПостфикса, СтрокаОтбора.ЗначениеС);
		Запрос.УстановитьПараметр("ЗначениеПо" + СтрокаПостфикса, СтрокаОтбора.ЗначениеПо);	
	
	КонецЕсли;
	
КонецПроцедуры

//Функция формирует строку ограничений для запроса по ограничениям построителя отчетов
Функция ПолучитьТекстОграниченийПоПостроителюОтчета(ПостроительОтчета, Запрос) Экспорт
	
	ТекстФильтры = "";
	
	Индекс = 0;
	Для Каждого СтрокаОтбора Из ПостроительОтчета.Отбор Цикл
		
		Индекс = Индекс + 1;
		Если Не СтрокаОтбора.Использование 
			ИЛИ ПустаяСтрока(СтрокаОтбора.ПутьКДанным) Тогда
			
			Продолжить;
			
		КонецЕсли;
		
		УстановитьПараметрыЗапросаПоСтрокеПостроителяОтчета(Запрос, СтрокаОтбора, Строка(Индекс));
						
		ТекстСтрокиПоля = "";
		Если СтрокаОтбора.ВидСравнения = ВидСравнения.ВИерархии
			И СтрокаОтбора.Значение <> Неопределено Тогда
			
			МетаданныеОграничения = СтрокаОтбора.Значение.Метаданные();	
			
			ТипВыражения = "";
			
			Если Метаданные.Справочники.Содержит(МетаданныеОграничения) Тогда
				
				ТипВыражения = "Справочник."; 
				
			ИначеЕсли Метаданные.Документы.Содержит(МетаданныеОграничения) Тогда
				
				ТипВыражения = "Документ."; 
				
			ИначеЕсли Метаданные.ПланыВидовХарактеристик.Содержит(МетаданныеОграничения) Тогда
				
				ТипВыражения = "ПланВидовХарактеристик.";	
				
			ИначеЕсли Метаданные.Перечисления.Содержит(МетаданныеОграничения) Тогда
				
				ТипВыражения = "Перечисление.";	
				
			КонецЕсли;
			
			Если ТипВыражения <> "" Тогда
				
				ТекстСтрокиПоля = "Выразить(" + СтрокаОтбора.ПутьКДанным + " КАК " + ТипВыражения + МетаданныеОграничения.Имя + ")"
				
			КонецЕсли;
			
		КонецЕсли;
		
		Если ТекстСтрокиПоля = "" Тогда
			
			ТекстСтрокиПоля = СтрокаОтбора.ПутьКДанным;
			
		КонецЕсли;
			
		ТекстФильтры = ТекстФильтры + " И " + УправлениеОтчетами.ПолучитьСтрокуОтбора(СтрокаОтбора.ВидСравнения, "&Значение" + Индекс, 
			ТекстСтрокиПоля, "&ЗначениеС" + Индекс, "&ЗначениеПо" + Индекс, СтрокаОтбора.Значение, 
			СтрокаОтбора.ЗначениеС, СтрокаОтбора.ЗначениеПо);
				
	КонецЦикла;
	
	Возврат Сред(ТекстФильтры, 3);
	
КонецФункции

// процедура выводит данные остатков по оборотам в макет
Процедура ВывестиДанныеОстатковКарточкиСчетаВМакет(ЗапросПоОстаткам, Знач ОбластьМакет, Знач Счет, Знач ЗапросНаНачало, 
	ТекущееСальдо = 0, ТекущееСальдоКолво = 0) Экспорт
	
	Остатки = ЗапросПоОстаткам.Выполнить().Выбрать();
	Остатки.Следующий();
	
	Если ЗапросНаНачало Тогда
		
		ОбластьМакет.Параметры.ОписательСальдо = "Сальдо на начало";
		ВыводитьИтогПоКоличеству = Счет.Количественный;
		
	Иначе
		
		ОбластьМакет.Параметры.ОписательСальдо = "Сальдо на конец";
		ВыводитьИтогПоКоличеству = Счет.Количественный;
		
	КонецЕсли;
	
	СуммаОстатокДт = ПривестиКЧислу(Остатки.СуммаОстатокДт);
	СуммаОстатокКт = ПривестиКЧислу(Остатки.СуммаОстатокКт);
	КоличествоОстатокДт = ПривестиКЧислу(Остатки.КоличествоОстатокДт);
	КоличествоОстатокКт = ПривестиКЧислу(Остатки.КоличествоОстатокКт);
	
	ТекущееСальдо = СуммаОстатокДт - СуммаОстатокКт;
	ТекущееСальдоКолво = КоличествоОстатокДт - КоличествоОстатокКт;

	Если Счет.Вид = ВидСчета.АктивноПассивный Тогда
		
		Если СуммаОстатокДт > СуммаОстатокКт Тогда
			ОбластьМакет.Параметры.СуммаСальдоДт   = ТекущееСальдо;
			ОбластьМакет.Параметры.СуммаСальдоКт   = 0;
			
			Если ВыводитьИтогПоКоличеству Тогда
				
				ОбластьМакет.Параметры.КоличествоСальдоДт   = ТекущееСальдоКолво;
				ОбластьМакет.Параметры.КоличествоСальдоКт   = 0;
				
			КонецЕсли;
			
		Иначе
			ОбластьМакет.Параметры.СуммаСальдоКт   = 0;
			ОбластьМакет.Параметры.СуммаСальдоКт   = -ТекущееСальдо;
			
			Если ВыводитьИтогПоКоличеству Тогда
				
				ОбластьМакет.Параметры.КоличествоСальдоДт   = 0;
				ОбластьМакет.Параметры.КоличествоСальдоКт   = -ТекущееСальдоКолво;
				
			КонецЕсли;
			
		КонецЕсли;
		
	Иначе
		
		ОбластьМакет.Параметры.СуммаСальдоДт   = СуммаОстатокДт;
		ОбластьМакет.Параметры.СуммаСальдоКт   = СуммаОстатокКт;
		
		Если ВыводитьИтогПоКоличеству Тогда
			
			ОбластьМакет.Параметры.КоличествоСальдоДт   = КоличествоОстатокДт;
			ОбластьМакет.Параметры.КоличествоСальдоКт   = КоличествоОстатокКт;
			
		КонецЕсли;
		
	КонецЕсли;
	
КонецПроцедуры

// Проверка соответствия половины проводки установленным отборам пользователя
//
// Параметры
//  Выборка  – ВыборкаИзРезультатаЗапроса – Выборка из результата запроса
//  Сторона  – Строка                     – Дт/Кт
//
// Возвращаемое значение:
//   Булево   – Соответствует или нет сторона проводки установленным отборам
//
Функция ЗначениеПоляСоответствуетОтбору(Выборка, Знач СторонаПроводки, ПостроительОтчета) Экспорт

	Результат = Истина;
	
	Для Каждого ЭлементОтбора Из ПостроительОтчета.Отбор Цикл
	
		Если НЕ ЭлементОтбора.Использование Тогда
			Продолжить;
		КонецЕсли;
		
		ИмяПоля = СтрЗаменить(ЭлементОтбора.ПутьКДанным, "Субконто", "Субконто"+СторонаПроводки);
		Если ВРЕГ(Лев(ЭлементОтбора.ПутьКДанным, 8)) = "СУБКОНТО" Тогда
			ИмяПоля = "Субконто" + СторонаПроводки + Сред(ЭлементОтбора.ПутьКДанным,9);
		КонецЕсли;
		Если ВРЕГ(Лев(ЭлементОтбора.ПутьКДанным, 6)) = "ВАЛЮТА" Тогда
			ИмяПоля = "Валюта" + СторонаПроводки + Сред(ЭлементОтбора.ПутьКДанным,7);
		КонецЕсли;
		
		ИндексТочки = Найти(ИмяПоля, ".");
		Если ИндексТочки <> 0 Тогда
			
			_ВремЗначение = Выборка[Лев(ИмяПоля,ИндексТочки-1)];
			
			Если Перечисления.ТипВсеСсылки().СодержитТип(ТипЗнч(_ВремЗначение)) Тогда
				
				ЗначениеПоля = _ВремЗначение;	
				
			Иначе
			
				ЗначениеПоля = Неопределено;
				Выполнить("ЗначениеПоля = _ВремЗначение" + Сред(ИмяПоля,ИндексТочки));
				Если ТипЗнч(ЗначениеПоля) = Тип("Строка") Тогда
					ЗначениеПоля = СокрЛП(ЗначениеПоля);
				КонецЕсли;

			
			КонецЕсли;
			
		Иначе
			ЗначениеПоля = Выборка[ИмяПоля];
		КонецЕсли;
		
		Если ЭлементОтбора.ВидСравнения = ВидСравнения.Больше Тогда
		
			Результат = ЗначениеПоля > ЭлементОтбора.Значение;
		
		ИначеЕсли ЭлементОтбора.ВидСравнения = ВидСравнения.БольшеИлиРавно Тогда
		
			Результат = ЗначениеПоля >= ЭлементОтбора.Значение;
		
		ИначеЕсли ЭлементОтбора.ВидСравнения = ВидСравнения.ВИерархии Тогда
		
			Результат = ВИерархии(ЗначениеПоля, ЭлементОтбора.Значение);
		
		ИначеЕсли ЭлементОтбора.ВидСравнения = ВидСравнения.ВСписке Тогда
		
			Результат = ЭлементОтбора.Значение.НайтиПоЗначению(ЗначениеПоля) <> Неопределено;
		
		ИначеЕсли ЭлементОтбора.ВидСравнения = ВидСравнения.ВСпискеПоИерархии Тогда
		
			ПромРезультат = Ложь;
			
			Для Каждого Элемент Из ЭлементОтбора.Значение Цикл
				
				Если ВИерархии(ЗначениеПоля, Элемент.Значение) Тогда
					ПромРезультат = Истина;
					Прервать;
				КонецЕсли;
			
			КонецЦикла;
			
			Результат = ПромРезультат;
			
		ИначеЕсли ЭлементОтбора.ВидСравнения = ВидСравнения.Интервал Тогда
		
			Результат = (ЗначениеПоля > ЭлементОтбора.ЗначениеС) и (ЗначениеПоля < ЭлементОтбора.ЗначениеПо);
		
		ИначеЕсли ЭлементОтбора.ВидСравнения = ВидСравнения.ИнтервалВключаяГраницы Тогда
		
			Результат = (ЗначениеПоля >= ЭлементОтбора.ЗначениеС) и (ЗначениеПоля <= ЭлементОтбора.ЗначениеПо);
		
		ИначеЕсли ЭлементОтбора.ВидСравнения = ВидСравнения.ИнтервалВключаяНачало Тогда
		
			Результат = (ЗначениеПоля >= ЭлементОтбора.ЗначениеС) и (ЗначениеПоля < ЭлементОтбора.ЗначениеПо);
		
		ИначеЕсли ЭлементОтбора.ВидСравнения = ВидСравнения.ИнтервалВключаяОкончание Тогда
		
			Результат = (ЗначениеПоля > ЭлементОтбора.ЗначениеС) и (ЗначениеПоля <= ЭлементОтбора.ЗначениеПо);
		
		ИначеЕсли ЭлементОтбора.ВидСравнения = ВидСравнения.Меньше Тогда
		
			Результат = ЗначениеПоля < ЭлементОтбора.Значение;
		
		ИначеЕсли ЭлементОтбора.ВидСравнения = ВидСравнения.МеньшеИлиРавно Тогда
		
			Результат = ЗначениеПоля <= ЭлементОтбора.Значение;
		
		ИначеЕсли ЭлементОтбора.ВидСравнения = ВидСравнения.НеВИерархии Тогда
		
			Результат = Не ВИерархии(ЗначениеПоля, ЭлементОтбора.Значение);
		
		ИначеЕсли ЭлементОтбора.ВидСравнения = ВидСравнения.НеВСписке Тогда
		
			Результат = ЭлементОтбора.Значение.НайтиПоЗначению(ЗначениеПоля) = Неопределено;
		
		ИначеЕсли ЭлементОтбора.ВидСравнения = ВидСравнения.НеВСпискеПоИерархии Тогда
		
			ПромРезультат = Ложь;
			
			Для Каждого Элемент Из ЭлементОтбора.Значение Цикл
			
				Если ВИерархии(ЗначениеПоля, Элемент.Значение) Тогда
					ПромРезультат = Истина;
					Прервать;
				КонецЕсли;
			
			КонецЦикла;
			
			Результат = Не ПромРезультат;
		
		ИначеЕсли ЭлементОтбора.ВидСравнения = ВидСравнения.НеРавно Тогда
		
			Результат = ЗначениеПоля <> ЭлементОтбора.Значение;
		
		ИначеЕсли ЭлементОтбора.ВидСравнения = ВидСравнения.НеСодержит Тогда
			
			ШаблонСтроки = ЭлементОтбора.Значение;
			ШаблонСтроки = СтрЗаменить(ШаблонСтроки, "\%", "[|||]");
			ШаблонСтроки = СтрЗаменить(ШаблонСтроки, "%", "");
			ШаблонСтроки = СтрЗаменить(ШаблонСтроки, "[|||]", "%");
			Результат = Найти(Строка(ЗначениеПоля), ШаблонСтроки) = 0;
		
		ИначеЕсли ЭлементОтбора.ВидСравнения = ВидСравнения.Равно Тогда
		
			Если ТипЗнч(ЭлементОтбора.Значение) = Тип("Строка") Тогда
				Результат = (ЗначениеПоля = СокрЛП(ЭлементОтбора.Значение));
			Иначе
				Результат = (ЗначениеПоля = ЭлементОтбора.Значение);
			КонецЕсли;
		
		ИначеЕсли ЭлементОтбора.ВидСравнения = ВидСравнения.Содержит Тогда
		
			ШаблонСтроки = ЭлементОтбора.Значение;
			ШаблонСтроки = СтрЗаменить(ШаблонСтроки, "\%", "[|||]");
			ШаблонСтроки = СтрЗаменить(ШаблонСтроки, "%", "");
			ШаблонСтроки = СтрЗаменить(ШаблонСтроки, "[|||]", "%");
			Результат = Найти(Строка(ЗначениеПоля), ШаблонСтроки) <> 0;
		
		КонецЕсли;
		
		Если НЕ Результат Тогда
			Прервать;
		КонецЕсли;
		
	КонецЦикла;

	Возврат Результат;
	
КонецФункции // СоответствуетОтбору()

Функция ВИерархии(ЛевоеЗначение, ПравоеЗначение)
	
	Если ТипЗнч(ЛевоеЗначение) <> ТипЗнч(ПравоеЗначение) Тогда
		Возврат Ложь;    	
	ИначеЕсли ЛевоеЗначение = ПравоеЗначение Тогда
		Возврат Истина;
	ИначеЕсли ЛевоеЗначение.Пустая() ИЛИ ПравоеЗначение.Пустая() Тогда
		Возврат Ложь;
	ИначеЕсли ЛевоеЗначение.ПринадлежитЭлементу(ПравоеЗначение) Тогда
		Возврат Истина;
	Иначе
		Возврат Ложь;
	КонецЕсли;

КонецФункции

///////////////////////////////////////////////////////////////////////////////
//ОБОРОТЫ СЧЕТА
///////////////////////////////////////////////////////////////////////////////

// процедура обрабатывает выбор для строки отборов
Процедура ОбработатьВыборДляСтрокиОтбораБухОтчетов(СтрокаОтбора, Элемент, СтандартнаяОбработка, ОбъектОтчет) Экспорт
	
	Если СтрокаОтбора = Неопределено Тогда
		Возврат;
	КонецЕсли;
	
	Попытка
		
		Если СтрокаОтбора.ТипЗначения.Типы().Количество() = 1
		 И СтрокаОтбора.ТипЗначения.СодержитТип(Тип("СправочникСсылка.Субконто")) Тогда
			
			Если ОбъектОтчет.ИмяРегистраБухгалтерии = "Хозрасчетный" 
			 ИЛИ ОбъектОтчет.ИмяРегистраБухгалтерии = "Налоговый" Тогда
				НайденноеЗначение = ПланыВидовХарактеристик.ВидыСубконтоХозрасчетные.НайтиПоНаименованию(СтрокаОтбора.Представление, Истина);
			ИначеЕсли ОбъектОтчет.ИмяРегистраБухгалтерии = "Международный"
			 И Метаданные.ПланыВидовХарактеристик.Найти("ВидыСубконтоМеждународные") <> Неопределено Тогда
				НайденноеЗначение = ПланыВидовХарактеристик.ВидыСубконтоМеждународные.НайтиПоНаименованию(СтрокаОтбора.Представление, Истина);
			КонецЕсли;
			
			Если НайденноеЗначение <> Неопределено Тогда
				СтандартнаяОбработка = Ложь;
				ФормаВыбора = Справочники.Субконто.ПолучитьФормуВыбора(,Элемент,);
				ФормаВыбора.ПараметрОтборПоВладельцу = НайденноеЗначение;
				ФормаВыбора.ЭлементыФормы.СправочникСписок.НастройкаОтбора.Владелец.Доступность = Ложь;
				ФормаВыбора.Открыть();
				Возврат;
			КонецЕсли;
			
		КонецЕсли;
		
	Исключение
	КонецПопытки;
	
	// Принятая в конфигурации обработка работает только для равенства/неравенства
	Если СтрокаОтбора.ВидСравнения = ВидСравнения.Равно
	 ИЛИ СтрокаОтбора.ВидСравнения = ВидСравнения.НеРавно Тогда
		
		ТипЗначенияПоля = СтрокаОтбора.ТипЗначения;
		ОбъектОтчет.НачалоВыбораЗначенияСубконто(Элемент, СтандартнаяОбработка, ТипЗначенияПоля);
		
	КонецЕсли;	
	
КонецПроцедуры

// функция приводит значение из выборки к числу
Функция ПривестиКЧислу(Значение) Экспорт
	
	Если Значение = NULL Тогда
		Возврат 0;
	Иначе
		Возврат Значение;
	КонецЕсли;
	
КонецФункции

//функция удаляет при необходимости область из макета
Функция УдалитьОбластьИзмакетаПриНеобходимости(Макет, Знач ИмяОбласти, Знач НужноУдалятьОбласть) Экспорт
	
	Если НЕ НужноУдалятьОбласть Тогда
		Макет.УдалитьОбласть(Макет.Область(ИмяОбласти), ТипСмещенияТабличногоДокумента.ПоГоризонтали);
	КонецЕсли;
	
КонецФункции

//Функция возвращает строку формата периода
Функция ПолучитьСтрокуФорматаПериода(Знач Период) Экспорт
	
	ФорматПериода = "";
	Если ЗначениеЗаполнено(Период) Тогда
		Если Врег(Период) = "ГОД" Тогда
			ФорматПериода = "ДФ = ""гггг """"г.""""""";
		ИначеЕсли Врег(Период) = "ПОЛУГОДИЕ" Тогда
			ФорматПериода = "ДФ = """"""Полугодие с"""" дд.ММ.гггг """"""";
		ИначеЕсли Врег(Период) = "КВАРТАЛ" Тогда
			ФорматПериода = "ДФ = ""к"""" квартал"""" гггг """"г.""""""";
		ИначеЕсли Врег(Период) = "МЕСЯЦ" Тогда
			ФорматПериода = "ДФ = ""ММММ гггг """"г.""""""";
		ИначеЕсли Врег(Период) = "ДЕКАДА" Тогда
			ФорматПериода = "ДФ = """"""Декада с"""" дд.ММ.гггг """"""";
		ИначеЕсли Врег(Период) = "НЕДЕЛЯ" Тогда
			ФорматПериода = "ДФ = """"""Неделя с"""" дд.ММ.гггг """"""";
		ИначеЕсли Врег(Период) = "ДЕНЬ" Тогда
			ФорматПериода = "ДЛФ = D";
		ИначеЕсли Врег(Период) = "РЕГИСТРАТОР" Тогда
			ФорматПериода = "";
		КонецЕсли;
	КонецЕсли;
	
	Возврат ФорматПериода;
	
КонецФункции

Процедура ВывестиЗаголовкиОборотовОтчетаОборотыСчета(Макет, Знач ИмяОбластиВывода, Знач Выборка, 
	Знач ДокументРезультат, Знач ПоСубсчетам, Знач ВидДвижения, МассивРесурсов, СписокСчетов, Знач ДополнениеКУровнюВывода = 0)
	
	ВерхнийУровень = 1000;
	Обл = Макет.ПолучитьОбласть(ИмяОбластиВывода);
	Пока Выборка.Следующий() Цикл
			
		Если НЕ ПоСубсчетам Тогда
				
			// Выводим только верхний уровень
			Если ВерхнийУровень < Выборка.Уровень() Тогда
				Продолжить;
			Иначе
				ВерхнийУровень = Выборка.Уровень();
			КонецЕсли;
				
		КонецЕсли;
			
		ЕстьОборот = Ложь;
		ОкончанниеПоля = ?(ВидДвижения = ВидДвиженияБухгалтерии.Дебет, "Дт", "Кт");
		Для каждого Ресурс Из МассивРесурсов Цикл
			Если Выборка["Есть" + Ресурс + "Оборот" + ОкончанниеПоля] <> 0 Тогда
				ЕстьОборот = Истина;
				Прервать;
			КонецЕсли;
		КонецЦикла;
		Если ЕстьОборот Тогда
			СписокСчетов.Добавить(Выборка.КорСчет);
							
			Обл.Параметры.Заполнить(Выборка);
			ДокументРезультат.Присоединить(Обл, Выборка.Уровень() + ДополнениеКУровнюВывода);
				
		КонецЕсли;
			
	КонецЦикла;
	
КонецПроцедуры

//Процедура возвращает суммы на начало периода
Процедура ПолучитьДанныеДляОборотов(ДанныеДляВыбораСумм, ПостфиксИменПолей, 
	Знач ПолучатьКоличество, Знач ПолучатьВалюту, СуммаДт, СуммаКт, КоличествоДт = Неопределено, 
	КоличествоКт = Неопределено, ВалютнаяСуммаДт = Неопределено, ВалютнаяСуммаКт = Неопределено) Экспорт
	


	СуммаДт = ПривестиКЧислу(ДанныеДляВыбораСумм["Сумма" + ПостфиксИменПолей + "Дт"]);
	СуммаКт = ПривестиКЧислу(ДанныеДляВыбораСумм["Сумма" + ПостфиксИменПолей + "Кт"]);
	
	Если ПолучатьКоличество Тогда
		
		КоличествоДт = ПривестиКЧислу(ДанныеДляВыбораСумм["Количество" + ПостфиксИменПолей + "Дт"]);
		КоличествоКт = ПривестиКЧислу(ДанныеДляВыбораСумм["Количество" + ПостфиксИменПолей + "Кт"]);
			
	КонецЕсли;
		
	Если ПолучатьВалюту Тогда
		
		ВалютнаяСуммаДт = ПривестиКЧислу(ДанныеДляВыбораСумм["ВалютнаяСумма" + ПостфиксИменПолей + "Дт"]);
		ВалютнаяСуммаКт = ПривестиКЧислу(ДанныеДляВыбораСумм["ВалютнаяСумма" + ПостфиксИменПолей + "Кт"]);
							
	КонецЕсли;
	
КонецПроцедуры

//Функция определяет по построителю отчета и имени субконто вести про нему количественный учет или нет
Функция ОпределитьПоСубконтоИПостроителюВестиКоличественныйУчет(Счет, ПостроительОтчета, Знач Измерение) Экспорт
	
	Если Врег(Измерение) = "СЧЕТ" Тогда
		
		Возврат Ложь;
		
	КонецЕсли;
	
	ИзмерениеПостроителя = ПостроительОтчета.ИзмеренияСтроки.Найти(Измерение);
	Если ИзмерениеПостроителя <> Неопределено Тогда
				
		ИмяПоля = ИзмерениеПостроителя.ПутьКДанным;
				
		поз = Найти(ИмяПоля, ".");
		ИмяПоля = ?(поз=0, ИмяПоля, Лев(ИмяПоля, поз-1));
			
	Иначе
		ИмяПоля = Измерение; 
	КонецЕсли;
	
	Попытка
		
		ИндСубконто = Число(Сред(ИмяПоля, СтрДлина("Субконто") + 1));
		
	Исключение
		
		Возврат Ложь;
		
	КонецПопытки;
	
	ВыводКоличества = Счет.ВидыСубконто[ИндСубконто - 1].Количественный;
	
	Возврат ВыводКоличества;
	
КонецФункции

// процедура выполняет заполнение отчета обороты счета параметрами
Процедура ЗаполнитьСуммыОборотаСчета(Знач ДокументРезультат, Знач ВыводитьКоличество, Знач Уровень, Знач ОбластьВывода, Знач ИмяПараметраСуммы, Знач ИмяПараметраКоличества,
	Знач Сумма, Знач Количество) Экспорт
	
	ОбластьВывода.Параметры[ИмяПараметраСуммы] = Сумма;
	Если ВыводитьКоличество Тогда
		ОбластьВывода.Параметры[ИмяПараметраКоличества] = Количество;
	КонецЕсли;
				
	ДокументРезультат.Присоединить(ОбластьВывода, Уровень);
	
КонецПроцедуры

// процедура выводит заголовок для отчета обороты счета
Процедура ВывестиПолныйЗаголовокОтчетаОборотовСчета(Выборка = Неопределено, ШиринаТаблицы, ОбъектОтчет, Макет, ДокументРезультат,
	РезультатЗапроса, Знач ИмяСтроки, МассивРесурсов, СписокДт, СписокКт, Знач ДополнениеКУровнюВывода = 0, Знач ВыборкаИтогов = Неопределено, 
	Знач ОбщийИтог = Неопределено) Экспорт
	
	// Вывод заголовков нач.сальдо
	Если ОбъектОтчет.СальдоНачДт Тогда
		ОблСальдоНачДт = Макет.ПолучитьОбласть(ИмяСтроки+"|СальдоНачДт");
		Если ВыборкаИтогов <> Неопределено Тогда
			ОблСальдоНачДт.Параметры.Заполнить(ВыборкаИтогов);
		КонецЕсли;
		ДокументРезультат.Присоединить(ОблСальдоНачДт, 0);
		ШиринаТаблицы = ШиринаТаблицы + ОблСальдоНачДт.ШиринаТаблицы;
	КонецЕсли;
	
	Если ОбъектОтчет.СальдоНачКт Тогда
		ОблСальдоНачКт = Макет.ПолучитьОбласть(ИмяСтроки+"|СальдоНачКт");
		Если ВыборкаИтогов <> Неопределено Тогда
			ОблСальдоНачКт.Параметры.Заполнить(ВыборкаИтогов);
		КонецЕсли;
		ДокументРезультат.Присоединить(ОблСальдоНачКт, 0);
		ШиринаТаблицы = ШиринаТаблицы + ОблСальдоНачКт.ШиринаТаблицы;
	КонецЕсли;
	
	// Вывод заголовков оборотов
	Если ОбъектОтчет.ОборотДт Тогда
		ОблОборотДт = Макет.ПолучитьОбласть(ИмяСтроки+"|ОборотДт");
		Если ОбщийИтог <> Неопределено Тогда
			ОблОборотДт.Параметры.Заполнить(ОбщийИтог);
		КонецЕсли;
		ДокументРезультат.Присоединить(ОблОборотДт, 0);
		ШиринаТаблицы = ШиринаТаблицы + ОблОборотДт.ШиринаТаблицы;
	КонецЕсли;
			
	// Вывод кор счетов с дебетовыми оборотами
	Если Выборка = Неопределено Тогда
		Выборка = РезультатЗапроса.Выбрать(ОбходРезультатаЗапроса.ПоГруппировкам, "КорСчет", "Все");
	Иначе
		Выборка.Сбросить();
	КонецЕсли;
	
	// вывод заголовков для корреспондирующих счетов
	СписокДт = Новый СписокЗначений;
	Если ОбъектОтчет.ОборотДтКорСчета Тогда
		
		ВывестиЗаголовкиОборотовОтчетаОборотыСчета(Макет, ИмяСтроки+"|ОборотДтКорсчет", Выборка,
			ДокументРезультат, ОбъектОтчет.ПоСубсчетамКорСчетов, ВидДвиженияБухгалтерии.Дебет, МассивРесурсов, СписокДт, ДополнениеКУровнюВывода);
						
	КонецЕсли;
	
	// вывод данных по кредитовому обороту
	Если ОбъектОтчет.ОборотКт Тогда
		ОблОборотКт = Макет.ПолучитьОбласть(ИмяСтроки+"|ОборотКт");
		Если ОбщийИтог <> Неопределено Тогда
			ОблОборотКт.Параметры.Заполнить(ОбщийИтог);
		КонецЕсли;
		ДокументРезультат.Присоединить(ОблОборотКт, 0);
		ШиринаТаблицы = ШиринаТаблицы + ОблОборотКт.ШиринаТаблицы;
	КонецЕсли;
	
	// Вывод кор счетов с кредитовыми оборотами
	СписокКт = Новый СписокЗначений;
	
	Выборка.Сбросить();
	Если ОбъектОтчет.ОборотКтКорСчета Тогда
		
		ВывестиЗаголовкиОборотовОтчетаОборотыСчета(Макет, ИмяСтроки+"|ОборотКтКорсчет", Выборка, 
			ДокументРезультат, ОбъектОтчет.ПоСубсчетамКорСчетов, ВидДвиженияБухгалтерии.Кредит, МассивРесурсов, СписокКт, ДополнениеКУровнюВывода);
			
	КонецЕсли;
	
	
	Если ДополнениеКУровнюВывода <> 0 Тогда
		
		Если ОбъектОтчет.СальдоКонДт Тогда
			ОблСальдоКонДт = Макет.ПолучитьОбласть(ИмяСтроки+"|СальдоКонДт");
			ДокументРезультат.Присоединить(ОблСальдоКонДт,0);
			ШиринаТаблицы = ШиринаТаблицы + ОблСальдоКонДт.ШиринаТаблицы;
		КонецЕсли;
		
		Если ОбъектОтчет.СальдоКонКт Тогда
			ОблСальдоКонКт = Макет.ПолучитьОбласть(ИмяСтроки+"|СальдоКонКт");
			ДокументРезультат.Присоединить(ОблСальдоКонКт,0);
			ШиринаТаблицы = ШиринаТаблицы + ОблСальдоКонКт.ШиринаТаблицы;
		КонецЕсли;
		
	КонецЕсли;
	
КонецПроцедуры

// процедурв выводит итоги оборотов за период для отчета обороты счета
Процедура ВывестиОборотыЗаПериод(СчетОграниченийОтчета, Знач ЕстьИтог, ОбщийИтог, Макет, ДокументРезультат,
	Знач СальдоКонДт, Знач СальдоКонКт) Экспорт
	
	СуммаКонКт = 0;
	СуммаКонДт = 0;
	
	Если ЕстьИтог Тогда
		
		СуммаНачКт = 0;
		СуммаНачДт = 0;
		
		СуммаОборотКт = 0;
		СуммаОборотДт = 0;
		
		ПолучитьДанныеДляОборотов(ОбщийИтог, "Нач",
			Ложь, Ложь, СуммаНачДт, СуммаНачКт);
			
		ПолучитьДанныеДляОборотов(ОбщийИтог, "Кон",
			Ложь, Ложь, СуммаКонДт, СуммаКонКт);
			
		ПолучитьДанныеДляОборотов(ОбщийИтог, "Оборот", 
			Ложь, Ложь, СуммаОборотДт, СуммаОборотКт);	
						
	КонецЕсли;
	
	Если СальдоКонДт Тогда
		
		Обл=Макет.ПолучитьОбласть("Итог|СальдоКонДт");
		Обл.Параметры.СуммаКонДт=СуммаКонДт;
		ДокументРезультат.Присоединить(Обл);
		
	КонецЕсли;
	
	Если СальдоКонКт Тогда
		
		Обл=Макет.ПолучитьОбласть("Итог|СальдоКонКт");
		Обл.Параметры.СуммаКонКт=СуммаКонКт;
		ДокументРезультат.Присоединить(Обл);
		
	КонецЕсли;
	
КонецПроцедуры

// процедура поддержка одновирменности для БухОтчетов
Процедура ПоддержкаОднофирменностиДляБухОтчетов(Форма, Организация, УчетПоВсемОрганизациям, Знач ЗаполнятьОрганизацию = Истина) Экспорт
	
	Если ЗаполнятьОрганизацию ИЛИ НЕ УчетПоВсемОрганизациям Тогда
		ПроизвестиПроверкуНаВедениеОднофирменности(Организация);
	КонецЕсли;
			
	Форма.ЭлементыФормы.Организация.ТолькоПросмотр = НЕ УчетПоВсемОрганизациям;
	
КонецПроцедуры

// процедура поддержка одновирменности для формы настроек БухОтчетов
Процедура ПоддержкаОднофирменностиДляФормыНастроекБухОтчетов(Форма, УчетПоВсемОрганизациям) Экспорт
	
	Форма.ЭлементыФормы.Организация.ТолькоПросмотр = НЕ УчетПоВсемОрганизациям;
	
КонецПроцедуры


///////////////////////////////////////////////////////////////////////////////
//ОБОРОТЫ ПО СЧЕТУ
///////////////////////////////////////////////////////////////////////////////

// процедура выводит итоги отчета оборотно сальдовая ведомость по счету
Процедура ВывестиИтогиОборотноСальдовойВедомостиПоСчету(Знач Выборка, Знач ИмяРегистраБухгалтерии, Знач МассивПоказателей, Знач ФорматПоказателей,
	Знач Счет, Знач ОбластьИтогиСтрокаЧисла, Знач ОбластьИтогиЧислаМакет, Знач ОбластьИтогиСтрокаСчет, Знач ДокументРезультат, ВыводитьРазвернутоеСальдо = Ложь) Экспорт
	
	ЭтоПерваяСтрока = Ложь;

	Для Каждого ИмяПоказателя Из МассивПоказателей Цикл

		Если НЕ Метаданные.РегистрыБухгалтерии[ИмяРегистраБухгалтерии].Ресурсы[ИмяПоказателя].Балансовый Тогда
			Продолжить;
		КонецЕсли;

		Если ЭтоПерваяСтрока = Истина Тогда
			Область = ОбластьИтогиСтрокаЧисла;
		Иначе
			Область = ОбластьИтогиЧислаМакет;
		КонецЕсли;

		ФорматПоказателя = "";
		ФорматПоказателей.Свойство(ИмяПоказателя, ФорматПоказателя);

		НачальныйОстатокДт = Выборка[ИмяПоказателя + "НачальныйОстатокДт"];
		НачальныйОстатокКт = Выборка[ИмяПоказателя + "НачальныйОстатокКт"];
		ОборотДт           = Выборка[ИмяПоказателя + "ОборотДт"];
		ОборотКт           = Выборка[ИмяПоказателя + "ОборотКт"];
		КонечныйОстатокДт  = Выборка[ИмяПоказателя + "КонечныйОстатокДт"];
		КонечныйОстатокКт  = Выборка[ИмяПоказателя + "КонечныйОстатокКт"];
		
		Если Счет.Вид = ВидСчета.Активный Тогда 
			
			Если НачальныйОстатокДт = 0 Тогда
				НачальныйОстатокДт = -НачальныйОстатокКт;
				НачальныйОстатокКт = 0;
			КонецЕсли;
			
			Если КонечныйОстатокДт = 0 Тогда
				КонечныйОстатокДт = -КонечныйОстатокКт;
				КонечныйОстатокКт = 0;
			КонецЕсли;
			
		ИначеЕсли Счет.Вид = ВидСчета.Пассивный Тогда
			
			Если НачальныйОстатокКт = 0 Тогда
				НачальныйОстатокКт = -НачальныйОстатокДт;
				НачальныйОстатокДт = 0;
			КонецЕсли;
			
			Если КонечныйОстатокКт = 0 Тогда
				КонечныйОстатокКт = -КонечныйОстатокДт;
				КонечныйОстатокДт = 0;
			КонецЕсли;
			
		КонецЕсли;
		
		Если ВыводитьРазвернутоеСальдо И НачальныйОстатокДт <> Неопределено Тогда
			
			НачальныйОстаток = НачальныйОстатокДт - НачальныйОстатокКт;
			Если НачальныйОстаток > 0 Тогда
				НачальныйСвернутыйОстатокДт = НачальныйОстаток;
				НачальныйСвернутыйОстатокКт = 0;
			Иначе
				НачальныйСвернутыйОстатокДт = 0;
				НачальныйСвернутыйОстатокКт = - НачальныйОстаток;
			КонецЕсли;
			
			КонечныйОстаток = КонечныйОстатокДт - КонечныйОстатокКт;
			Если КонечныйОстаток > 0 Тогда
				КонечныйСвернутыйОстатокДт = КонечныйОстаток;
				КонечныйСвернутыйОстатокКт = 0;
			Иначе
				КонечныйСвернутыйОстатокДт = 0;
				КонечныйСвернутыйОстатокКт = - КонечныйОстаток;
			КонецЕсли;
			
			Область.Параметры.НачальныйРазвернутыйОстатокДт = Формат(НачальныйОстатокДт, ФорматПоказателя);
			Область.Параметры.НачальныйРазвернутыйОстатокКт = Формат(НачальныйОстатокКт, ФорматПоказателя);
			Область.Параметры.НачальныйОстатокДт = Формат(НачальныйСвернутыйОстатокДт, ФорматПоказателя);
			Область.Параметры.НачальныйОстатокКт = Формат(НачальныйСвернутыйОстатокКт, ФорматПоказателя);
			Область.Параметры.ОборотДт           = Формат(ОборотДт, ФорматПоказателя);
			Область.Параметры.ОборотКт           = Формат(ОборотКт, ФорматПоказателя);
			Область.Параметры.КонечныйРазвернутыйОстатокДт  = Формат(КонечныйОстатокДт, ФорматПоказателя);
			Область.Параметры.КонечныйРазвернутыйОстатокКт  = Формат(КонечныйОстатокКт, ФорматПоказателя);
			Область.Параметры.КонечныйОстатокДт  = Формат(КонечныйСвернутыйОстатокДт, ФорматПоказателя);
			Область.Параметры.КонечныйОстатокКт  = Формат(КонечныйСвернутыйОстатокКт, ФорматПоказателя);
			
		Иначе
			
			Область.Параметры.НачальныйОстатокДт = Формат(НачальныйОстатокДт, ФорматПоказателя);
			Область.Параметры.НачальныйОстатокКт = Формат(НачальныйОстатокКт, ФорматПоказателя);
			Область.Параметры.ОборотДт           = Формат(ОборотДт, ФорматПоказателя);
			Область.Параметры.ОборотКт           = Формат(ОборотКт, ФорматПоказателя);
			Область.Параметры.КонечныйОстатокДт  = Формат(КонечныйОстатокДт, ФорматПоказателя);
			Область.Параметры.КонечныйОстатокКт  = Формат(КонечныйОстатокКт, ФорматПоказателя);
			
		КонецЕсли;

		Если ЭтоПерваяСтрока = Истина Тогда
			ДокументРезультат.Вывести(ОбластьИтогиСтрокаСчет, 1);
		КонецЕсли;

		ДокументРезультат.Присоединить(Область);
		
		ЭтоПерваяСтрока = Истина;

	КонецЦикла;
	
КонецПроцедуры

// процедура выводит текущие показатели оборотно сальдовой ведомости по счету
Процедура ВывестиПоказателиОборотноСальдовойВедомостиПоСчету(Выборка, СтруктураПараметров, Знач Счет, 
	Знач СтруктураЗамещающихДанных = Неопределено) Экспорт

	ВыведеноПоказателей = 0; // количество выведенных показателей
	Для Каждого ИмяПоказателя Из СтруктураПараметров.МассивПоказателей Цикл

		// Сумму в валюте выводим только по группировке Валюта
		Если ИмяПоказателя = "ВалютнаяСумма" Тогда
			Если Выборка.Группировка() <> "Валюта" Тогда
				Продолжить;
			КонецЕсли;
		КонецЕсли;

		Если ВыведеноПоказателей > 0 Тогда
			Область = СтруктураПараметров.ОбластьСтрокаПоказателяЧисла;
		Иначе
			Область = СтруктураПараметров.ОбластьСтрокаЧисла;
		КонецЕсли;
		
		ФорматПоказателя = "";
		СтруктураПараметров.ФорматПоказателей.Свойство(ИмяПоказателя, ФорматПоказателя);
		
		Если СтруктураЗамещающихДанных = Неопределено Тогда
			
			СальдоНачДт = Выборка[ИмяПоказателя + "НачальныйОстатокДт"];
			СальдоНачКт = Выборка[ИмяПоказателя + "НачальныйОстатокКт"];
			СальдоКонДт = Выборка[ИмяПоказателя + "КонечныйОстатокДт"];
			СальдоКонКт = Выборка[ИмяПоказателя + "КонечныйОстатокКт"];
			ОборотДт = Выборка[ИмяПоказателя + "ОборотДт"];
			ОборотКт = Выборка[ИмяПоказателя + "ОборотКт"];
			
		Иначе
			
			СальдоНачДт = СтруктураЗамещающихДанных[ИмяПоказателя + "НачальныйОстатокДт"];
			СальдоНачКт = СтруктураЗамещающихДанных[ИмяПоказателя + "НачальныйОстатокКт"];
			СальдоКонДт = СтруктураЗамещающихДанных[ИмяПоказателя + "КонечныйОстатокДт"];
			СальдоКонКт = СтруктураЗамещающихДанных[ИмяПоказателя + "КонечныйОстатокКт"];
			ОборотДт = СтруктураЗамещающихДанных[ИмяПоказателя + "ОборотДт"];
			ОборотКт = СтруктураЗамещающихДанных[ИмяПоказателя + "ОборотКт"];			
			
	    КонецЕсли;
		
		// Сальдо по счетам нужно привести к традиционному виду, в зависимости от вида выбранного счета:
		// если группировки Счет еще не было, сальдо в выборке рассчитаны как для активно-пассивного счета.
		Если Счет.Вид = ВидСчета.Активный Тогда
			
			СальдоНачДт = СальдоНачДт - СальдоНачКт;
			СальдоНачКт = 0;
			
			СальдоКонДт = СальдоКонДт - СальдоКонКт;
			СальдоКонКт = 0;
			
		ИначеЕсли Счет.Вид = ВидСчета.Пассивный Тогда
			
			СальдоНачКт = СальдоНачКт - СальдоНачДт;
			СальдоНачДт = 0;
			
			СальдоКонКт = СальдоКонКт - СальдоКонДт;
			СальдоКонДт = 0;
			
		КонецЕсли;
		
		Область.Параметры.НачальныйОстатокДт = Формат(СальдоНачДт, ФорматПоказателя);
		Область.Параметры.НачальныйОстатокКт = Формат(СальдоНачКт, ФорматПоказателя);
		Область.Параметры.ОборотДт           = Формат(ОборотДт,    ФорматПоказателя);
		Область.Параметры.ОборотКт           = Формат(ОборотКт,    ФорматПоказателя);
		Область.Параметры.КонечныйОстатокДт  = Формат(СальдоКонДт, ФорматПоказателя);
		Область.Параметры.КонечныйОстатокКт  = Формат(СальдоКонКт, ФорматПоказателя);

		ДокументРезультат = СтруктураПараметров.ДокументРезультат;

		Если ВыведеноПоказателей > 0 Тогда
			
			ВыводимаяОбласть = СтруктураПараметров.ОбластьСтрокаПоказателяСчет;
			
			Если ИмяПоказателя = "ВалютнаяСумма" Тогда
				ВыводимаяОбласть.Параметры.СубконтоПредставление = "Валютная сумма";
			Иначе
				ВыводимаяОбласть.Параметры.СубконтоПредставление = "";
			КонецЕсли;

			ВыведеннаяОбласть = ДокументРезультат.Вывести(ВыводимаяОбласть);

			ВыведеннаяОбласть.ГраницаСверху = СтруктураПараметров.НетЛинии;
						
		КонецЕсли;

		ДокументРезультат.Присоединить(Область);
		
		ВыведеноПоказателей = ВыведеноПоказателей+1;
				
	КонецЦикла;

КонецПроцедуры

//процедура выводит вложенную группировку оборотно сальдовой ведомости оп счету
Процедура ВывестиВложеннуюГруппировкуОборотноСальдовойВедомостиПоСчету(ОбъектОтчета, Выборка, Знач ИндексТекущейГруппировки, 
	СтруктураПараметров)
	
	Если ИндексТекущейГруппировки + 1 >= СтруктураПараметров.МассивГруппировок.Количество() Тогда
		Возврат;
	КонецЕсли;
	
	ВывестиГруппировкуОборотноСальдовойВедомостиПоСчету(ОбъектОтчета, Выборка.Выбрать(ОбходРезультатаЗапроса.ПоГруппировкам, СтруктураПараметров.МассивГруппировок[ИндексТекущейГруппировки + 1]), 
		ИндексТекущейГруппировки + 1, СтруктураПараметров);
		
КонецПроцедуры

// Выводит группировку при развороте счета по субсчетам и/или субконто для оборотно сальдовой ведомости по счету
Процедура ВывестиГруппировкуОборотноСальдовойВедомостиПоСчету(ОбъектОтчета, Выборка, Знач ИндексТекущейГруппировки, СтруктураПараметров) Экспорт

	Пока Выборка.Следующий() Цикл
		
		ИмяГруппировки = Выборка.Группировка();
		
		Если ИмяГруппировки = "Счет" Тогда
			
			ВыводимаяОбласть = СтруктураПараметров.ОбластьСтрокаСчет;
			
			ВыводимаяОбласть.Параметры.Заполнить(Выборка);
			
			ЗаполнитьПараметрыРасшифровкиОбороткиПоСчету(ОбъектОтчета, ВыводимаяОбласть, Выборка, СтруктураПараметров);
			
		ИначеЕсли Лев(ИмяГруппировки, 8) = "Субконто" Тогда
			
			Если Выборка[ИмяГруппировки] = Null Тогда
				Продолжить;
			КонецЕсли;
									
			ВыводимаяОбласть = СтруктураПараметров.ОбластьСтрокаПоказателяСчет;
			
			ВыводимаяОбласть.Параметры.Заполнить(Выборка);
			
			ВыводимаяОбласть.Параметры.СубконтоПредставление = Выборка[ИмяГруппировки + "Представление"];
			
			ЗаполнитьПараметрыРасшифровкиОбороткиПоСчету(ОбъектОтчета, ВыводимаяОбласть, Выборка, СтруктураПараметров)
			
		Иначе
			
			ВыводимаяОбласть = СтруктураПараметров.ОбластьСтрокаПоказателяСчет;
			
			ВыводимаяОбласть.Параметры.Заполнить(Выборка);
			ВыводимаяОбласть.Параметры.СубконтоПредставление = Выборка[ИмяГруппировки];
			
		КонецЕсли;
		
		// При выводе субсчетов не делаем отступы
		Отступ = ОбщегоНазначения.ВернутьИндексВМассиве(СтруктураПараметров.МассивГруппировок, ИмяГруппировки);
						
		// Не выводим счета более высокого уровня
		Если ИмяГруппировки = "Счет" 
			И СтруктураПараметров.СоответствиеСчетовПредков[Выборка.Счет] <> Неопределено Тогда
				
			ВывестиВложеннуюГруппировкуОборотноСальдовойВедомостиПоСчету(ОбъектОтчета, Выборка, ИндексТекущейГруппировки, СтруктураПараметров);
			Продолжить;
			
		КонецЕсли;
		
		ДокументРезультат = СтруктураПараметров.ДокументРезультат;
		
		ВыводимаяОбласть.Область("R1C2").Отступ = Отступ;
		
		ДокументРезультат.Вывести(ВыводимаяОбласть, Выборка.Уровень() );
		
		Если Выборка.ТипЗаписи() = ТипЗаписиЗапроса.ИтогПоИерархии 
		   И ИмяГруппировки <> "Счет" Тогда
			
			ДокументРезультат.Область(ДокументРезультат.ВысотаТаблицы, 2).Шрифт = СтруктураПараметров.ШрифтГрупп;
			
		КонецЕсли;
		
		ВывестиПоказателиОборотноСальдовойВедомостиПоСчету(Выборка, СтруктураПараметров, ОбъектОтчета.Счет);
		
		// Если по валютам,
		Если СтруктураПараметров.СтруктураОграничений.ПоВалютам Тогда
			
			ВыборкаПоВалютам = Выборка.Выбрать(ОбходРезультатаЗапроса.ПоГруппировкам, "Валюта");
			Пока ВыборкаПоВалютам.Следующий() Цикл
				
				ВыводимаяОбласть = СтруктураПараметров.ОбластьСтрокаПоказателяСчет;
				
				ВыводимаяОбласть.Параметры.Заполнить(Выборка);
				ВыводимаяОбласть.Параметры.СубконтоПредставление = "Валюта " + ВыборкаПоВалютам.ВалютаПредставление;
				
				ВыводимаяОбласть.Область("R1C2").Отступ = Отступ + 1;
				
				// Заполнение параметров расшифровки
				ЗаполнитьПараметрыРасшифровкиОбороткиПоСчету(ОбъектОтчета, ВыводимаяОбласть, Выборка, СтруктураПараметров);
				
				ДокументРезультат.Вывести(ВыводимаяОбласть, Выборка.Уровень());
				
				ВывестиПоказателиОборотноСальдовойВедомостиПоСчету(ВыборкаПоВалютам, СтруктураПараметров, ОбъектОтчета.Счет);
				
			КонецЦикла;
			
		КонецЕсли;

        // Если есть следующая группировка, то выбираем ее
		ВывестиВложеннуюГруппировкуОборотноСальдовойВедомостиПоСчету(ОбъектОтчета, Выборка, ИндексТекущейГруппировки, СтруктураПараметров);
			
	КонецЦикла;

КонецПроцедуры

//Функция формирует структуру параметров ограничений для оборотно-сальдовой ведомости
Функция СформироватьСтруктуруОграниченийДляОборотноСальдовойВедомостиПоСчету(ОбъектОтчета,
		Знач ПоВалютам, Знач ВидУчета = Неопределено, Знач Валюта = Неопределено, Знач ОтражениеВНУ = Неопределено,
		Знач Сценарий = Неопределено, Знач ВВалютеСценария = Неопределено) Экспорт
	
	Структура = Новый Структура();
	Структура.Вставить("ДатаНач", ОбъектОтчета.ДатаНач);
	Структура.Вставить("ДатаКон", ОбъектОтчета.ДатаКон);
	Попытка
		Структура.Вставить("Организация", ОбъектОтчета.Организация);
	Исключение
		Структура.Вставить("Организация", Неопределено);
	КонецПопытки;
	
	Структура.Вставить("ПоВалютам", ПоВалютам);
	
	Структура.Вставить("ВидУчета", ВидУчета);	
	
	Структура.Вставить("Валюта",  Валюта);
	Структура.Вставить("ОтражениеВНУ",  ОтражениеВНУ);
	
	Структура.Вставить("Сценарий",  Сценарий);
	
	Структура.Вставить("ВВалютеСценария",  ВВалютеСценария);
	
	Структура.Вставить("ИмяРегистраБухгалтерии", ОбъектОтчета.ИмяРегистраБухгалтерии);
	
	Возврат Структура; 
	
КонецФункции

//Функция Определяет вид отбора по типу значения объекта
Функция ПолучитьВидОтбораПоТипуЗначения(ЗначениеОтбора)
	
	ВидСравненияОтчета = ВидСравнения.Равно;
	
	Если (ЗначениеОтбора = NULL)	
		ИЛИ НЕ ЗначениеЗаполнено(ЗначениеОтбора) Тогда
		
		Возврат ВидСравненияОтчета;
		
	КонецЕсли;
	
	// нужно определить это ссылочный тип или нет
	Попытка
		
		Если Справочники.ТипВсеСсылки().СодержитТип(ТипЗнч(ЗначениеОтбора))
			ИЛИ ПланыВидовХарактеристик.ТипВсеСсылки().СодержитТип(ТипЗнч(ЗначениеОтбора)) Тогда
			Если ЗначениеОтбора.Метаданные().Иерархический Тогда
				ВидСравненияОтчета = ВидСравнения.ВИерархии;
			Иначе
				ВидСравненияОтчета = ВидСравнения.Равно;
			КонецЕсли;
		КонецЕсли; 
		
	Исключение
	КонецПопытки;
			
	Возврат ВидСравненияОтчета;
	
КонецФункции

//Функция создает структуру дополнительных ограничений для расшифровки отчета
Функция СоздатьСтруктуруДопОграниченийДляОборотноСальдовойВедомостиПоСчету(ОтчетОбъект, Выборка, МассивГруппировок, 
	Знач ВыводитьВсеГруппировки = Ложь) Экспорт
	
	ДополнительныеОтборы = СоздатьТаблицуДляХраненияОтбора(Истина);
	
	ИмяГруппировки = Выборка.Группировка();
	Если ВыводитьВсеГруппировки Тогда
		НомерГруппировкиВМассиве = МассивГруппировок.Количество() - 1;
	Иначе	
		НомерГруппировкиВМассиве = ОбщегоНазначения.ВернутьИндексВМассиве(МассивГруппировок, ИмяГруппировки);
	КонецЕсли;
	
	Для Сч = 0 По НомерГруппировкиВМассиве Цикл 
		
		ТекущееИмяГруппировки = Врег(МассивГруппировок[Сч]);
		
		Если ТекущееИмяГруппировки = "СЧЕТ"
			ИЛИ ТекущееИмяГруппировки = "ОБЩИЕ" Тогда         
			
			Продолжить;
			
		КонецЕсли;
		
		Измерение = ОтчетОбъект.ПостроительОтчета.ИзмеренияСтроки.Найти(ТекущееИмяГруппировки);
		
		СтрокаОтбора = ДополнительныеОтборы.ДОбавить();
		СтрокаОтбора.Использование = Истина;
		СтрокаОтбора.Имя = Измерение.ПутьКДанным;
		
		Если Измерение.ТипИзмерения = ТипИзмеренияПостроителяОтчета.Элементы Тогда
			ВидСравненияДанных = ВидСравнения.Равно;
		Иначе			
			// надо тип отбора определить и по нему можно сказать вид сравнения
			ВидСравненияДанных = ПолучитьВидОтбораПоТипуЗначения(Выборка[ТекущееИмяГруппировки]);
		КонецЕсли;
		
		СтрокаОтбора.ВидСравнения = ВидСравненияДанных;
		СтрокаОтбора.Значение = Выборка[ТекущееИмяГруппировки];
				
		Если Измерение <> Неопределено Тогда
					
			СтрокаОтбора.Имя = Измерение.ПутьКДанным;
			СтрокаОтбора.ПутьКДанным = Измерение.ПутьКДанным;
			
		Иначе
						
			СтрокаОтбора.Имя = ТекущееИмяГруппировки;
			СтрокаОтбора.ПутьКДанным = ТекущееИмяГруппировки;
			
		КонецЕсли;
	
	КонецЦикла;

	Возврат ДополнительныеОтборы;
	
КонецФункции

// процедура заполняет параметры расшифровки для счета по отчету оборотно сальдовая ведомость по счету
Процедура ЗаполнитьРасшифровкуДляСчета(ОтчетОбъект, Область, Выборка, СтруктураПараметров, Знач ИмяРегистраБухгалтерии,
	Знач РасшифровываемыйСчет, Знач РасшифровываемыйСчетПредставление) Экспорт
		
	ПараметрыКарточкиСчета = Новый Соответствие;
	
	ПараметрыКарточкиСчета.Вставить("ИмяОбъекта", "КарточкаСчета" + ИмяРегистраБухгалтерии);

	ПараметрыКарточкиСчета.Вставить("Счет", РасшифровываемыйСчет);

	ИмяГруппировки = Выборка.Группировка();
	
	Если Лев(ИмяГруппировки, 8) = "Субконто" Тогда

		// надо в структуру доп ограничений поместить все группировки более высокого уровня
		ДополнительныеОтборы = СоздатьСтруктуруДопОграниченийДляОборотноСальдовойВедомостиПоСчету(ОтчетОбъект, Выборка, СтруктураПараметров.МассивГруппировок);
				
		ПараметрыКарточкиСчета.Вставить("ДополнительныеОтборы", ДополнительныеОтборы);
		
		СписокРасшифровки = Новый СписокЗначений;

		СписокРасшифровки.Добавить(ПараметрыКарточкиСчета, "Карточка счета " + РасшифровываемыйСчетПредставление);
		
	ИначеЕсли ИмяГруппировки = "Счет" Тогда

		СписокРасшифровки = Новый СписокЗначений;
        СписокРасшифровки.Добавить(ПараметрыКарточкиСчета, "Карточка счета " + РасшифровываемыйСчетПредставление);
		
	Иначе
		
		СписокРасшифровки = Неопределено;
		
	КонецЕсли;

	Область.Параметры.Расшифровка = СписокРасшифровки;	
	
КонецПроцедуры

// Заполняет параметры расшифровки
//
// Параметры:
//	Нет.
//
Процедура ЗаполнитьПараметрыРасшифровкиОбороткиПоСчету(ОтчетОбъект, Область, Выборка, СтруктураПараметров) Экспорт

	// Если итоги по счету не анализируются, берем общий
	Если Выборка.Счет = NULL Тогда
		
		РасшифровываемыйСчет = ОтчетОбъект.Счет;
		РасшифровываемыйСчетПредставление = Строка(ОтчетОбъект.Счет);
		
	Иначе
		
		РасшифровываемыйСчет = Выборка.Счет;
		РасшифровываемыйСчетПредставление = Выборка.СчетПредставление;
		
	КонецЕсли;
	
	ЗаполнитьРасшифровкуДляСчета(ОтчетОбъект, Область, Выборка, СтруктураПараметров, ОтчетОбъект.ИмяРегистраБухгалтерии,
		РасшифровываемыйСчет, РасшифровываемыйСчетПредставление);
    
КонецПроцедуры


///////////////////////////////////////////////////////////////////////////////
//ОТЧЕТ ПО ПРОВОДКАМ
///////////////////////////////////////////////////////////////////////////////

// Формирование строки описания корреспонденций для заголовка отчета
Функция СформироватьОписаниеКорреспондеции(Корреспонденции) Экспорт

	СтрокаОписания = "";

	Для каждого стр Из Корреспонденции Цикл
		СтрокаКор = ?(стр.СчетДт.Пустая(), "*", Строка(стр.СчетДт));
		СтрокаКор = СтрокаКор + "," + ?(стр.СчетКт.Пустая(), "*", Строка(стр.СчетКт));
		СтрокаКор = СтрокаКор + ?(ПустаяСтрока(стр.ПредставлениеСубконто), "", ", " + стр.ПредставлениеСубконто);
		
		СтрокаОписания = СтрокаОписания + ?(ПустаяСтрока(СтрокаОписания), "", "; ") + СтрокаКор;
	КонецЦикла;

	Возврат СтрокаОписания;

КонецФункции

Процедура ОбвестиОбластиОтчета(ДокументРезультат, НачалоСекции = 0, Линия, ЛинияЖирная) Экспорт
	
	КонСтр = ДокументРезультат.ВысотаТаблицы;

	ДокументРезультат.Область(КонСтр,2,КонСтр,4).ГраницаСнизу = Линия;
	ДокументРезультат.Область(КонСтр,5,КонСтр,8).ГраницаСнизу = ЛинияЖирная;
	ДокументРезультат.Область(КонСтр,9,КонСтр,12).ГраницаСнизу = Линия;
	
	ДокументРезультат.Область(НачалоСекции,2,КонСтр,2).Объединить();
	ДокументРезультат.Область(НачалоСекции,3,КонСтр,3).Объединить();
	ДокументРезультат.Область(НачалоСекции,2,КонСтр,3).РазмещениеТекста = ТипРазмещенияТекстаТабличногоДокумента.Переносить;
	
КонецПроцедуры

// процедура создает колонки для корреспонденции плана счетов
Процедура СоздатьКолонкиОграниченийДляКорреспонденцииПланаСчетов(Корреспонденции, Знач ИмяПланаСчетов) Экспорт
	
	ОписаниеТиповПланСчетов = Новый ОписаниеТипов("ПланСчетовСсылка." + ИмяПланаСчетов);
	ОписаниеТиповТаблицаЗначений = Новый ОписаниеТипов("ТаблицаЗначений");
	ОписаниеТиповСтрока = Новый ОписаниеТипов("Строка",, Новый КвалификаторыСтроки(200));

	Корреспонденции.Колонки.Добавить("СчетДт",     ОписаниеТиповПланСчетов, "Дебет");
	Корреспонденции.Колонки.Добавить("СчетКт",     ОписаниеТиповПланСчетов, "Кредит");
	Корреспонденции.Колонки.Добавить("Субконто",   ОписаниеТиповТаблицаЗначений);
	Корреспонденции.Колонки.Добавить("ПредставлениеСубконто", ОписаниеТиповСтрока);
	
КонецПроцедуры

// Формирование списка номеров журналов, присутствующих в базе
//
// Параметры
//    Нет
//
// Возвращаемое значение:
//   СписокЗначений   – Список номеров журналов, которые есть в базе
//
Функция ВернутьСписокНомеровЖурналов(Знач ИмяРегистраБухгалтерии) Экспорт
	
	Запрос = Новый Запрос;
	Запрос.Текст = 
	"ВЫБРАТЬ РАЗЛИЧНЫЕ
	|	Регистр.НомерЖурнала КАК НомерЖурнала
	|ИЗ
	|	РегистрБухгалтерии." + ИмяРегистраБухгалтерии + " КАК Регистр
	|
	|УПОРЯДОЧИТЬ ПО
	|	НомерЖурнала";
	

	СписокНомеровЖурналов = Новый СписокЗначений;
	СписокНомеровЖурналов.ЗагрузитьЗначения(Запрос.Выполнить().Выгрузить().ВыгрузитьКолонку("НомерЖурнала"));
	
	Возврат СписокНомеровЖурналов;
	
КонецФункции

//Функция возвращает нужно ли пропустить текущую строку выборки при выводе данных или нет
Функция ОпределитьНеобходимоПропуститьСтрокуПриВыводеДанных(Выборка, Знач ПоПодстрокеСодержание, Знач ПоПодстрокеСубконто,
	Знач БезУчетаРегистра, Знач Подстрока, Знач МаксКоличествоСубконто) Экспорт
	
	Если НЕ (ПоПодстрокеСодержание ИЛИ ПоПодстрокеСубконто) Тогда
		Возврат Ложь;
	КонецЕсли;
	
	ПодстрокаПоиска = ?(БезУчетаРегистра, НРег(Подстрока), Подстрока);
	
	// поиск по ИЛИ на вхождение в содержание или в Субконто
	Если ПоПодстрокеСодержание Тогда
		
		Если БезУчетаРегистра Тогда
			СтрокаНайдена = Найти(НРег(Выборка.Содержание), ПодстрокаПоиска) > 0;
		Иначе
			СтрокаНайдена = Найти(Выборка.Содержание, ПодстрокаПоиска) > 0;
		КонецЕсли;
		
		Если СтрокаНайдена Тогда
			// строка уже найдена, дальше искать не надо
			Возврат Ложь;
		КонецЕсли;
		
	КонецЕсли;
	
			
	Если ПоПодстрокеСубконто Тогда
		
		Для Сч = 1 По МаксКоличествоСубконто Цикл
			
			СубконтоДт = ?(БезУчетаРегистра, НРег(Выборка["СубконтоДт" + Сч]), Выборка["СубконтоДт" + Сч]);
			СубконтоКт = ?(БезУчетаРегистра, НРег(Выборка["СубконтоКт" + Сч]), Выборка["СубконтоКт" + Сч]);
			
			Если Найти(СубконтоДт, ПодстрокаПоиска) > 0
				Или Найти(СубконтоКт, ПодстрокаПоиска) > 0 Тогда
						
				Возврат Ложь;
										
			КонецЕсли;
						
		КонецЦикла;
		
	КонецЕсли;
	
	// ничего не нашли
	Возврат Истина;
	
КонецФункции	

// процедура добовляет очередную строку к отборам отчета па проводкам
Процедура ДополнитьОтборОчереднойСтрокой(ОтборДанных, ТаблицаОтборов, Знач СтрокаДБКТ, Знач Счет)
	
	Для каждого Элемент Из ОтборДанных Цикл
		Если Элемент.Имя = "ВидУчетаДт" ИЛИ Элемент.Имя = "ВидУчетаКт" Тогда
			СтрокаАналитики = ТаблицаОтборов.Добавить();
			СтрокаАналитики.ПутьКДанным   = "ВидУчета" + СтрокаДБКТ;
			СтрокаАналитики.Представление = СтрокаДБКТ + " Вид учета";
			СтрокаАналитики.Значение      = Элемент.Значение;
			СтрокаАналитики.ВидСравнения  = Элемент.ВидСравнения;
		Иначе
			ТекПозиция = 1;
			
			Пока ТекПозиция <= СтрДлина(Элемент.Имя) Цикл
				
				Если Сред(Элемент.Имя, ТекПозиция, 1) >= "0" И Сред(Элемент.Имя, ТекПозиция, 1) <= "9" Тогда
					Прервать;
				КонецЕсли;
				ТекПозиция = ТекПозиция + 1;
				
			КонецЦикла;
			
			Если НЕ(Сред(Элемент.Имя, ТекПозиция, 1) >= "0" И Сред(Элемент.Имя, ТекПозиция, 1) <= "9") Тогда
				Продолжить;
			КонецЕсли;
			
			СтрокаПрефиксаИмени = Сред(Элемент.Имя, 1, ТекПозиция - 1); 
			
			Если НЕ (Врег(Сред(СтрокаПрефиксаИмени, СтрДлина(СтрокаПрефиксаИмени) - 1, 2)) = "ДТ"  
				ИЛИ Врег(Сред(СтрокаПрефиксаИмени, СтрДлина(СтрокаПрефиксаИмени) - 1, 2)) = "КТ") Тогда
				
				СтрокаПрефиксаИмени = СтрокаПрефиксаИмени + СтрокаДБКТ;		
			КонецЕсли;
			
			СтрокаПоискаНомера = Сред(Элемент.Имя, ТекПозиция);
			
			КонецНомера = Найти(СтрокаПоискаНомера, ".");
			НомерСубконто = Число(?(КонецНомера = 0, СтрокаПоискаНомера, Лев(СтрокаПоискаНомера, КонецНомера - 1)));
			ХвостИмениОтбора = ?(КонецНомера=0, "", Сред(СтрокаПоискаНомера,КонецНомера + 1));
			
			СтрокаАналитики = ТаблицаОтборов.Добавить();
			СтрокаАналитики.ПутьКДанным = СтрокаПрефиксаИмени + СтрокаПоискаНомера;
			Если ЗначениеЗаполнено(Счет) Тогда
				СтрокаАналитики.Представление = СтрокаДБКТ + " " + Строка(Счет.ВидыСубконто[НомерСубконто-1].ВидСубконто) + ХвостИмениОтбора;
			Иначе
				СтрокаАналитики.Представление = "Субконто" + СтрокаДБКТ + Элемент.Имя;
			КонецЕсли;
			
			СтрокаАналитики.Значение = Элемент.Значение;
			СтрокаАналитики.ВидСравнения = Элемент.ВидСравнения;
		КонецЕсли;	
	КонецЦикла;
	
КонецПроцедуры

// Создание структуры таблицы для хранения данных об отборе по субконто каждой корреспонденции
Функция СоздатьТаблицуДляХраненияОтбора(Знач ДобавлятьКолонкуИспользования = Ложь) Экспорт
	
	ТаблицаОтбора = Новый ТаблицаЗначений();
		
	ТаблицаОтбора.Колонки.Добавить("Имя", Новый ОписаниеТипов("Строка"));
	ТаблицаОтбора.Колонки.Добавить("ПутьКДанным", Новый ОписаниеТипов("Строка"));
	ТаблицаОтбора.Колонки.Добавить("Представление", Новый ОписаниеТипов("Строка"));
	ТаблицаОтбора.Колонки.Добавить("ВидСравнения", Новый ОписаниеТипов("ВидСравнения"));
	ТаблицаОтбора.Колонки.Добавить("Значение");
	ТаблицаОтбора.Колонки.Добавить("ЗначениеС");
	ТаблицаОтбора.Колонки.Добавить("ЗначениеПо");
	
	Если ДобавлятьКолонкуИспользования Тогда
		ТаблицаОтбора.Колонки.Добавить("Использование");
	КонецЕсли;
	
	Возврат ТаблицаОтбора;
	
КонецФункции

//процедура добавляет в таблицу очередной отбор
Функция ДобавитьВТаблицуОчереднойОтбор(ТаблицаОтбора, Знач Имя, Знач Значение, Знач ВидСравненияПоУмолчанию = Неопределено)
	
	СтрокаДобавления = ТаблицаОтбора.Добавить();
	СтрокаДобавления.Имя = Имя; 
	Если ТипЗнч(Значение) = Тип("Структура") Тогда
		СтрокаДобавления.Значение = Значение.Значение; 
	Иначе
		СтрокаДобавления.Значение = Значение; 
	КонецЕсли; 
	
	Если ВидСравненияПоУмолчанию = Неопределено Тогда
		Если ТипЗнч(Значение) = Тип("Структура") Тогда
			СтрокаДобавления.ВидСравнения = Значение.ВидСравнения;
		Иначе
			СтрокаДобавления.ВидСравнения = ПолучитьТипСравненияПоЗначению(Значение);
		КонецЕсли;
	Иначе
		СтрокаДобавления.ВидСравнения = ВидСравненияПоУмолчанию;
	КонецЕсли;
	
	Возврат СтрокаДобавления;
	
КонецФункции

Функция ПолучитьТипСравненияПоЗначению(Значение)
	
	Если (ТипЗнч(Значение) = Тип("СписокЗначений") ИЛИ ТипЗнч(Значение) = Тип("Массив")) Тогда
		Возврат ВидСравнения.ВСписке;
	Иначе
		Тип = ТипЗнч(Значение);
		ОбъектМетаданных = Метаданные.НайтиПоТипу(Тип);
		Если ОбъектМетаданных = Неопределено Тогда
			Возврат ВидСравнения.Равно;
		КонецЕсли;
		
		Если Метаданные.Справочники.Содержит(ОбъектМетаданных) Тогда
			Если Значение.ЭтоГруппа Тогда
				Возврат ВидСравнения.ВИерархии;
			КонецЕсли;
		КонецЕсли;
		Возврат ВидСравнения.Равно;
		
	КонецЕсли;
		
КонецФункции

// Получение строкового представления строки отборов
//
// Параметры
//  ТаблицаОтборов  – ТаблицаЗначений, Отбор – Таблица отборов
//
// Возвращаемое значение:
//   Строка   – строковое представление списка отборов
//
Функция ПолучитьПредставлениеОтбораПоТаблице(ТаблицаОтборов) Экспорт

	СтрокаОтборов = "";
	
	Если ТипЗнч(ТаблицаОтборов) <> Тип("Отбор") Тогда
		Возврат СтрокаОтборов;
	КонецЕсли;
	
	Для каждого ЭлементОтбора Из ТаблицаОтборов Цикл
		
		СтрокаОтборов = СтрокаОтборов + ", ";
	
		Если ЭлементОтбора.ВидСравнения = ВидСравнения.Равно Тогда
			СтрокаОтборов = СтрокаОтборов + ЭлементОтбора.Представление + " = "+ ?(НЕ ЗначениеЗаполнено(ЭлементОтбора.Значение), "Пусто", СокрЛП(Строка(ЭлементОтбора.Значение)));
		ИначеЕсли ЭлементОтбора.ВидСравнения = ВидСравнения.НеРавно Тогда
			СтрокаОтборов = СтрокаОтборов + ЭлементОтбора.Представление + " <> "+ ?(НЕ ЗначениеЗаполнено(ЭлементОтбора.Значение), "Пусто", СокрЛП(Строка(ЭлементОтбора.Значение)));
		ИначеЕсли ЭлементОтбора.ВидСравнения = ВидСравнения.ВСписке Тогда
			СтрокаСписка = "";
			Для каждого ЭлементСписка Из ЭлементОтбора.Значение Цикл
				Если НЕ ПустаяСтрока(СтрокаСписка) Тогда
					СтрокаСписка = СтрокаСписка + "; ";
				КонецЕсли; 
				Если НЕ ЗначениеЗаполнено(ЭлементСписка.Представление) Тогда
					СтрокаСписка = СтрокаСписка + СокрЛП(Строка(ЭлементСписка.Значение));
				Иначе
					СтрокаСписка = СтрокаСписка + СокрЛП(ЭлементСписка.Представление);
				КонецЕсли;
			КонецЦикла; 
			СтрокаОтборов = СтрокаОтборов + ЭлементОтбора.Представление + " в списке "+ ?(НЕ ЗначениеЗаполнено(ЭлементОтбора.Значение), "Пусто", СтрокаСписка);
		ИначеЕсли ЭлементОтбора.ВидСравнения = ВидСравнения.ВСпискеПоИерархии Тогда
			СтрокаСписка = "";
			Для каждого ЭлементСписка Из ЭлементОтбора.Значение Цикл
				Если НЕ ПустаяСтрока(СтрокаСписка) Тогда
					СтрокаСписка = СтрокаСписка + "; ";
				КонецЕсли; 
				Если НЕ ЗначениеЗаполнено(ЭлементСписка.Представление) Тогда
					СтрокаСписка = СтрокаСписка + СокрЛП(Строка(ЭлементСписка.Значение));
				Иначе
					СтрокаСписка = СтрокаСписка + СокрЛП(ЭлементСписка.Представление);
				КонецЕсли;
			КонецЦикла; 
			СтрокаОтборов = СтрокаОтборов + ЭлементОтбора.Представление + " в списке по иерархии "+ ?(НЕ ЗначениеЗаполнено(ЭлементОтбора.Значение), "Пусто", СтрокаСписка);
		ИначеЕсли ЭлементОтбора.ВидСравнения = ВидСравнения.НеВСписке Тогда
			СтрокаСписка = "";
			Для каждого ЭлементСписка Из ЭлементОтбора.Значение Цикл
				Если НЕ ПустаяСтрока(СтрокаСписка) Тогда
					СтрокаСписка = СтрокаСписка + "; ";
				КонецЕсли;
				Если НЕ ЗначениеЗаполнено(ЭлементСписка.Представление) Тогда
					СтрокаСписка = СтрокаСписка + СокрЛП(Строка(ЭлементСписка.Значение));
				Иначе
					СтрокаСписка = СтрокаСписка + СокрЛП(ЭлементСписка.Представление);
				КонецЕсли;
			КонецЦикла; 
			СтрокаОтборов = СтрокаОтборов + ЭлементОтбора.Представление + " не в списке "+ ?(НЕ ЗначениеЗаполнено(ЭлементОтбора.Значение), "Пусто", СтрокаСписка);
		ИначеЕсли ЭлементОтбора.ВидСравнения = ВидСравнения.НеВСпискеПоИерархии Тогда
			СтрокаСписка = "";
			Для каждого ЭлементСписка Из ЭлементОтбора.Значение Цикл
				Если НЕ ПустаяСтрока(СтрокаСписка) Тогда
					СтрокаСписка = СтрокаСписка + "; ";
				КонецЕсли;
				Если НЕ ЗначениеЗаполнено(ЭлементСписка.Представление) Тогда
					СтрокаСписка = СтрокаСписка + СокрЛП(Строка(ЭлементСписка.Значение));
				Иначе
					СтрокаСписка = СтрокаСписка + СокрЛП(ЭлементСписка.Представление);
				КонецЕсли;
			КонецЦикла; 
			СтрокаОтборов = СтрокаОтборов + ЭлементОтбора.Представление + " не в списке по иерархии "+ ?(НЕ ЗначениеЗаполнено(ЭлементОтбора.Значение), "Пусто", СтрокаСписка);
		ИначеЕсли ЭлементОтбора.ВидСравнения = ВидСравнения.ВИерархии Тогда
			СтрокаОтборов = СтрокаОтборов + ЭлементОтбора.Представление + " в иерархии "+ ?(НЕ ЗначениеЗаполнено(ЭлементОтбора.Значение), "Пусто", ЭлементОтбора.Значение);
		ИначеЕсли ЭлементОтбора.ВидСравнения = ВидСравнения.НеВИерархии Тогда
			СтрокаОтборов = СтрокаОтборов + ЭлементОтбора.Представление + " не в иерархии "+ ?(НЕ ЗначениеЗаполнено(ЭлементОтбора.Значение), "Пусто", ЭлементОтбора.Значение);
		ИначеЕсли ЭлементОтбора.ВидСравнения = ВидСравнения.Больше Тогда
			СтрокаОтборов = СтрокаОтборов + ЭлементОтбора.Представление + " > "+ ?(НЕ ЗначениеЗаполнено(ЭлементОтбора.Значение), "Пусто", СокрЛП(Строка(ЭлементОтбора.Значение)));
		ИначеЕсли ЭлементОтбора.ВидСравнения = ВидСравнения.БольшеИлиРавно Тогда
			СтрокаОтборов = СтрокаОтборов + ЭлементОтбора.Представление + " >= "+ ?(НЕ ЗначениеЗаполнено(ЭлементОтбора.Значение), "Пусто", СокрЛП(Строка(ЭлементОтбора.Значение)));
		ИначеЕсли ЭлементОтбора.ВидСравнения = ВидСравнения.Меньше Тогда
			СтрокаОтборов = СтрокаОтборов + ЭлементОтбора.Представление + " < "+ ?(НЕ ЗначениеЗаполнено(ЭлементОтбора.Значение), "Пусто", СокрЛП(Строка(ЭлементОтбора.Значение)));
		ИначеЕсли ЭлементОтбора.ВидСравнения = ВидСравнения.МеньшеИлиРавно Тогда
			СтрокаОтборов = СтрокаОтборов + ЭлементОтбора.Представление + " <= "+ ?(НЕ ЗначениеЗаполнено(ЭлементОтбора.Значение), "Пусто", СокрЛП(Строка(ЭлементОтбора.Значение)));
		ИначеЕсли ЭлементОтбора.ВидСравнения = ВидСравнения.Интервал Тогда
			СтрокаОтборов = СтрокаОтборов + ?(НЕ ЗначениеЗаполнено(ЭлементОтбора.ЗначениеС), "...", СокрЛП(Строка(ЭлементОтбора.ЗначениеС))) + " < " + ЭлементОтбора.Представление + " < "+ ?(НЕ ЗначениеЗаполнено(ЭлементОтбора.ЗначениеПо), "...", СокрЛП(Строка(ЭлементОтбора.ЗначениеПо)));
		ИначеЕсли ЭлементОтбора.ВидСравнения = ВидСравнения.ИнтервалВключаяГраницы Тогда
			СтрокаОтборов = СтрокаОтборов + ?(НЕ ЗначениеЗаполнено(ЭлементОтбора.ЗначениеС), "...", СокрЛП(Строка(ЭлементОтбора.ЗначениеС))) + " <= " + ЭлементОтбора.Представление + " <= "+ ?(НЕ ЗначениеЗаполнено(ЭлементОтбора.ЗначениеПо), "...", СокрЛП(Строка(ЭлементОтбора.ЗначениеПо)));
		ИначеЕсли ЭлементОтбора.ВидСравнения = ВидСравнения.ИнтервалВключаяНачало Тогда
			СтрокаОтборов = СтрокаОтборов + ?(НЕ ЗначениеЗаполнено(ЭлементОтбора.ЗначениеС), "...", СокрЛП(Строка(ЭлементОтбора.ЗначениеС))) + " <= " + ЭлементОтбора.Представление + " < "+ ?(НЕ ЗначениеЗаполнено(ЭлементОтбора.ЗначениеПо), "...", СокрЛП(Строка(ЭлементОтбора.ЗначениеПо)));
		ИначеЕсли ЭлементОтбора.ВидСравнения = ВидСравнения.ИнтервалВключаяОкончание Тогда
			СтрокаОтборов = СтрокаОтборов + ?(НЕ ЗначениеЗаполнено(ЭлементОтбора.ЗначениеС), "...", СокрЛП(Строка(ЭлементОтбора.ЗначениеС))) + " < " + ЭлементОтбора.Представление + " <= "+ ?(НЕ ЗначениеЗаполнено(ЭлементОтбора.ЗначениеПо), "...", СокрЛП(Строка(ЭлементОтбора.ЗначениеПо)));
		КонецЕсли; 
	
	КонецЦикла;
	
	Возврат Сред(СтрокаОтборов, 3);
    	
КонецФункции

//Процедура заменяет в структуре отборы на отборы ДТ и КТ
Процедура ЗаменитьОбщиеОтборыНаОтборыДтКт(ОтборДляРасшифровки, РасшифровкаОтборПоСчетам, Знач ВидОборота) Экспорт
	
	Если ОтборДляРасшифровки = Неопределено Тогда
		Возврат;
	КонецЕсли;
	
	Если ТипЗнч(ОтборДляРасшифровки) = Тип("ТаблицаЗначений") Тогда
		
		Для каждого СтрокаТаблицы Из ОтборДляРасшифровки Цикл
						
			НовоеИмя = ?(ВидОборота = "ДТ", СтрЗаменить(СтрокаТаблицы.Имя, "Субконто", "СубконтоДт"), СтрЗаменить(СтрокаТаблицы.Имя, "Субконто", "СубконтоКт"));
			НовоеПутьКданным = ?(ВидОборота = "ДТ", СтрЗаменить(СтрокаТаблицы.ПутьКданным, "Субконто", "СубконтоДт"), СтрЗаменить(СтрокаТаблицы.ПутьКданным, "Субконто", "СубконтоКт"));
			
			СтрокаТаблицы.Имя = НовоеИмя;
			СтрокаТаблицы.ПутьКданным = НовоеПутьКданным;
												
		КонецЦикла;
		
	Иначе	
	
		Для каждого соот Из ОтборДляРасшифровки Цикл
						
			ИмяКлюча = ?(ВидОборота = "ДТ", СтрЗаменить(соот.Ключ, "Субконто", "СубконтоДт"), СтрЗаменить(соот.Ключ, "Субконто", "СубконтоКт"));
			РасшифровкаОтборПоСчетам.Вставить(ИмяКлюча, соот.Значение);
						
		КонецЦикла;
	
	КонецЕсли;
		
КонецПроцедуры

//Процедура заполняет настройки ограничений по параметрам
Процедура НастроитьОтборыДанныхПопараметрам(Параметры, Корреспонденции, Валюта, ОтборПоВалюте) Экспорт
	
	СтрокиОтбора = Параметры["Отбор"];
	
	ОтборСубконто = СоздатьТаблицуДляХраненияОтбора();
	ОтборКорСубконто = СоздатьТаблицуДляХраненияОтбора();
	ОтборСубконтоДт = СоздатьТаблицуДляХраненияОтбора();
	ОтборСубконтоКт = СоздатьТаблицуДляХраненияОтбора();
	
	КорСчет = Неопределено;
	
	Если ТипЗнч(СтрокиОтбора) = Тип("Соответствие")
		ИЛИ ТипЗнч(СтрокиОтбора) = Тип("Структура") Тогда
	
		Для каждого ЭлементОтбора Из СтрокиОтбора Цикл
			
			Если ВРег(Лев(ЭлементОтбора.Ключ,8)) = "СУБКОНТО" Тогда
				
				Если ВРег(Лев(ЭлементОтбора.Ключ,10)) = "СУБКОНТОДТ" Тогда
					
					ДобавитьВТаблицуОчереднойОтбор(ОтборСубконтоДт, ЭлементОтбора.Ключ, ЭлементОтбора.Значение);
					
				ИначеЕсли ВРег(Лев(ЭлементОтбора.Ключ,10)) = "СУБКОНТОКТ" Тогда
					
					ДобавитьВТаблицуОчереднойОтбор(ОтборСубконтоКт, ЭлементОтбора.Ключ, ЭлементОтбора.Значение);
					
				Иначе
					
					ДобавитьВТаблицуОчереднойОтбор(ОтборСубконто, ЭлементОтбора.Ключ, ЭлементОтбора.Значение);
										
				КонецЕсли;
				
			ИначеЕсли ВРег(Лев(ЭлементОтбора.Ключ,8)) = "ВИДУЧЕТА" Тогда
				
				Если ВРег(Лев(ЭлементОтбора.Ключ,10)) = "ВИДУЧЕТАДТ" И Параметры["ВидОборота"] = "Д" Тогда
					
					ДобавитьВТаблицуОчереднойОтбор(ОтборСубконтоДт, ЭлементОтбора.Ключ, ЭлементОтбора.Значение);
					
				ИначеЕсли ВРег(Лев(ЭлементОтбора.Ключ,10)) = "ВИДУЧЕТАКТ" И Параметры["ВидОборота"] = "К" Тогда
					
					ДобавитьВТаблицуОчереднойОтбор(ОтборСубконтоКт, ЭлементОтбора.Ключ, ЭлементОтбора.Значение);
					
				КонецЕсли;
				
			ИначеЕсли ВРег(Лев(ЭлементОтбора.Ключ,11)) = "КОРСУБКОНТО" Тогда
				
				ДобавитьВТаблицуОчереднойОтбор(ОтборКорСубконто, Сред(ЭлементОтбора.Ключ, 4), ЭлементОтбора.Значение);
                				
			ИначеЕсли ВРег(ЭлементОтбора.Ключ) = "ВАЛЮТА" и НЕ ЗначениеЗаполнено(Валюта) Тогда
				
				Валюта = ЭлементОтбора.Значение;
				ОтборПоВалюте = ЗначениеЗаполнено(Валюта);
				
			ИначеЕсли ВРег(ЭлементОтбора.Ключ) = "КОРСЧЕТ" Тогда
				
				КорСчет = ЭлементОтбора.Значение;
				
			КонецЕсли;
			
		КонецЦикла;
		
	ИначеЕсли ТипЗнч(СтрокиОтбора) = Тип("ТаблицаЗначений") Тогда
		
		Для каждого ЭлементОтбора Из СтрокиОтбора Цикл
			
			Если ЭлементОтбора.Использование = Ложь Тогда
				Продолжить;
			КонецЕсли;
			
			Если ВРег(Лев(ЭлементОтбора.ПутьКДанным,8)) = "СУБКОНТО" Тогда
				
				Если ВРег(Лев(ЭлементОтбора.ПутьКДанным,10)) = "СУБКОНТОДТ" Тогда
					
					ДобавитьВТаблицуОчереднойОтбор(ОтборСубконтоДт, ЭлементОтбора.ПутьКДанным, ЭлементОтбора.Значение, ЭлементОтбора.ВидСравнения);
					
				ИначеЕсли ВРег(Лев(ЭлементОтбора.ПутьКДанным,10)) = "СУБКОНТОКТ" Тогда
					
					ДобавитьВТаблицуОчереднойОтбор(ОтборСубконтоКт, ЭлементОтбора.ПутьКДанным, ЭлементОтбора.Значение, ЭлементОтбора.ВидСравнения);
					
				Иначе
					
					ДобавитьВТаблицуОчереднойОтбор(ОтборСубконто, ЭлементОтбора.ПутьКДанным, ЭлементОтбора.Значение, ЭлементОтбора.ВидСравнения);
										
				КонецЕсли;
				
			ИначеЕсли ВРег(Лев(ЭлементОтбора.ПутьКДанным,8)) = "ВИДУЧЕТА" Тогда
				Если ЗначениеЗаполнено(ЭлементОтбора.Значение) Тогда
					Если ВРег(Лев(ЭлементОтбора.ПутьКДанным,10)) = "ВИДУЧЕТАДТ" Тогда	
						ДобавитьВТаблицуОчереднойОтбор(ОтборСубконтоДт, ЭлементОтбора.ПутьКДанным, ЭлементОтбора.Значение, ЭлементОтбора.ВидСравнения);
					ИначеЕсли ВРег(Лев(ЭлементОтбора.ПутьКДанным,10)) = "ВИДУЧЕТАКТ" Тогда
						ДобавитьВТаблицуОчереднойОтбор(ОтборСубконтоКт, ЭлементОтбора.ПутьКДанным, ЭлементОтбора.Значение, ЭлементОтбора.ВидСравнения);
					КонецЕсли;
				КонецЕсли;
			ИначеЕсли ВРег(Лев(ЭлементОтбора.ПутьКДанным,11)) = "КОРСУБКОНТО" Тогда
				
				ДобавитьВТаблицуОчереднойОтбор(ОтборКорСубконто, Сред(ЭлементОтбора.ПутьКДанным, 4), ЭлементОтбора.Значение, ЭлементОтбора.ВидСравнения);
                				
			КонецЕсли;
			
		КонецЦикла;		
			
	КонецЕсли;
	
	СчетДт =  Параметры["СчетДт"];
	СчетКт =  Параметры["СчетКт"];

	Счет    = Параметры["Счет"];
	Если КорСчет = Неопределено Тогда
		КорСчет = Параметры["КорСчет"];
	КонецЕсли;
	
	Если ЗначениеЗаполнено(СчетДт) или ЗначениеЗаполнено(СчетКт) Тогда
		стр = Корреспонденции.Добавить();
		
		стр.Субконто = СоздатьТаблицуДляХраненияОтбора();
		
		// заполним фильтры по дебетовой аналитике
		Если ЗначениеЗаполнено(СчетДт) Тогда
			стр.СчетДт = СчетДт;
			ДополнитьОтборОчереднойСтрокой(ОтборСубконтоДт, стр.Субконто, "Дт", СчетДт);							
		КонецЕсли;
		
		// заполним фильтры по кредитовой аналитике
		Если ЗначениеЗаполнено(СчетКт) Тогда
			стр.СчетКт = СчетКт;
			ДополнитьОтборОчереднойСтрокой(ОтборСубконтоКт, стр.Субконто, "Кт", СчетКт);				
		КонецЕсли;
		//
		Если ОтборСубконто.Количество()>0 Тогда
			Если СчетКт<>КорСчет Тогда
				ДополнитьОтборОчереднойСтрокой(ОтборСубконто, стр.Субконто, "Кт", СчетКт);
			Иначе
				ДополнитьОтборОчереднойСтрокой(ОтборСубконто, стр.Субконто, "Дт", СчетДт);
			КонецЕсли;
		КонецЕсли;
		Если ОтборКорСубконто.Количество()>0 Тогда
			Если СчетКт<>КорСчет Тогда
				ДополнитьОтборОчереднойСтрокой(ОтборКорСубконто, стр.Субконто, "Кт", СчетКт);
			Иначе
				ДополнитьОтборОчереднойСтрокой(ОтборКорСубконто, стр.Субконто, "Дт", СчетДт);
			КонецЕсли;
		КонецЕсли;
		
		стр.ПредставлениеСубконто = ПолучитьПредставлениеОтбораПоТаблице(стр.Субконто);
		
	Иначе
		стр = Корреспонденции.Добавить();
		стр.СчетДт = Счет;
		стр.Субконто = СоздатьТаблицуДляХраненияОтбора();
		
		ДополнитьОтборОчереднойСтрокой(ОтборСубконто, стр.Субконто, "Дт", Счет);
		ДополнитьОтборОчереднойСтрокой(ОтборКорСубконто, стр.Субконто, "Кт", КорСчет);
									
		стр.ПредставлениеСубконто = ПолучитьПредставлениеОтбораПоТаблице(стр.Субконто);
			
		стр.СчетКт = КорСчет;
		
		
		стр = Корреспонденции.Добавить();
		стр.СчетКт = Счет;
		стр.Субконто = СоздатьТаблицуДляХраненияОтбора();
				
		ДополнитьОтборОчереднойСтрокой(ОтборСубконто, стр.Субконто, "Кт", Счет);
						
		ДополнитьОтборОчереднойСтрокой(ОтборКорСубконто, стр.Субконто, "Дт", КорСчет);				
						
		стр.ПредставлениеСубконто = ПолучитьПредставлениеОтбораПоТаблице(стр.Субконто);
				
		стр.СчетДт = КорСчет;
				
	КонецЕсли;
	
	ВидУчета = Параметры["ВидУчета"];
	Если ЗначениеЗаполнено(Видучета) Тогда
		ОтборВидаУчетаДтКт = СоздатьТаблицуДляХраненияОтбора(); 
		ОтборВидаУчетастр = ОтборВидаУчетаДтКт.Добавить();
		ОтборВидаУчетастр.Имя = "";
		ОтборВидаУчетастр.ПутьКДанным = "ВидУчетаДт";
		ОтборВидаУчетастр.Представление = "Дт Вид учета";
		ОтборВидаУчетастр.ВидСравнения = ВидСравнения.Равно;
		ОтборВидаУчетастр.Значение = ВидУчета;
		
		ОтборВидаУчетастр = ОтборВидаУчетаДтКт.Добавить();
		ОтборВидаУчетастр.Имя = "";
		ОтборВидаУчетастр.ПутьКДанным = "ВидУчетаКт";
		ОтборВидаУчетастр.Представление = "Кт Вид учета";
		ОтборВидаУчетастр.ВидСравнения = ВидСравнения.Равно;
		ОтборВидаУчетастр.Значение = ВидУчета;
		
		Для Каждого Стр Из Корреспонденции Цикл
			стр.Субконто = ОтборВидаУчетаДтКт;
		КонецЦикла;
	КонецЕсли;

	
КонецПроцедуры


///////////////////////////////////////////////////////////////////////////////
//ОБОРОТЫ МЕЖДУ СУБКОНТО
///////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////
//КАРТОЧКА СУБКОНТО
///////////////////////////////////////////////////////////////////////////////

//Функция возвращает строку ограничений по типу субконто
Функция СформироватьОграниченияПоТипуСубконто(Запрос, Знач МассивСубконто, Знач ИмяРегистраБухгалтерии, Знач ИмяТаблицыСвязки) Экспорт
	
	ТекущееОграничений = "";
	НомерОграничения = 1;
	
	Для Каждого ЭлементМассиваСубконто Из МассивСубконто Цикл
		
		Если Не ПустаяСтрока(ТекущееОграничений) Тогда
			
			ТекущееОграничений = ТекущееОграничений + Символы.ПС + "И" + Символы.ПС;
			
		КонецЕсли;
		
		АлиасТаблицыОграничения = "Суб" + Строка(НомерОграничения);
		ЗначениеТаблицыОграничения =  "Вид" + Строка(НомерОграничения);
		
		ТекущееОграничений = ТекущееОграничений + " 1 В (Выбрать Первые 1 1 Из РегистрБухгалтерии." + ИмяРегистраБухгалтерии + ".Субконто КАК " + АлиасТаблицыОграничения + "
			|ГДЕ " + АлиасТаблицыОграничения + ".Регистратор = " + ИмяТаблицыСвязки + ".Регистратор
			|		И " + АлиасТаблицыОграничения + ".НомерСтроки = " + ИмяТаблицыСвязки + ".НомерСтроки
			|		И  " + АлиасТаблицыОграничения + ".Вид = &" + ЗначениеТаблицыОграничения + ")";
			
		Запрос.УстановитьПараметр(ЗначениеТаблицыОграничения + Строка(НомерОграничения), ЭлементМассиваСубконто);	
			
		НомерОграничения = НомерОграничения + 1;
		
	КонецЦикла;
				
	Возврат ТекущееОграничений;			
	
КонецФункции

//Процедура удаляет строки с пустым субконто из таблицы
Процедура УдалитьПустыеСубконтоИзТабличнойЧасти(ТабЧастьСубконто) Экспорт
	
	СчСубконто = ТабЧастьСубконто.Количество() - 1;
	Пока СчСубконто >= 0 Цикл
						
		Если НЕ ЗначениеЗаполнено(ТабЧастьСубконто[СчСубконто].ВидСубконто) Тогда
			
			ТабЧастьСубконто.Удалить(СчСубконто);
			
		КонецЕсли;
		
		СчСубконто = СчСубконто - 1;
		
	КонецЦикла;
	
КонецПроцедуры

//Процедура изменяет типы у отборов построителя по субконто
Процедура УстановитьТипыОтборовПостроителяПоСубконто(ПостроительОтчета, МассивСубконто) Экспорт
	
	Сч = 0;
	Для каждого Элемент Из МассивСубконто Цикл
		
		Сч = Сч + 1;
		Поле = ПостроительОтчета.ДоступныеПоля.Найти("Субконто"+Сч);
		
		Если Поле <> Неопределено Тогда
			
			Поле.ТипЗначения = Элемент.ТипЗначения;
			Поле.Представление = Элемент.Наименование;
			
		КонецЕсли;
	
	КонецЦикла;
	
КонецПроцедуры