///////////////////////////////////////////////////////////////////////////////
// СЛУЖЕБНЫЕ ПРОЦЕДУРЫ И ФУНКЦИИ

// Функция возвращает список подключенного в справочнике ПО
Функция ПолучитьСписокОборудования(ТипыПО = Неопределено, Идентификатор = Неопределено, РабочееМесто = Неопределено) Экспорт
	
	Возврат Справочники.ПодключаемоеОборудование.ПолучитьСписокОборудования(ТипыПО, Идентификатор, РабочееМесто);
	
КонецФункции

// Функция возвращает по идентификатору устройства его параметры
Функция ПолучитьПараметрыУстройства(Идентификатор) Экспорт

	Возврат Справочники.ПодключаемоеОборудование.ПолучитьПараметрыУстройства(Идентификатор);

КонецФункции

// Процедура предназначена для сохранения параметров устройства
//в реквизит Параметры типа хранилище значения в элементе справочника
Функция СохранитьПараметрыУстройства(Идентификатор, Параметры) Экспорт

	Возврат Справочники.ПодключаемоеОборудование.СохранитьПараметрыУстройства(Идентификатор, Параметры);

КонецФункции

// Функция возвращает структуру с данными устройства
//(со значениями реквизитов элемента справочника)
Функция ПолучитьДанныеУстройства(Идентификатор) Экспорт

	Возврат Справочники.ПодключаемоеОборудование.ПолучитьДанныеУстройства(Идентификатор);

КонецФункции

// Функция возвращает по идентификатору наименование драйвера устройства
Функция ПолучитьИмяДрайвераЭкземпляра(НаименованиеОбработчикаДрайвера) Экспорт

	Результат = "";

	Для каждого ИмяПеречисления Из Метаданные.Перечисления.ОбработчикиДрайверовПодключаемогоОборудования.ЗначенияПеречисления Цикл
		Если НаименованиеОбработчикаДрайвера = ИмяПеречисления.Синоним Тогда
			Результат = ИмяПеречисления.Имя;
			Прервать;
		КонецЕсли;
	КонецЦикла;

	Возврат Результат;

КонецФункции

// Функция возвращает из переменной сеанса имя компьютера клиента
Функция ПолучитьРабочееМестоКлиента() Экспорт

	УстановитьПривилегированныйРежим(Истина);
	Возврат ПараметрыСеанса.РабочееМестоКлиента;

КонецФункции

// Функция возвращает список рабочих мест, соответствующих указанному имени компьютера
Функция НайтиРабочиеМестаПоИД(ИдентификаторКлиента) Экспорт

	Запрос = Новый Запрос("
	|ВЫБРАТЬ
	|	РабочиеМеста.Ссылка
	|ИЗ
	|	Справочник.РабочиеМеста КАК РабочиеМеста
	|ГДЕ
	|	РабочиеМеста.Код = &Код
	|	И РабочиеМеста.ПометкаУдаления = ЛОЖЬ
	|");

	Запрос.УстановитьПараметр("Код", ИдентификаторКлиента);

	СписокКомпьютеров = Запрос.Выполнить().Выгрузить().ВыгрузитьКолонку("Ссылка");

	Возврат СписокКомпьютеров;

КонецФункции

// Функция устанавливает в переменную сеанса имя компьютера клиента
Процедура УстановитьРабочееМестоКлиента(РабочееМестоКлиента) Экспорт

	УстановитьПривилегированныйРежим(Истина);
	ПараметрыСеанса.РабочееМестоКлиента = РабочееМестоКлиента;
	ОбновитьПовторноИспользуемыеЗначения();

КонецПроцедуры

// Функция возвращает макет слип чека по наименованию макета
//
Функция ПолучитьСлипЧек(ИмяМакета, ШиринаСлипЧека, Параметры, АвторизацияПИН = Ложь) Экспорт

	Документ = Новый ТекстовыйДокумент();
	СлипЧек  = "";

	Макет    = ПолучитьОбщийМакет(ИмяМакета);
	Область  = Макет.ПолучитьОбласть("Чек" + ШиринаСлипЧека + ?(АвторизацияПИН, "пин", ""));

	Для Каждого Параметр Из Параметры Цикл
		Область.Параметры[Параметр.Ключ] = Параметр.Значение;
	КонецЦикла;

	Если Область <> Неопределено Тогда
		Документ.Вывести(Область);

		Для Индекс = 1 По Документ.КоличествоСтрок() Цикл
			СлипЧек = СлипЧек + Документ.ПолучитьСтроку(Индекс)
			        + ?(Индекс = Документ.КоличествоСтрок(), "", Символ(13) + Символ(10));
		КонецЦикла;
	КонецЕсли;

	Возврат СлипЧек;

КонецФункции

// Функция получает макет драйвера и сохраняет его во временное хранилище,
// возвращая ссылку на временное хранилище
Функция ПолучитьМакетССервера(ИмяМакета) Экспорт

	Ссылка = ПоместитьВоВременноеХранилище(ПолучитьОбщийМакет(ИмяМакета));
	Возврат Ссылка;

КонецФункции

// Функция возвращает значение константы
//
Функция ПолучитьКонстанту(ИмяКонстанты) Экспорт
	
	Константа = Константы[ИмяКонстанты].Получить();
	Возврат Константа;
	
КонецФункции           

// Функция возвращает доступность сохранение данных пользователя
//
Функция ПравоДоступаСохранениеДанныхПользователя() Экспорт
	
	Возврат ПравоДоступа("СохранениеДанныхПользователя", Метаданные);
	
КонецФункции

// Функция возвращает имя перечисления из его метаданных
//
Функция ПолучитьИмяТипаОборудования(ТипОборудования) Экспорт

	Результат = Неопределено;
	
	МтОбъект = ТипОборудования.Метаданные();
	Индекс = Перечисления.ТипыПодключаемогоОборудования.Индекс(ТипОборудования);
	Результат = МтОбъект.ЗначенияПеречисления[Индекс].Имя;

	Возврат Результат;

КонецФункции

// Функция возвращает созданное рабочее место клиента
Функция СоздатьРабочееМестоКлиента(Параметры) Экспорт

	УстановитьПривилегированныйРежим(Истина);
	
	РабочееМесто = Справочники.РабочиеМеста.СоздатьЭлемент();

	РабочееМесто.Код           = Параметры.ИдентификаторКлиента;
	РабочееМесто.ИмяКомпьютера = Параметры.ИмяКомпьютера;
	РабочееМесто.СетевойПорт   = Параметры.СетевойПорт;

	МенеджерОборудованияКлиентСервер.ЗаполнитьНаименованиеРабочегоМеста(РабочееМесто, ПользователиИнформационнойБазы.ТекущийПользователь());

	РабочееМесто.Записать();

	УстановитьПривилегированныйРежим(Ложь);
	
	Возврат РабочееМесто.Ссылка;

КонецФункции // СоздатьРабочееМестоКлиентаПоИД()

// Процедура устанавливает значения параметров сеанса, относящихся к подключаемому оборудованию
Процедура УстановитьПараметрыСеансаПодключаемогоОборудования(ИмяПараметра, УстановленныеПараметры) Экспорт

	Если ИмяПараметра = "РабочееМестоКлиента" Тогда
		
		//Если с идентификатором клиента текущего сеанса связано одно рабочее место,
		// то его сразу и запишем в параметры сеанса
		ТекущееРМ           = Справочники.РабочиеМеста.ПустаяСсылка();
		СистемнаяИнформация = Новый СистемнаяИнформация();

		СписокРМ = НайтиРабочиеМестаПоИД(ВРег(СистемнаяИнформация.ИдентификаторКлиента));
		Если СписокРМ.Количество() = 0 Тогда
			
			// Будет создано с клиента.
			
		ИначеЕсли СписокРМ.Количество() = 1 Тогда
			
			ТекущееРМ = СписокРМ[0];
			
		ИначеЕсли СписокРМ.Количество() > 1 Тогда
			
			// Будет выбрано на клиенте.
			
		КонецЕсли;
		
		УстановитьРабочееМестоКлиента(ТекущееРМ);
		
		Если ТипЗнч(УстановленныеПараметры) = Тип("Структура") Тогда
			УстановленныеПараметры.Вставить("РабочееМестоКлиента");
		Иначе
			УстановленныеПараметры.Добавить("РабочееМестоКлиента");
		КонецЕсли;
		
	КонецЕсли;
	
КонецПроцедуры

// Функция возвращает набор пользовательских настроек,
// связанных с механизмом подключаемого оборудования
Функция ПолучитьПользовательскиеНастройкиПодключаемогоОборудования() Экспорт

	Настройки = Новый Структура();
	
	Если НЕ ПравоДоступа("СохранениеДанныхПользователя", Метаданные) Тогда
		Возврат Настройки;
	КонецЕсли;
	
	СписокНастроек = ХранилищеОбщихНастроек.ПолучитьСписок("ПользовательскиеНастройкиПодключаемогоОборудования");
	Для Каждого Элемент из СписокНастроек Цикл
		КлючНастройки = Элемент.Значение;
		ЗначениеНастройки = ХранилищеОбщихНастроек.Загрузить("ПользовательскиеНастройкиПодключаемогоОборудования", КлючНастройки);
		Если ЗначениеНастройки <> Неопределено Тогда
			Настройки.Вставить(КлючНастройки, ЗначениеНастройки);
		КонецЕсли;
	КонецЦикла;
	
	Возврат Настройки;

КонецФункции

// Сохраняет пользовательские настройки подключаемого оборудования
//
Процедура СохранитьПользовательскиеНастройкиПодключаемогоОборудования(СписокНастроек) Экспорт
		
	Если НЕ ПравоДоступа("СохранениеДанныхПользователя", Метаданные) Тогда
		Возврат;
	КонецЕсли;

	Для Каждого Элемент Из СписокНастроек Цикл
		ХранилищеОбщихНастроек.Сохранить("ПользовательскиеНастройкиПодключаемогоОборудования", Элемент.Ключ, Элемент.Значение);
	КонецЦикла;
		
	ОбновитьПовторноИспользуемыеЗначения();

КонецПроцедуры

// Производит разложение данных дорожек магнитной карты по шаблонам
// На входе:
// ДанныеДорожек - массив строк. Значения полученные из дорожек.
// ПараметрыДорожек - массив структур содержащих параметры настройки устройства
//  * Использовать, булево - признак использования дорожки
//  * НомерДорожки, число - порядковый номер дорожки 1-3
//
// На выходе:
// Массив структур содержащих расшифрованные данные по всем подходящим шаблонам со ссылкой на них
// * Массив - шаблоны
//   * Структура - данные шаблона
//     - Шаблон, СправочникСсылка.ШаблоныМагнитныхКарт
//     - ДанныеДорожек, массив полей всех дорожек
//       * Структура - данные поля
//         - Поле
//         - ЗначениеПоля
Функция РасшифроватьКодМагнитнойКарты(ДанныеДорожек, ПараметрыДорожек) Экспорт
	
	Если ДанныеДорожек.Количество() = 0
		ИЛИ ПараметрыДорожек.Количество() = 0 Тогда
		Возврат Неопределено; // нет данных
	КонецЕсли;
	
	ДанныеОтбор = Новый Массив;
	СчётчикДорожек = 0;
	Для каждого текПараметр Из ПараметрыДорожек Цикл
		Если текПараметр.Использовать Тогда
			Попытка
				ДанныеОтбор.Добавить(Новый Структура("НомерДорожки, ДлинаДорожки, ДанныеДорожки"
													, текПараметр.НомерДорожки, СтрДлина(ДанныеДорожек[СчётчикДорожек]), ДанныеДорожек[СчётчикДорожек]));
			Исключение
				Возврат Неопределено; // неверный формат шаблона
			КонецПопытки;										
		КонецЕсли;
		СчётчикДорожек = СчётчикДорожек + 1;
	КонецЦикла;
	
	// 1-ый этап. Ищем шаблоны совпадающие по длине кода
	// а) При сравнении играют роль только доступные дорожки
	// б) Необходимо чтобы хотя бы одна дорожка была доступной
	Запрос = Новый Запрос(
	"ВЫБРАТЬ
	|	ШаблоныМагнитныхКарт.Ссылка,
	|	ШаблоныМагнитныхКарт.ДоступностьДорожки1,
	|	ШаблоныМагнитныхКарт.Префикс1,
	|	ШаблоныМагнитныхКарт.Суффикс1,
	|	ШаблоныМагнитныхКарт.ДлинаКода1,
	|	ШаблоныМагнитныхКарт.РазделительБлоков1,
	|	ШаблоныМагнитныхКарт.ДоступностьДорожки2,
	|	ШаблоныМагнитныхКарт.Префикс2,
	|	ШаблоныМагнитныхКарт.Суффикс2,
	|	ШаблоныМагнитныхКарт.ДлинаКода2,
	|	ШаблоныМагнитныхКарт.РазделительБлоков2,
	|	ШаблоныМагнитныхКарт.ДоступностьДорожки3,
	|	ШаблоныМагнитныхКарт.Префикс3,
	|	ШаблоныМагнитныхКарт.Суффикс3,
	|	ШаблоныМагнитныхКарт.ДлинаКода3,
	|	ШаблоныМагнитныхКарт.РазделительБлоков3
	|ИЗ
	|	Справочник.ШаблоныМагнитныхКарт КАК ШаблоныМагнитныхКарт
	|ГДЕ
	|	(ШаблоныМагнитныхКарт.ДоступностьДорожки1
	|			ИЛИ ШаблоныМагнитныхКарт.ДоступностьДорожки2
	|			ИЛИ ШаблоныМагнитныхКарт.ДоступностьДорожки3)
	|	И ВЫБОР
	|			КОГДА ШаблоныМагнитныхКарт.ДоступностьДорожки1
	|				ТОГДА ШаблоныМагнитныхКарт.ДлинаКода1 = &ДлинаКода1
	|			ИНАЧЕ ИСТИНА
	|		КОНЕЦ
	|	И ВЫБОР
	|			КОГДА ШаблоныМагнитныхКарт.ДоступностьДорожки2
	|				ТОГДА ШаблоныМагнитныхКарт.ДлинаКода2 = &ДлинаКода2
	|			ИНАЧЕ ИСТИНА
	|		КОНЕЦ
	|	И ВЫБОР
	|			КОГДА ШаблоныМагнитныхКарт.ДоступностьДорожки3
	|				ТОГДА ШаблоныМагнитныхКарт.ДлинаКода3 = &ДлинаКода3
	|			ИНАЧЕ ИСТИНА
	|		КОНЕЦ");
	Запрос.УстановитьПараметр("ДлинаКода1", СтрДлина(ДанныеДорожек[0]));
	Запрос.УстановитьПараметр("ДлинаКода2", СтрДлина(ДанныеДорожек[1]));
	Запрос.УстановитьПараметр("ДлинаКода3", СтрДлина(ДанныеДорожек[2]));
	Выборка = Запрос.Выполнить().Выбрать();
	
	СписокШаблонов = Новый Массив;
	Пока Выборка.Следующий() Цикл
		
		// 2-ой этап - Пропускаем шаблоны не совпадающие по суффиксу, префиксу, разделителю.
		
		Если НЕ КодСоответствуетШаблонуМК(ДанныеДорожек, Выборка) Тогда
			Продолжить;
		КонецЕсли;
		
		ДанныеДорожки = Новый Массив;
		Для каждого текОтбор Из ДанныеОтбор Цикл
			Для каждого текПоле Из Выборка.Ссылка["ПоляДорожки"+Строка(текОтбор.НомерДорожки)] Цикл
				
				// Поиск блока по номеру
				ДанныеСтрока = текОтбор.ДанныеДорожки;
				Префикс = Выборка["Префикс"+Строка(текОтбор.НомерДорожки)];
				Если Префикс = Лев(ДанныеСтрока, СтрДлина(Префикс)) Тогда
					ДанныеСтрока = Прав(ДанныеСтрока, СтрДлина(ДанныеСтрока)-СтрДлина(Префикс)); // Удаляем префикс если есть
				КонецЕсли;
				Суффикс = Выборка["Суффикс"+Строка(текОтбор.НомерДорожки)];
				Если Суффикс = Прав(ДанныеСтрока, СтрДлина(Суффикс)) Тогда
					ДанныеСтрока = Лев(ДанныеСтрока, СтрДлина(ДанныеСтрока)-СтрДлина(Суффикс)); // Удаляем суффикс если есть
				КонецЕсли;
				
				текНомерБлока = 0;
				Пока текНомерБлока < текПоле.НомерБлока Цикл
					ПозицияРазделителя = Найти(ДанныеСтрока, Выборка["РазделительБлоков"+Строка(текОтбор.НомерДорожки)]);
					Если ПозицияРазделителя = 0 Тогда
						Блок = ДанныеСтрока;
					ИначеЕсли ПозицияРазделителя = 1 Тогда
						Блок = "";
						ДанныеСтрока = Прав(ДанныеСтрока, СтрДлина(ДанныеСтрока)-1);
					Иначе
						Блок = Лев(ДанныеСтрока, ПозицияРазделителя-1);
						ДанныеСтрока = Прав(ДанныеСтрока, СтрДлина(ДанныеСтрока)-ПозицияРазделителя);
					КонецЕсли;
					текНомерБлока = текНомерБлока + 1;
				КонецЦикла;
				
				// Поиск подстроки в блоке
				ЗначениеПоля = Сред(Блок, текПоле.НомерПервогоСимволаПоля, ?(текПоле.ДлинаПоля = 0, СтрДлина(Блок), текПоле.ДлинаПоля));
				
				ДанныеПоля = Новый Структура("Поле, ЗначениеПоля", текПоле.Поле, ЗначениеПоля);
				ДанныеДорожки.Добавить(ДанныеПоля);
			КонецЦикла;
		КонецЦикла;
		Шаблон = Новый Структура("Шаблон, ДанныеДорожек", Выборка.Ссылка, ДанныеДорожки);
		СписокШаблонов.Добавить(Шаблон);
	КонецЦикла;
	
	Если СписокШаблонов.Количество() = 0 Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	Возврат СписокШаблонов;
	
КонецФункции

// Определяет соответствует ли код карты шаблону
// На входе:
// ДанныеДорожек - Массив содержащий строки кода дорожки. Всего 3 Элемента.
// ДанныеШаблона - структура содержащая данные шаблона:
//	- Суффикс
//	- Префикс
//	- РазделительБлоков
//	- ДлинаКода
// На выходе:
// Истина - код соответствует шаблону
Функция КодСоответствуетШаблонуМК(ДанныеДорожек, ДанныеШаблона)
	Для й = 1 По 3 Цикл
		Если ДанныеШаблона["ДоступностьДорожки"+Строка(й)] Тогда
			текСтрока = ДанныеДорожек[й-1];
			Если Прав(текСтрока, СтрДлина(ДанныеШаблона["Суффикс"+Строка(й)])) <> ДанныеШаблона["Суффикс"+Строка(й)]
				ИЛИ Лев(текСтрока, СтрДлина(ДанныеШаблона["Префикс"+Строка(й)])) <> ДанныеШаблона["Префикс"+Строка(й)]
				ИЛИ Найти(текСтрока, ДанныеШаблона["РазделительБлоков"+Строка(й)]) = 0
				ИЛИ СтрДлина(текСтрока) <> ДанныеШаблона["ДлинаКода"+Строка(й)] Тогда
				Возврат Ложь;
			КонецЕсли;
		КонецЕсли;
	КонецЦикла;
	Возврат Истина;
КонецФункции

// Возвращает список оборудования для которого необходима переустановка компоненты
//
Функция ПолучитьСписокОборудованияДляПереустановки() Экспорт
	
	УстановитьПривилегированныйРежим(Истина);
	Список = Новый Массив;
	
	Запрос = Новый Запрос(
	"ВЫБРАТЬ
	|	ПодключаемоеОборудование.ИдентификаторУстройства,
	|	ПодключаемоеОборудование.ОбработчикДрайвера,
	|	ПодключаемоеОборудование.Ссылка
	|ИЗ
	|	Справочник.ПодключаемоеОборудование КАК ПодключаемоеОборудование
	|ГДЕ
	|	ПодключаемоеОборудование.ТребуетсяПереустановка");
	Выборка = Запрос.Выполнить().Выбрать();
	Пока Выборка.Следующий() Цикл
		Строка = Новый Структура("Ссылка, ИдентификаторУстройства, ОбработчикДрайвера",
			Выборка.Ссылка, Выборка.ИдентификаторУстройства, Выборка.ОбработчикДрайвера);
		Список.Добавить(Строка);
	КонецЦикла;
	
	Возврат Список;
КонецФункции

// Устанавливает признак необходимости переустановки оборудования
//
Процедура УстановитьПризнакПереустановки(ПодключаемоеОборудованиеСсылка, Признак) Экспорт
	УстановитьПривилегированныйРежим(Истина);
	
	СправочникОбъект = ПодключаемоеОборудованиеСсылка.ПолучитьОбъект();
	СправочникОбъект.ТребуетсяПереустановка = Признак;
	СправочникОбъект.Записать();
КонецПроцедуры

// Возвращает реквизит ОбработчикДрайвера по ссылке справочника ПодключаемоеОборудование
//
Функция ПолучитьОбработчикДрайвераИзСсылки(ПодключаемоеОборудованиеСсылка) Экспорт
	Возврат ПодключаемоеОборудованиеСсылка.ОбработчикДрайвера
КонецФункции

// Возвращает реквизит ТребуетсяПереустановка по ссылке справочника ПодключаемоеОборудование
//
Функция ПолучитьПризнакПереустановкиИзСсылки(ПодключаемоеОборудованиеСсылка) Экспорт
	Возврат ПодключаемоеОборудованиеСсылка.ТребуетсяПереустановка
КонецФункции