////////////////////////////////////////////////////////////////////////////////
// Клиентские и серверные процедуры общего назначения

// Формирует и выводит сообщение, которое может быть связано с элементом 
// управления формы.
//
//  Параметры
//  ТекстСообщенияПользователю - Строка - текст сообщения.
//  КлючДанных                - Любая ссылка на объект информационной базы.
//                               Ссылка на объект информационной базы, к которому это сообщение относится,
//                               или ключ записи.
//  Поле                       - Строка - наименование реквизита формы
//  ПутьКДанным                - Строка - путь к данным (путь к реквизиту формы)
//  Отказ                      - Булево - Выходной параметр
//                               Всегда устанавливается в значение Истина
//
//	Примеры использования:
//
//	1. Для вывода сообщения у поля управляемой формы, связанного с реквизитом объекта:
//	ОбщегоНазначенияКлиентСервер.СообщитьПользователю(
//		НСтр("ru = 'Сообщение об ошибке.'"), ,
//		"ПолеВРеквизитеФормыОбъект",
//		"Объект");
//
//	Альтернативный вариант использования в форме объекта:
//	ОбщегоНазначенияКлиентСервер.СообщитьПользователю(
//		НСтр("ru = 'Сообщение об ошибке.'"), ,
//		"Объект.ПолеВРеквизитеФормыОбъект");
//
//	2. Для вывода сообщения рядом с полем управляемой формы, связанным с реквизитом формы:
//	ОбщегоНазначенияКлиентСервер.СообщитьПользователю(
//		НСтр("ru = 'Сообщение об ошибке.'"), ,
//		"ИмяРеквизитаФормы");
//
//	3. Для вывода сообщения связанного с объектом информационной базы
//	ОбщегоНазначенияКлиентСервер.СообщитьПользователю(
//		НСтр("ru = 'Сообщение об ошибке.'"), ОбъектИнформационнойБазы, "Ответственный",,Отказ);
//
// 4. Для вывода сообщения по ссылке на объект информационной базы
//	ОбщегоНазначенияКлиентСервер.СообщитьПользователю(
//		НСтр("ru = 'Сообщение об ошибке.'"), Ссылка, , , Отказ);
//
// Случаи некорректного использования:
//  1. Передача одновременно параметров КлючДанных и ПутьКДанным
//  2. Передача в параметре КлючДанных значения типа отличного от допустимых
//  3. Установка ссылки без установки поля (и/или пути к данным)
//
Процедура СообщитьПользователю(
		Знач ТекстСообщенияПользователю,
		Знач КлючДанных = Неопределено,
		Знач Поле = "",
		Знач ПутьКДанным = "",
		Отказ = Ложь) Экспорт
	
	Сообщение = Новый СообщениеПользователю;
	Сообщение.Текст = ТекстСообщенияПользователю;
	Сообщение.Поле = Поле;
	
	ЭтоОбъект = Ложь;
	
#Если НЕ (ТонкийКлиент ИЛИ ВебКлиент) Тогда
	Если КлючДанных <> Неопределено
	   И XMLТипЗнч(КлючДанных) <> Неопределено Тогда
		ТипЗначенияСтрокой = XMLТипЗнч(КлючДанных).ИмяТипа;
		ЭтоОбъект = Найти(ТипЗначенияСтрокой, "Object.") > 0;
	КонецЕсли;
#КонецЕсли
	
	Если ЭтоОбъект Тогда
		Сообщение.УстановитьДанные(КлючДанных);
	Иначе
		Сообщение.КлючДанных = КлючДанных;
	КонецЕсли;
	
	Если НЕ ПустаяСтрока(ПутьКДанным) Тогда
		Сообщение.ПутьКДанным = ПутьКДанным;
	КонецЕсли;
		
	Сообщение.Сообщить();
	
	Отказ = Истина;
	
КонецПроцедуры

// Формирует текст сообщения, подставляя значения
// параметров в шаблоны сообщений.
//
// Параметры
//  ВидПоля       - Строка - может принимать значения:
//                  Поле, Колонка, Список
//  ВидСообщения  - Строка - может принимать значения:
//                  Заполнение, Корректность
//  Параметр1     - Строка - имя поля
//  Параметр2     - Строка - номер строки
//  Параметр3     - Строка - имя списка
//  Параметр4     - Строка - текст сообщения о некорректности заполнения
//
// Возвращаемое значение:
//   Строка - текст сообщения
//
Функция ПолучитьТекстСообщения(ВидПоля = "Поле", ВидСообщения = "Заполнение",
	Параметр1 = "", Параметр2 = "",	Параметр3 = "", Параметр4 = "") Экспорт

	ТекстСообщения = "";

	Если ВРег(ВидПоля) = "ПОЛЕ" Тогда
		Если ВРег(ВидСообщения) = "ЗАПОЛНЕНИЕ" Тогда
			Шаблон = НСтр("ru = 'Поле ""%1"" не заполнено'");
		ИначеЕсли ВРег(ВидСообщения) = "КОРРЕКТНОСТЬ" Тогда
			Шаблон = НСтр("ru = 'Поле ""%1"" заполнено некорректно.
                           |
                           |%4'");
		КонецЕсли;
	ИначеЕсли ВРег(ВидПоля) = "КОЛОНКА" Тогда
		Если ВРег(ВидСообщения) = "ЗАПОЛНЕНИЕ" Тогда
			Шаблон = НСтр("ru = 'Не заполнена колонка ""%1"" в строке %2 списка ""%3""'");
		ИначеЕсли ВРег(ВидСообщения) = "КОРРЕКТНОСТЬ" Тогда
			Шаблон = НСтр("ru = 'Некорректно заполнена колонка ""%1"" в строке %2 списка ""%3"".
                           |
                           |%4'");
		КонецЕсли;
	ИначеЕсли ВРег(ВидПоля) = "СПИСОК" Тогда
		Если ВРег(ВидСообщения) = "ЗАПОЛНЕНИЕ" Тогда
			Шаблон = НСтр("ru = 'Не введено ни одной строки в список ""%3""'");
		ИначеЕсли ВРег(ВидСообщения) = "КОРРЕКТНОСТЬ" Тогда
			Шаблон = НСтр("ru = 'Некорректно заполнен список ""%3"".
                           |
                           |%4'");
		КонецЕсли;
	КонецЕсли;

	Возврат СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(Шаблон, Параметр1, Параметр2, Параметр3, Параметр4);

КонецФункции

// Формирует путь к заданной строке НомерСтроки и колонке ИмяРеквизита 
// табличной части ИмяТабличнойЧасти для выдачи сообщений в форме.
// Для совместного использования с процедурой СообщитьПользователю
// (для передачи в параметры Поле или ПутьКДанным). 
//
// Параметры:
//  ИмяТабличнойЧасти - Строка - имя табличной части.
//  НомерСтроки       - Число - номер строки табличной части.
//  ИмяРеквизита      - Строка - имя реквизита.
//
// Возвращаемое значение:
//  Строка.
//
Функция ПутьКТабличнойЧасти(Знач ИмяТабличнойЧасти, Знач НомерСтроки, 
	Знач ИмяРеквизита) Экспорт

	Возврат ИмяТабличнойЧасти + "[" + Формат(НомерСтроки - 1, "ЧН=0; ЧГ=0") + "]." + ИмяРеквизита;

КонецФункции

// Дополняет таблицу значений-приемник данными из таблицы значений-источник
//
// Параметры:
//  ТаблицаИсточник - Таблица значений - таблица из которой будут браться строки для заполнения
//  ТаблицаПриемник - Таблица значений - таблица в которую будут добавлены строки из таблицы-источника
//  
Процедура ДополнитьТаблицу(ТаблицаИсточник, ТаблицаПриемник) Экспорт
	
	Для каждого СтрокаТаблицыИсточник Из ТаблицаИсточник Цикл
		
		ЗаполнитьЗначенияСвойств(ТаблицаПриемник.Добавить(), СтрокаТаблицыИсточник);
		
	КонецЦикла;
	
КонецПроцедуры

// Дополняет таблицу значений Таблица значениями из массива Массив.
//
// Параметры:
//  Таблица - ТаблицаЗначений - таблица, которую необходимо заполнить значениями из массива
//  Массив - Массив - массив значений для заполнения таблицы
//  ИмяПоля - Строка - имя поля таблицы значений, в которое необходимо загрузить значения из массива
// 
Процедура ДополнитьТаблицуИзМассива(Таблица, Массив, ИмяПоля) Экспорт

	Для каждого Значение Из Массив Цикл
		
		Таблица.Добавить()[ИмяПоля] = Значение;
		
	КонецЦикла;
	
КонецПроцедуры

// Снимает один элемент условного оформления, если это список значений.
// Параметры
// УсловноеОформление - условное оформление элемента формы
// ИдентификаторПользовательскойНастройки - строка - идентификатор настройки
// Значение - значение, которое требуется удалить из списка оформления
//
Процедура СнятьУсловноеОформлениеСпискаЗначений(
						УсловноеОформление,
						знач ИдентификаторПользовательскойНастройки,
						знач Значение) Экспорт
	
	Для каждого ЭлементУО Из УсловноеОформление.Элементы Цикл
		Если ЭлементУО.ИдентификаторПользовательскойНастройки = ИдентификаторПользовательскойНастройки Тогда
			Если ЭлементУО.Отбор.Элементы.Количество() = 0 Тогда
				Возврат;
			КонецЕсли;
			ЭлементСписокОтбора = ЭлементУО.Отбор.Элементы[0];
			Если ЭлементСписокОтбора.ПравоеЗначение = Неопределено Тогда
				Возврат;
			КонецЕсли;
			ЭлементСписка = ЭлементСписокОтбора.ПравоеЗначение.НайтиПоЗначению(Значение);
			Если ЭлементСписка <> Неопределено Тогда
				ЭлементСписокОтбора.ПравоеЗначение.Удалить(ЭлементСписка);
			КонецЕсли;
			ЭлементСписокОтбора.ПравоеЗначение = ЭлементСписокОтбора.ПравоеЗначение;
			Возврат;
		КонецЕсли;
	КонецЦикла;
	
КонецПроцедуры

// Удаляет одно значение из массива
//
// Параметры:
//  Массив - массив, из которого необходимо удалить значение
//  Значение - удаляемое значение из массива
// 
Процедура УдалитьЗначениеИзМассива(Массив, Значение) Экспорт
	
	Индекс = Массив.Найти(Значение);
	
	Если Индекс <> Неопределено Тогда
		
		Массив.Удалить(Индекс);
		
	КонецЕсли;
	
КонецПроцедуры

// Удаляет все вхождения переданного значения из массива
//
// Параметры:
//  Массив - массив, из которого необходимо удалить значение
//  Значение - удаляемое значение из массива
// 
Процедура УдалитьВсеВхожденияЗначенияИзМассива(Массив, Значение) Экспорт
	
	КолвоЭлементовКоллекции = Массив.Количество();
	
	Для ОбратныйИндекс = 1 По КолвоЭлементовКоллекции Цикл
		
		Индекс = КолвоЭлементовКоллекции - ОбратныйИндекс;
		
		Если Массив[Индекс] = Значение Тогда
			
			Массив.Удалить(Индекс);
			
		КонецЕсли;
		
	КонецЦикла;
	
КонецПроцедуры

// Удаляет все вхождения значений указанного типа
//
// Параметры:
//  Массив - массив, из которого необходимо удалить значения
//  Тип – тип, значения которых следует удалить из коллекции
// 
Процедура УдалитьВсеВхожденияТипаИзМассива(Массив, Тип) Экспорт
	
	КолвоЭлементовКоллекции = Массив.Количество();
	
	Для ОбратныйИндекс = 1 По КолвоЭлементовКоллекции Цикл
		
		Индекс = КолвоЭлементовКоллекции - ОбратныйИндекс;
		
		Если ТипЗнч(Массив[Индекс]) = Тип Тогда
			
			Массив.Удалить(Индекс);
			
		КонецЕсли;
		
	КонецЦикла;
	
КонецПроцедуры

// Заполняет коллекцию-приемник значениями из коллекции-источник
// В качестве коллекций источника и приемника могут выступать типы:
// ТаблицаЗначений; ДеревоЗначений; СписокЗначений и пр.
//
// Параметры:
//  КоллекцияИсточник - коллекция значений, которая является источником для заполнения данных
//  КоллекцияПриемник - коллекция значений, которая является приемником для заполнения данных
// 
Процедура ЗаполнитьКоллекциюСвойств(КоллекцияИсточник, КоллекцияПриемник) Экспорт
	
	Для Каждого Элемент ИЗ КоллекцияИсточник Цикл
		
		ЗаполнитьЗначенияСвойств(КоллекцияПриемник.Добавить(), Элемент);
		
	КонецЦикла;
	
КонецПроцедуры

// Получает массив значений из отмеченных элементов списка значений
//
// Параметры:
//  Список - СписокЗначений - список значений из которого будет формироваться массив значений
// 
// Возвращаемое значение:
//  Массив - массив значений из отмеченных элементов списка значений
//
Функция ПолучитьМассивОтмеченныхЭлементовСписка(Список) Экспорт
	
	// возвращаемое значение функции
	Массив = Новый Массив;
	
	Для Каждого Элемент ИЗ Список Цикл
		
		Если Элемент.Пометка Тогда
			
			Массив.Добавить(Элемент.Значение);
			
		КонецЕсли;
		
	КонецЦикла;
	
	Возврат Массив;
КонецФункции

// Вычитает один массив элементов из другого массива. Возвращает результат вычитания.
//
// Параметры:
//  Массив - массив элементов, из которого необходимо выполнить вычитание
//  МассивВычитания - массив элементов, который будет вычитаться
// 
//  Возвращаемое значение:
//  Массив – результат вычитания двух массивов
//
Функция СократитьМассив(Массив, МассивВычитания) Экспорт
	
	Результат = Новый Массив;
	
	Для Каждого Элемент Из Массив Цикл
		
		Если МассивВычитания.Найти(Элемент) = Неопределено Тогда
			
			Результат.Добавить(Элемент);
			
		КонецЕсли;
		
	КонецЦикла;
	
	Возврат Результат;
	
КонецФункции

// Преобразует РасписаниеРегламентногоЗадания в структуру.
//
// Параметры:
//  Расписание - РасписаниеРегламентногоЗадания
// 
// Возвращаемое значение:
//  Структура
//
Функция РасписаниеВСтруктуру(Знач Расписание) Экспорт
	
	ЗначениеРасписания = Расписание;
	Если ЗначениеРасписания = Неопределено Тогда
		ЗначениеРасписания = Новый РасписаниеРегламентногоЗадания();
	КонецЕсли;
	СписокПолей = "ВремяЗавершения,ВремяКонца,ВремяНачала,ДатаКонца,ДатаНачала,ДеньВМесяце,ДеньНеделиВМесяце," + 
		"ДниНедели,ИнтервалЗавершения,Месяцы,ПаузаПовтора,ПериодНедель,ПериодПовтораВТечениеДня,ПериодПовтораДней";
	Результат = Новый Структура(СписокПолей);
	ЗаполнитьЗначенияСвойств(Результат, ЗначениеРасписания, СписокПолей);
	ДетальныеРасписанияДня = Новый Массив;
	Для каждого РасписаниеДля Из Расписание.ДетальныеРасписанияДня Цикл
		ДетальныеРасписанияДня.Добавить(РасписаниеВСтруктуру(РасписаниеДля));
	КонецЦикла;
	Результат.Вставить("ДетальныеРасписанияДня", ДетальныеРасписанияДня);
	Возврат Результат;
	
КонецФункции		

// Преобразует структуру в РасписаниеРегламентногоЗадания.
//
// Параметры:
//  СтруктураРасписания - Структура
// 
// Возвращаемое значение:
//  РасписаниеРегламентногоЗадания
//
Функция СтруктураВРасписание(Знач СтруктураРасписания) Экспорт
	
	Если СтруктураРасписания = Неопределено Тогда
		Возврат Новый РасписаниеРегламентногоЗадания();
	КонецЕсли;
	СписокПолей = "ВремяЗавершения,ВремяКонца,ВремяНачала,ДатаКонца,ДатаНачала,ДеньВМесяце,ДеньНеделиВМесяце," + 
		"ДниНедели,ИнтервалЗавершения,Месяцы,ПаузаПовтора,ПериодНедель,ПериодПовтораВТечениеДня,ПериодПовтораДней";
	Результат = Новый РасписаниеРегламентногоЗадания;
	ЗаполнитьЗначенияСвойств(Результат, СтруктураРасписания, СписокПолей);
	ДетальныеРасписанияДня = Новый Массив;
	Для каждого Расписание Из СтруктураРасписания.ДетальныеРасписанияДня Цикл
		  ДетальныеРасписанияДня.Добавить(СтруктураВРасписание(Расписание));
	КонецЦикла;
	Результат.ДетальныеРасписанияДня = ДетальныеРасписанияДня;  
	Возврат Результат;
	
КонецФункции		

// Создает новый экземпляр объекта Структура, заполняет объект данными указанной структуры.
//
// Параметры:
//  СтруктураИсточник – Структура – структура, копию которой необходимо получить
// 
//  Возвращаемое значение:
//  Тип: Структура.
//
Функция СкопироватьСтруктуру(СтруктураИсточник) Экспорт
	
	СтруктураРезультат = Новый Структура;
	
	Для Каждого Элемент ИЗ СтруктураИсточник Цикл
		
		Если ТипЗнч(Элемент.Значение) = Тип("СписокЗначений") Тогда
			СтруктураРезультат.Вставить(Элемент.Ключ, Элемент.Значение.Скопировать());
		Иначе
			СтруктураРезультат.Вставить(Элемент.Ключ, Элемент.Значение);
		КонецЕсли;
		
	КонецЦикла;
	
	Возврат СтруктураРезультат;
	
КонецФункции

// Функция выполняет поиск элемента в коллекции: списке значений или массиве
//
Функция НайтиВСписке(Список, Элемент)
	
	Перем ЭлементВСписке;
	
	Если ТипЗнч(Список) = Тип("СписокЗначений") Тогда
		Если ТипЗнч(Элемент) = Тип("ЭлементСпискаЗначений") Тогда
			ЭлементВСписке = Список.НайтиПоЗначению(Элемент.Значение);
		Иначе
			ЭлементВСписке = Список.НайтиПоЗначению(Элемент);
		КонецЕсли;
	КонецЕсли;
	
	Если ТипЗнч(Список) = Тип("Массив") Тогда
		ЭлементВСписке = Список.Найти(Элемент);
	КонецЕсли;
	
	Возврат ЭлементВСписке;
	
КонецФункции // ЭлементПрисутствуетВСписке

// Сравнивает элементы списков значений или массивов по значениям
//
Функция СпискиЗначенийИдентичны(Список1, Список2) Экспорт
	
	СпискиИдентичны = Истина;
	
	Для Каждого ЭлементСписка1 Из Список1 Цикл
		Если НайтиВСписке(Список2, ЭлементСписка1) = Неопределено Тогда
			СпискиИдентичны = Ложь;
			Прервать;
		КонецЕсли;
	КонецЦикла;
	
	Если СпискиИдентичны Тогда
		Для Каждого ЭлементСписка2 Из Список2 Цикл
			Если НайтиВСписке(Список1, ЭлементСписка2) = Неопределено Тогда
				СпискиИдентичны = Ложь;
				Прервать;
			КонецЕсли;
		КонецЦикла;
	КонецЕсли;
	
	Возврат СпискиИдентичны;
	
КонецФункции // СпискиЗначенийИдентичны

// Возвращает шаблон структуры параметров для установки внешнего соединения.
// Параметрам необходимо задать требуемые значения и передать
// в метод ОбщегоНазначения.УстановитьВнешнееСоединение()
//
Функция СтруктураПараметровДляУстановкиВнешнегоСоединения() Экспорт
	
	СтруктураПараметров = Новый Структура;
	СтруктураПараметров.Вставить("ВариантРаботыИнформационнойБазы", 0);
	СтруктураПараметров.Вставить("КаталогИнформационнойБазы", "");
	СтруктураПараметров.Вставить("ИмяСервера1СПредприятия", "");
	СтруктураПараметров.Вставить("ИмяИнформационнойБазыНаСервере1СПредприятия", "");
	СтруктураПараметров.Вставить("АутентификацияОперационнойСистемы", Ложь);
	СтруктураПараметров.Вставить("ИмяПользователя", "");
	СтруктураПараметров.Вставить("ПарольПользователя", "");
	
	Возврат СтруктураПараметров;
КонецФункции

// Извлекает из строки соединения с информационной базой параметры подключения
// и передает параметры в структуру для установки внешнего соединения.
//
Функция ПолучитьПараметрыПодключенияИзСтрокиСоединенияИнформационнойБазы(Знач СтрокаСоединения) Экспорт
	
	Результат = СтруктураПараметровДляУстановкиВнешнегоСоединения();
	
	Параметры = СтроковыеФункцииКлиентСервер.ПолучитьПараметрыИзСтроки(СтрокаСоединения);
	
	Параметры.Свойство("File", Результат.КаталогИнформационнойБазы);
	Параметры.Свойство("Srvr", Результат.ИмяСервера1СПредприятия);
	Параметры.Свойство("Ref",  Результат.ИмяИнформационнойБазыНаСервере1СПредприятия);
	
	Результат.ВариантРаботыИнформационнойБазы = ?(Параметры.Свойство("File"), 0, 1);
	
	Возврат Результат;
КонецФункции

// Получает идентификатор (метод ПолучитьИдентификатор()) строки дерева значений для заданного значения поля строки дерева.
// Используется для позиционирования курсора в иерархических списках.
// 
Процедура ПолучитьИдентификаторСтрокиДереваПоЗначениюПоля(ИмяПоля, ИдентификаторСтроки, КоллекцияЭлементовДерева, КлючСтроки, ПрекратитьПоиск) Экспорт
	
	Для Каждого СтрокаДерева ИЗ КоллекцияЭлементовДерева Цикл
		
		Если ПрекратитьПоиск Тогда
			Возврат;
		КонецЕсли;
		
		Если СтрокаДерева[ИмяПоля] = КлючСтроки Тогда
			
			ИдентификаторСтроки = СтрокаДерева.ПолучитьИдентификатор();
			
			ПрекратитьПоиск = Истина;
			
			Возврат;
			
		КонецЕсли;
		
		КоллекцияЭлементов = СтрокаДерева.ПолучитьЭлементы();
		
		Если КоллекцияЭлементов.Количество() > 0 Тогда
			
			ПолучитьИдентификаторСтрокиДереваПоЗначениюПоля(ИмяПоля, ИдентификаторСтроки, КоллекцияЭлементов, КлючСтроки, ПрекратитьПоиск);
			
		КонецЕсли;
		
	КонецЦикла;
	
КонецПроцедуры

// Заменяет недопустимые символы в XML-строке на заданные символы
//
// Параметры:
//   Текст – Строка – строка, в которой требуется выполнить замену недопустимых символов.
//   СимволЗамены – Строка – строка, на которую требуется выполнить замену недопустимого символа в XML-строке
// 
//  Возвращаемое значение:
//    Строка - cтрока, полученная заменой недопустимых символов в XML-строке.
//
Функция ЗаменитьНедопустимыеСимволыXML(Знач Текст, СимволЗамены = " ") Экспорт
	
#Если НЕ ВебКлиент Тогда
	ПозицияНачала = 1;
	Пока Истина Цикл
		Позиция = НайтиНедопустимыеСимволыXML(Текст, ПозицияНачала);
		Если Позиция = 0 Тогда
			Прервать;
		КонецЕсли;
		// Если возращается позиция, больше чем должна быть, то корректируем ее.
		Если Позиция > 1 Тогда
			НедопустимыйСимвол = Сред(Текст, Позиция - 1, 1);
			Если НайтиНедопустимыеСимволыXML(НедопустимыйСимвол) > 0 Тогда
				Текст = СтрЗаменить(Текст, НедопустимыйСимвол, СимволЗамены);
			КонецЕсли;
		КонецЕсли;
		НедопустимыйСимвол = Сред(Текст, Позиция, 1);
		Если НайтиНедопустимыеСимволыXML(НедопустимыйСимвол) > 0 Тогда
			Текст = СтрЗаменить(Текст, НедопустимыйСимвол, СимволЗамены);
		КонецЕсли;
		ПозицияНачала = Позиция + 1;
	КонецЦикла;
#КонецЕсли

	Возврат Текст;
КонецФункции

// Удаляет недопустимые символы в XML-строке.
//
// Параметры:
//  Текст – Строка – строка, в которой требуется удалить недопустимые символы.
// 
//  Возвращаемое значение:
//  Тип: Строка. Строка, полученная при удалении недопустимых символов в XML-строке.
//
Функция УдалитьНедопустимыеСимволыXML(Знач Текст) Экспорт
	
	Возврат ЗаменитьНедопустимыеСимволыXML(Текст, "");
	
КонецФункции

// Сравнивает расписания между собой.
//
// Параметры
//	Расписание1, Расписание2 - РасписаниеРегламентногоЗадания
//
// Возвращаемое значение
//  Булево - истина, если расписания идентичны, иначе ложь.
Функция РасписанияОдинаковые(Знач Расписание1, Знач Расписание2) Экспорт
	Расписание1 = РасписаниеВСтруктуру(Расписание1);
	Расписание2 = РасписаниеВСтруктуру(Расписание2);
	
	Для Каждого РеквизитРасписания Из Расписание1 Цикл
		Если ТипЗнч(РеквизитРасписания.Значение) <> Тип("Массив") Тогда
			Если РеквизитРасписания.Значение <> Расписание2[РеквизитРасписания.Ключ] Тогда
				Возврат Ложь;
			КонецЕсли;
		Иначе
			Если РеквизитРасписания.Значение.Количество() <> Расписание2[РеквизитРасписания.Ключ].Количество() Тогда
				Возврат Ложь;
			КонецЕсли;
			
			Для НомерЭлемента = 0 По РеквизитРасписания.Значение.Количество()-1 Цикл
				Если РеквизитРасписания.Ключ = "ДетальныеРасписанияДня" Тогда
					Если Не РасписанияОдинаковые(РеквизитРасписания.Значение[НомерЭлемента],Расписание2[РеквизитРасписания.Ключ][НомерЭлемента]) Тогда
						Возврат Ложь;
					КонецЕсли;
				Иначе
					Если РеквизитРасписания.Значение[НомерЭлемента] <> Расписание2[РеквизитРасписания.Ключ][НомерЭлемента] Тогда
						Возврат Ложь;
					КонецЕсли;
				КонецЕсли;
			КонецЦикла;
		КонецЕсли;
	КонецЦикла;
	
	Возврат Истина;
КонецФункции

// Удаляет заданный литерал (префикс) в именах ключей переданной структуры.
// Создает новую структуру.
//
//  Параметры:
// Структура. Тип: Структура.
// Структура элементов, на основании которой необходимо создать новую структуру с ключами без заданного литерала.
//
// Литерал. Тип: Строка.
// Строка символов, которую необходимо исключить из имени ключей переданной структуры.
//
//  Возвращающее значение:
// Тип. Структура.
// Возвращаемая структура получается на основании копирования исходной структуры.
//
Функция УдалитьПрефиксВКлючахКоллекции(Структура, Литерал) Экспорт
	
	Результат = Новый Структура;
	
	Для Каждого Элемент Из Структура Цикл
		
		Результат.Вставить(СтрЗаменить(Элемент.Ключ, Литерал, ""), Элемент.Значение);
		
	КонецЦикла;
	
	Возврат Результат;
КонецФункции

////////////////////////////////////////////////////////////////////////////////
// Функции для поддержки формирования печатных форм
//

// Возвращает заголовок документа в том виде, в котором его формирует платформа для представления ссылки на документ.
//
// Параметры
//  Шапка - Структура с ключами
//          Номер - строка или число - номер документа
//          Дата  - дата - дата документа
//  НазваниеДокумента - Строка - название документа (например, синоним объекта метаданных)
//
// Возвращаемое значение 
//  Строка - заголовок документа
//
Функция СформироватьЗаголовокДокумента(Шапка, знач НазваниеДокумента = "") Экспорт
	
	// Если название документа не передано, получим название по представлению документа
	Если НазваниеДокумента = ""	И Шапка.Свойство("Представление") И ЗначениеЗаполнено(Шапка.Представление) Тогда
		ПоложениеНомера = Найти(Шапка.Представление, Шапка.Номер);
		Если ПоложениеНомера > 0 Тогда
			НазваниеДокумента = СокрЛП(Лев(Шапка.Представление, ПоложениеНомера - 1));
		КонецЕсли;
	КонецЕсли;

	НомерНаПечать = Шапка.Номер;
	СтандартнаяОбработка = Истина;
	СтандартныеПодсистемыКлиентСерверПереопределяемый.ПолучитьНомерНаПечать(НомерНаПечать, СтандартнаяОбработка);
	Если СтандартнаяОбработка Тогда
		НомерНаПечать = Шапка.Номер;
	КонецЕсли;
	
	Возврат СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
		НСтр("ru = '%1 № %2 от %3'"),
		НазваниеДокумента, НомерНаПечать, Формат(Шапка.Дата, "ДФ='дд ММММ гггг'"));
	
КонецФункции

////////////////////////////////////////////////////////////////////////////////
// Функции для работы с файловой системой
//

// Процедура УдалитьКаталогСФайлами удаляет все файлы в заданном каталоге.
//
// Параметры:
//  Путь         - Строка, полный путь каталога, в котором требуется
//                 удалить все файлы.
//
Процедура УдалитьКаталогСФайлами(Путь) Экспорт
	
	Каталог = Новый Файл(Путь);
	
	Если Каталог.Существует() Тогда
		УдалитьФайлы(Путь);
	КонецЕсли;
	
КонецПроцедуры // УдалитьКаталогСФайлами()

// Добавляет к переданному пути каталога конечный символ-разделитель, если он отсутствует.
// В случае, когда параметр "Платформа" не указан, разделитель выбирается, исходя из уже имеющихся
// разделителей в параметре "ПутьКаталога".
//
// Параметры:
//  ПутьКаталога - Строка - путь к каталогу;
//  Платформа - ТипПлатформы - тип платформы, в рамках которой осуществляется работа (влияет на выбор разделителя).
//
// Возвращаемое значение:
//  Строка   - путь к каталогу с конечным символом-разделителем.
//
// Примеры использования:
//  Результат = ДобавитьКонечныйРазделительПути("C:\Мой каталог"); // возвращает "C:\Мой каталог\"
//  Результат = ДобавитьКонечныйРазделительПути("C:\Мой каталог\"); // возвращает "C:\Мой каталог\"
//  Результат = ДобавитьКонечныйРазделительПути("ftp://Мой каталог"); // возвращает "ftp://Мой каталог/"
//	Результат = ДобавитьКонечныйРазделительПути("%APPDATA%", ТипПлатформы.Windows_x86_64); // возвращает "%APPDATA%\"
//
Функция ДобавитьКонечныйРазделительПути(Знач ПутьКаталога, Знач Платформа = Неопределено) Экспорт
	
	Если ПустаяСтрока(ПутьКаталога) Тогда
		Возврат ПутьКаталога;
	КонецЕсли;
	
	ДобавляемыйСимвол = "\";
	Если Платформа = Неопределено Тогда
		Если Найти(ПутьКаталога, "/") > 0 Тогда
			ДобавляемыйСимвол = "/";
		КонецЕсли;
	Иначе
		Если Платформа = ТипПлатформы.Linux_x86 Или Платформа = ТипПлатформы.Linux_x86_64 Тогда
			ДобавляемыйСимвол = "/";
		КонецЕсли;
	КонецЕсли;
	
	Если Прав(ПутьКаталога, 1) <> ДобавляемыйСимвол Тогда
		Возврат ПутьКаталога + ДобавляемыйСимвол;
	Иначе 
		Возврат ПутьКаталога;
	КонецЕсли;
	
КонецФункции

// Составляет полное имя файла из имени каталога и имени файла.
//
// Параметры
//  ИмяКаталога  – Строка, содержащая путь к каталогу файла на диске.
//  ИмяФайла     – Строка, содержащая имя файла, без имени каталога.
//
// Возвращаемое значение:
//   Строка – полное имя файла с учетом каталога.
//
Функция ПолучитьПолноеИмяФайла(Знач ИмяКаталога, Знач ИмяФайла) Экспорт

	Если НЕ ПустаяСтрока(ИмяФайла) Тогда
		
		Слэш = "";
		Если (Прав(ИмяКаталога, 1) <> "\") И (Прав(ИмяКаталога, 1) <> "/") Тогда
			Слэш = ?(Найти(ИмяКаталога, "\") = 0, "/", "\");
		КонецЕсли;
		
		Возврат ИмяКаталога + Слэш + ИмяФайла;
		
	Иначе
		
		Возврат ИмяКаталога;
		
	КонецЕсли;

КонецФункции

// Раскладывает полное имя файла на составляющие.
//
// Параметры
//  ПолноеИмяФайла – Строка, содержащая полный путь к файлу.
//  ЭтоПапка – Булево, признак того, что требуется разложить полное имя папки, а не файла.
//
// Возвращаемое значение:
//   Структура – имя файла, разложенное на составные части(аналогично свойствам объекта Файл):
//		ПолноеИмя - Содержит полный путь к файлу, т.е. полностью соответствует входному параметру ПолноеИмяФайла.
//		Путь - Содержит путь к каталогу, в котором лежит файл.
//		Имя - Содержит имя файла с расширением, без пути к файлу.
//		Расширение - Содержит расширение файла
//		ИмяБезРасширения - Содержит имя файла без расширения и без пути к файлу.
//			Пример: если ПолноеИмяФайла = "c:\temp\test.txt", то структура заполнится следующим образом:
//				ПолноеИмя: "c:\temp\test.txt"
//				Путь: "c:\temp\"
//				Имя: "test.txt"
//				Расширение: ".txt"
//				ИмяБезРасширения: "test"
//
Функция РазложитьПолноеИмяФайла(Знач ПолноеИмяФайла, ЭтоПапка = Ложь) Экспорт
	
	СтруктураИмениФайла = Новый Структура("ПолноеИмя,Путь,Имя,Расширение,ИмяБезРасширения");
	
	// Убераем из полного имени файла завершающий слеш и сохраняем получившееся полное имя в структуре
	Если ЭтоПапка И (Прав(ПолноеИмяФайла, 1) = "/" Или Прав(ПолноеИмяФайла, 1) = "\") Тогда
		Если ЭтоПапка Тогда
			ПолноеИмяФайла = Сред(ПолноеИмяФайла, 1, СтрДлина(ПолноеИмяФайла) - 1);
		Иначе
			// Если путь к файлу заканчивается слешем, то у файла нет имени.
			СтруктураИмениФайла.Вставить("ПолноеИмя", ПолноеИмяФайла); 
			СтруктураИмениФайла.Вставить("Путь", ПолноеИмяФайла); 
			СтруктураИмениФайла.Вставить("Имя", ""); 
			СтруктураИмениФайла.Вставить("Расширение", ""); 
			СтруктураИмениФайла.Вставить("ИмяБезРасширения", ""); 
			Возврат СтруктураИмениФайла;
		КонецЕсли;
	КонецЕсли;
	СтруктураИмениФайла.Вставить("ПолноеИмя", ПолноеИмяФайла); 
	
	// Если полное имя файла оказалось пустым - то остальные параметры структуры возвращаем пустыми
	Если СтрДлина(ПолноеИмяФайла) = 0 Тогда 
		СтруктураИмениФайла.Вставить("Путь", ""); 
		СтруктураИмениФайла.Вставить("Имя", ""); 
		СтруктураИмениФайла.Вставить("Расширение", ""); 
		СтруктураИмениФайла.Вставить("ИмяБезРасширения", ""); 
		Возврат СтруктураИмениФайла;
	КонецЕсли;
	
	// Выделяем путь к файлу и имя файла									 
	Если Найти(ПолноеИмяФайла, "/") > 0 Тогда
		ПозицияРазделителя = СтроковыеФункцииКлиентСервер.НайтиСимволСКонца(ПолноеИмяФайла, "/");
	ИначеЕсли Найти(ПолноеИмяФайла, "\") > 0 Тогда
		ПозицияРазделителя = СтроковыеФункцииКлиентСервер.НайтиСимволСКонца(ПолноеИмяФайла, "\");
	Иначе
		ПозицияРазделителя = 0;
	КонецЕсли;
	СтруктураИмениФайла.Вставить("Путь", Лев(ПолноеИмяФайла, ПозицияРазделителя)); 
	СтруктураИмениФайла.Вставить("Имя", Сред(ПолноеИмяФайла, ПозицияРазделителя + 1));
	
	// Папки не имеют расширений, а для файла выделяем расширение
	Если ЭтоПапка Тогда
		СтруктураИмениФайла.Вставить("Расширение", "");
		СтруктураИмениФайла.Вставить("ИмяБезРасширения", СтруктураИмениФайла.Имя);
	Иначе
        ПозицияТочки = СтроковыеФункцииКлиентСервер.НайтиСимволСКонца(СтруктураИмениФайла.Имя, ".");
		Если ПозицияТочки = 0 Тогда
			СтруктураИмениФайла.Вставить("Расширение", "");
			СтруктураИмениФайла.Вставить("ИмяБезРасширения", СтруктураИмениФайла.Имя);
		Иначе
			СтруктураИмениФайла.Вставить("Расширение", Сред(СтруктураИмениФайла.Имя, ПозицияТочки));
			СтруктураИмениФайла.Вставить("ИмяБезРасширения", Лев(СтруктураИмениФайла.Имя, ПозицияТочки - 1));
		КонецЕсли;
	КонецЕсли;
	
	Возврат СтруктураИмениФайла;
	
КонецФункции

// Возвращает строку недопустимых символов
// Возвращаемое значение:
//   Строка - строка недопустимых символов
Функция ПолучитьНедопустимыеСимволыВИмениФайла() Экспорт

	НедопустимыеСимволы = """/\[]:;|=,?*<>";
	Возврат НедопустимыеСимволы;

КонецФункции

// Проверяет наличение недопустимых символов в имени файла
//
// Параметры
//  ИмяФайла  - Строка 
// Возвращаемое значение:
//   Массив   - массив обнаруженных в имени файла недопустимых символов.
//              Если недопустимых символов не обнаружено возвращается пустой массив.
Функция НайтиНедопустимыеСимволыВИмениФайла(ИмяФайла) Экспорт

	НедопустимыеСимволы = ПолучитьНедопустимыеСимволыВИмениФайла();
	
	МассивНайденныхНедопустимыхСимволов = Новый Массив;
	
	Для ПозицияСимвола = 1 По СтрДлина(НедопустимыеСимволы) Цикл
		ПроверяемыйСимвол = Сред(НедопустимыеСимволы,ПозицияСимвола,1);
		Если Найти(ИмяФайла,ПроверяемыйСимвол) <> 0 Тогда
			МассивНайденныхНедопустимыхСимволов.Добавить(ПроверяемыйСимвол);
		КонецЕсли;
	КонецЦикла;
	
	Возврат МассивНайденныхНедопустимыхСимволов;

КонецФункции

// Заменяет недопустимые символы в имени файла
//
// Параметры
//  ИмяФайла     - Строка - исходное имя файла.
//  НаЧтоМенять  - Строка - строка на которые неоходимо заменить недопустимые символы.
//
// Возвращаемое значение:
//   Строка   - имя файла в котором недопустимые символы заменены.
//
Функция ЗаменитьНедопустимыеСимволыВИмениФайла(ИмяФайла, НаЧтоМенять = " ") Экспорт

	МассивНайденныхНедопустимыхСимволов = НайтиНедопустимыеСимволыВИмениФайла(ИмяФайла);
	Для Каждого НедопустимыйСимвол Из МассивНайденныхНедопустимыхСимволов Цикл
		ИмяФайла = СтрЗаменить(ИмяФайла,НедопустимыйСимвол,НаЧтоМенять);
	КонецЦикла;
	
	Возврат ИмяФайла;

КонецФункции

////////////////////////////////////////////////////////////////////////////////
// Блок функций для работы с почтовыми адресами
//

// Функция проверяет что введенная строка с e-mail адресами введена правильно
//
// Формат строки:
// Z = ИмяПользователя|[Имя Пользователя] [<]пользователь@почтовый_сервер[>], Строка = Z[<разделитель*>Z]..
// 
//   прим.: разделитель* - имеется в виду любой разделитель адресов
//
// Параметры:
// СтрокаПереданныхАдресов - строка - правильная строка с почтовыми адресами
//
// Возвращаемое значение:
// Структура
// ключ Статус - булево - успех или неуспех преобразования
// в случае успеха содержит ключ Значение:
//           Массив структур, где
//                  Адрес- e-mail получателя
//                  Представление   - имя получателя
// в случае неуспеха содержит ключ СообщениеОбОшибке - строка
//
//  ВАЖНО: Функция возвращает массив структур, в которых одно поле (любое)
//         может быть незаполнено. Может использоваться различными
//         подсистемами для собственного сопоставления имени пользователя
//         некому e-mail адресу. Поэтому, необходимо перед непосредственной
//         отправкой проверить, что поле почтового адреса заполнено.
//
Функция РазобратьСтрокуСПочтовымиАдресами(знач СтрокаПереданныхАдресов) Экспорт
	
	Результат = Новый Массив;
	
	НедопустимыеСимволы = "!#$%^&*()+`~|\/=";
	
	СообщениеНедопустимыеСимволы = НСтр("ru = 'Недопустимый символ %1 в адресе электронной почты %2'");
	СообщениеНеверныйФорматПочтовогоАдреса = НСтр("ru = 'Некорректный адрес электронной почты %1'");
	
	МассивПодстрок = СтроковыеФункцииКлиентСервер.РазложитьСтрокуВМассивПодстрок(СтрокаПереданныхАдресов,";", Истина);
	МассивПодстрокКОбработке = Новый Массив;
	
	Для каждого ЭлементМассива Из МассивПодстрок Цикл
		Если Найти(ЭлементМассива,",") > 0 Тогда
			ДопМассивПодстрок = СтроковыеФункцииКлиентСервер.РазложитьСтрокуВМассивПодстрок(СтрокаПереданныхАдресов);
			Для каждого ЭлементДопМассива Из ДопМассивПодстрок Цикл
				МассивПодстрокКОбработке.Добавить(ЭлементДопМассива);
			КонецЦикла;
		Иначе
			МассивПодстрокКОбработке.Добавить(ЭлементМассива);
		КонецЕсли;
	КонецЦикла;
	
	Для Каждого СтрокаАдреса ИЗ МассивПодстрокКОбработке Цикл
		
		Индекс = 1;               // номер обрабатываемого символа
		Накопитель = "";          // накопитель символов, после анализа перемещается либо в полное имя
		// либо в почтовый адрес
		ПолноеИмяАдресата = "";   // переменная, накапливающая имя адресата
		ПочтовыйАдрес = "";       // переменная, накапливающая e-mail адрес
		// 1 - формирование полного имени: ожидаются любые допустимые символы имени адресата
		// 2 - формирование почтового адреса: ожидаются любые допустимые символы email адреса
		// 3 - завершение формирования очередного почтового адреса - ожидаются символы разделители либо пробелы
		СтадияРазбора = 1; 
		
		Пока Индекс <= СтрДлина(СтрокаАдреса) Цикл
			
			Символ = Сред(СтрокаАдреса, Индекс, 1);
			
			Если      Символ = " " Тогда
				Индекс = ? ((ПропуститьПробелы(СтрокаАдреса, Индекс, " ") - 1) > Индекс,
				ПропуститьПробелы(СтрокаАдреса, Индекс, " ") - 1,
				Индекс);
				Если      СтадияРазбора = 1 Тогда
					ПолноеИмяАдресата = ПолноеИмяАдресата + Накопитель + " ";
				ИначеЕсли СтадияРазбора = 2 Тогда
					ПочтовыйАдрес = Накопитель;
					СтадияРазбора = 3;
				КонецЕсли;
				Накопитель = "";
			ИначеЕсли Символ = "@" Тогда
				Если      СтадияРазбора = 1 Тогда
					СтадияРазбора = 2;
					
					Для ИндексПоискаНС = 1 По СтрДлина(Накопитель) Цикл
						Если Найти(НедопустимыеСимволы, Сред(Накопитель, ИндексПоискаНС, 1)) > 0 Тогда
							ВызватьИсключение СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
							                  СообщениеНедопустимыеСимволы,Сред(Накопитель, ИндексПоискаНС, 1),СтрокаАдреса);
						КонецЕсли;
					КонецЦикла;
					
					Накопитель = Накопитель + Символ;
				ИначеЕсли СтадияРазбора = 2 Тогда
					ВызватьИсключение СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
					                  СообщениеНеверныйФорматПочтовогоАдреса,СтрокаАдреса);
				ИначеЕсли СтадияРазбора = 3 Тогда
					ВызватьИсключение СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
					                  СообщениеНеверныйФорматПочтовогоАдреса,СтрокаАдреса);
				КонецЕсли;
			Иначе
				Если СтадияРазбора = 2 ИЛИ СтадияРазбора = 3 Тогда
					Если Найти(НедопустимыеСимволы, Символ) > 0 Тогда
						ВызватьИсключение СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
						                  СообщениеНедопустимыеСимволы,Символ,СтрокаАдреса);
					КонецЕсли;
				КонецЕсли;
				
				Накопитель = Накопитель + Символ;
			КонецЕсли;
			
			Индекс = Индекс + 1;
		КонецЦикла;
		
		Если      СтадияРазбора = 1 Тогда
			ПолноеИмяАдресата = ПолноеИмяАдресата + Накопитель;
		ИначеЕсли СтадияРазбора = 2 Тогда
			ПочтовыйАдрес = Накопитель;
		КонецЕсли;
		
		Если ПустаяСтрока(ПочтовыйАдрес) И (Не ПустаяСтрока(ПолноеИмяАдресата)) Тогда
			ВызватьИсключение СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
			                  СообщениеНеверныйФорматПочтовогоАдреса,ПолноеИмяАдресата);
		ИначеЕсли СтрЧислоВхождений(ПочтовыйАдрес,"@") <> 1 Тогда 
			ВызватьИсключение СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
			                  СообщениеНеверныйФорматПочтовогоАдреса,ПочтовыйАдрес);
		КонецЕсли;
		
		Если НЕ (ПустаяСтрока(ПолноеИмяАдресата) И ПустаяСтрока(ПочтовыйАдрес)) Тогда
			Результат.Добавить(ПроверитьИПодготовитьПочтовыйАдрес(ПолноеИмяАдресата, ПочтовыйАдрес));
		КонецЕсли;
		
	КонецЦикла;
	
	Возврат Результат;
	
КонецФункции

// Проверяет, что почтовый адрес не содержит символов обрамления
// если символы обрамления вставлены правильно убирает их
// Параметры:
//  ПолноеИмяАдресата - строка - имя получателя
//  ПочтовыйАдрес     - строка - email адрес
// Возвращаемое значение:
//  Структура:
//   Ключ статус - булево - успех или неуспех операции
//   СообщениеОбОшибке - в случае неуспеха операции содержит сообщение об ошибке
//   Значение - структура - в случае успеха операции содержит записанную структуру почтового
//                          адреса: ключи - Адрес, Представление (строки)
//
Функция ПроверитьИПодготовитьПочтовыйАдрес(знач ПолноеИмяАдресата, знач ПочтовыйАдрес)
	
	НедопустимыйСимволВИмениАдресата = НСтр("ru = 'Недопустимый символ в имени адресата.'");
	НедопустимыйСимволВПочтовомАдресе = НСтр("ru = 'Недопустимый символ в почтовом адресе.'");
	СимволыОбрамления = "<>[]";
	
	ПочтовыйАдрес     = СокрЛП(ПочтовыйАдрес);
	ПолноеИмяАдресата = СокрЛП(ПолноеИмяАдресата);
	
	Если Лев(ПолноеИмяАдресата, 1) = "<" Тогда
		Если Прав(ПолноеИмяАдресата, 1) = ">" Тогда
			ПолноеИмяАдресата = Сред(ПолноеИмяАдресата, 2, СтрДлина(ПолноеИмяАдресата)-2);
		Иначе
			ВызватьИсключение НедопустимыйСимволВИмениАдресата;
		КонецЕсли;
	ИначеЕсли Лев(ПолноеИмяАдресата, 1) = "[" Тогда
		Если Прав(ПолноеИмяАдресата, 1) = "]" Тогда
			ПолноеИмяАдресата = Сред(ПолноеИмяАдресата, 2, СтрДлина(ПолноеИмяАдресата)-2);
		Иначе
			ВызватьИсключение НедопустимыйСимволВИмениАдресата;
		КонецЕсли;
	КонецЕсли;
	
	Если Лев(ПочтовыйАдрес, 1) = "<" Тогда
		Если Прав(ПочтовыйАдрес, 1) = ">" Тогда
			ПочтовыйАдрес = Сред(ПочтовыйАдрес, 2, СтрДлина(ПочтовыйАдрес)-2);
		Иначе
			ВызватьИсключение НедопустимыйСимволВПочтовомАдресе;
		КонецЕсли;
	ИначеЕсли Лев(ПочтовыйАдрес, 1) = "[" Тогда
		Если Прав(ПочтовыйАдрес, 1) = "]" Тогда
			ПочтовыйАдрес = Сред(ПочтовыйАдрес, 2, СтрДлина(ПочтовыйАдрес)-2);
		Иначе
			ВызватьИсключение НедопустимыйСимволВПочтовомАдресе;
		КонецЕсли;
	КонецЕсли;
	
	Для Индекс = 1 По СтрДлина(СимволыОбрамления) Цикл
		Если Найти(ПолноеИмяАдресата, Сред(СимволыОбрамления, Индекс, 1)) <> 0
		 ИЛИ Найти(ПочтовыйАдрес,     Сред(СимволыОбрамления, Индекс, 1)) <> 0 Тогда
			ВызватьИсключение НедопустимыйСимволВПочтовомАдресе;
		КонецЕсли;
	КонецЦикла;
	
	Возврат Новый Структура("Адрес, Представление", ПочтовыйАдрес,ПолноеИмяАдресата);
	
КонецФункции

// Разбирает строку с адресами электронной почты согласно стандарту RFC 5322 с ограничениями.
//
// Ограничения:
//  1. В адресе разрешаются только буквы, цифры, символ подчеркивания, дефис и символ "@".
//  2. Символы скобок "<>[]()" допускаются, но игнорируются путём замены на пробелы.
//  3. Группы запрещены.
//
// Параметры:
//  Строка - Строка - Строка, содержащая электронные адреса (mailbox-list).
//
// Возвращаемое значение:
//  Массив - содержит массив структур адресов.
//           Поля структуры:
//             Псевдоним      - Строка - представление адресата.
//             Адрес          - Строка - найденный и соответствующий требованиям почтовый адрес;
//                                       Если текст, похожий на адрес найден, но не соответствует требованиям
//                                       стандартов, то такой текст записывается в поле "Псевдоним".
//             ОписаниеОшибки - Строка - текстовое представление ошибки, либо пустая строка, если ошибок нет.
Функция АдресаЭлектроннойПочтыИзСтроки(Знач Строка) Экспорт
	
	Результат = Новый Массив;
	
	// заменяем скобки на пробелы
	СимволыСкобок = "<>()[]";
	Строка = ЗаменитьСимволыВСтрокеНаПробелы(Строка, СимволыСкобок);
	
	// приводим разделители к одному виду
	Строка = СтрЗаменить(Строка, ",", ";");
	
	// раскладываем mailbox-list на mailbox'ы
	МассивАдресов = РазложитьСтрокуНаМассивПодстрок(Строка);
	
	// допустимые символы для псевдонима (display-name)
	Буквы = "abcdefghijklmnopqrstuvwxyzабвгдеёжзийклмнопрстуфхцчшщъыьэюя";
	Цифры = "0123456789";
	ДополнительныеСимволы = "._- ";
	
	// выделяем из строки адреса (mailbox'а) псевдоним (display-name) и адрес (addr-spec)
	Для Каждого СтрокаАдреса Из МассивАдресов Цикл
		
		Псевдоним = "";
		Адрес = "";
		ОписаниеОшибки = "";
		
		Если СтрЧислоВхождений(СтрокаАдреса, "@") <> 1 Тогда
			Псевдоним = СтрокаАдреса;
		Иначе
			// всё, что не подходит в качестве адреса, складываем в псевдоним
			Для Каждого Подстрока Из РазложитьСтрокуНаМассивПодстрок(СтрокаАдреса, " ") Цикл
				Если ПустаяСтрока(Адрес) и АдресЭлектроннойПочтыСоответствуетТребованиям(Подстрока) Тогда
					Адрес = Подстрока;
				Иначе
					Псевдоним = Псевдоним + " " + Подстрока;
				КонецЕсли;
			КонецЦикла;
		КонецЕсли;
		
		Псевдоним = СокрЛП(Псевдоним);
		
		// проверки
		Если ПустаяСтрока(ОписаниеОшибки) Тогда
			ЕстьНедопустимыеСимволыВПсевдониме = Не СтрокаСодержитТолькоДопустимыеСимволы(НРег(Псевдоним), Буквы + Цифры + ДополнительныеСимволы);
			АдресОпределен = Не ПустаяСтрока(Адрес);
			ЕстьПризнакНаличияАдресаВСтроке = Найти(СтрокаАдреса, "@") > 0;
			
			Если АдресОпределен Тогда 
				Если ЕстьНедопустимыеСимволыВПсевдониме Тогда
					ОписаниеОшибки = НСтр("ru = 'Представление содержит недопустимые символы'");
				КонецЕсли;
			Иначе
				Если ЕстьПризнакНаличияАдресаВСтроке Тогда 
					ОписаниеОшибки = НСтр("ru = 'Адрес электронной почты содержит ошибки'");
				Иначе
					ОписаниеОшибки = НСтр("ru = 'Строка не содержит адреса электронной почты'");
				КонецЕсли;
			КонецЕсли;	
		КонецЕсли;
		
		СтруктураАдреса = Новый Структура("Псевдоним,Адрес,ОписаниеОшибки", Псевдоним, Адрес, ОписаниеОшибки);
		Результат.Добавить(СтруктураАдреса);
	КонецЦикла;
	
	Возврат Результат;	
	
КонецФункции

Функция ЗаменитьСимволыВСтрокеНаПробелы(Строка, ЗаменяемыеСимволы)
	Результат = Строка;
	Для Позиция = 1 по СтрДлина(Символы) Цикл
		Результат = СтрЗаменить(Результат, Сред(ЗаменяемыеСимволы, Позиция, 1), " ");
	КонецЦикла;
	Возврат Результат;
КонецФункции

Функция РазложитьСтрокуНаМассивПодстрок(Знач Строка, Разделитель = ";", ПропускатьПустыеСтроки = Истина)
	
	Результат = Новый Массив;
	
	Позиция = Найти(Строка, Разделитель);
	Пока Позиция > 0 Цикл
		Подстрока = Лев(Строка, Позиция - 1);
		Если Не ПустаяСтрока(Подстрока) или не ПропускатьПустыеСтроки Тогда
			Результат.Добавить(Подстрока);
		КонецЕсли;
		Строка = Сред(Строка, Позиция + СтрДлина(Разделитель));
		Позиция = Найти(Строка, Разделитель);
	КонецЦикла;
	
	Результат.Добавить(Строка);
	
	Возврат Результат;
		
КонецФункции

// Проверяет email адрес на соответствие требованиям стандартов RFC 5321, RFC 5322,
// а также RFC 5335, RFC 5336 и RFC 3696.
// Кроме того, функция ограничивает использование спецсимволов.
// 
// Параметры:
//  Адрес - Строка - проверяемый email.
//
// Возвращаемое значение:
//  Булево - Истина, если ошибок нет.
//
Функция АдресЭлектроннойПочтыСоответствуетТребованиям(Знач Адрес) Экспорт
	
	// допустимые символы для email
	Буквы = "abcdefghijklmnopqrstuvwxyzабвгдеёжзийклмнопрстуфхцчшщъыьэюя";
	Цифры = "0123456789";
	СпецСимволы = ".@_-";
	
	// проверяем любые сочетания спецсимволов
	Если СтрДлина(СпецСимволы) > 1 Тогда
		Для Позиция1 = 1 По СтрДлина(СпецСимволы)-1 Цикл
			Символ1 = Сред(СпецСимволы, Позиция1, 1);
			Для Позиция2 = Позиция1 + 1 По СтрДлина(СпецСимволы) Цикл
				Символ2 = Сред(СпецСимволы, Позиция2, 1);
				Комбинация1 = Символ1 + Символ2;
				Комбинация2 = Символ2 + Символ1;
				Если Найти(Адрес, Комбинация1) > 0 или Найти(Адрес, Комбинация2) > 0 Тогда
					Возврат Ложь;
				КонецЕсли;
			КонецЦикла;
		КонецЦикла;
	КонецЕсли;
	
	// проверяем символ @
	Если СтрЧислоВхождений(Адрес, "@") <> 1 Тогда
		Возврат Ложь;
	КонецЕсли;
	   
	// проверяем две точки подряд
	Если Найти(Адрес, "..") > 0 Тогда
		Возврат Ложь;
	КонецЕсли;
	
	// приводим строку адреса к нижнему регистру
	Адрес = НРег(Адрес);
	
	// проверяем допустимые символы
	Если Не СтрокаСодержитТолькоДопустимыеСимволы(Адрес, Буквы + Цифры + СпецСимволы) Тогда
		Возврат Ложь;
	КонецЕсли;
	
	// разбираем адрес на local-part и domain
	Позиция = Найти(Адрес,"@");
	ЛокальноеИмя = Лев(Адрес, Позиция - 1);
	Домен = Сред(Адрес, Позиция + 1);
	
	// проверяем на заполненность и допустимость длины
	Если ПустаяСтрока(ЛокальноеИмя)
	 	или ПустаяСтрока(Домен)
		или СтрДлина(ЛокальноеИмя) > 64
		или СтрДлина(Домен) > 255 Тогда
		
		Возврат Ложь;
	КонецЕсли;
	
	// проверяем наличие спецсимволов в начале и в конце частей адреса
	Если ЕстьСимволыВНачалеВКонце(ЛокальноеИмя, СпецСимволы) или ЕстьСимволыВНачалеВКонце(Домен, СпецСимволы) Тогда
		Возврат Ложь;
	КонецЕсли;
	
	// в домене должна быть минимум одна точка
	Если Найти(Домен,".") = 0 Тогда
		Возврат Ложь;
	КонецЕсли;
	
	// в домене не должно быть символа подчеркивания
	Если Найти(Домен,"_") > 0 Тогда
		Возврат Ложь;
	КонецЕсли;
	
	// выделяем зону (TLD) из имени домена 
	Зона = Домен;
	Позиция = Найти(Зона,".");
	Пока Позиция > 0 Цикл
		Зона = Сред(Зона, Позиция + 1);
		Позиция = Найти(Зона,".");
	КонецЦикла;
	
	// проверяем зону домена (минимум 2 символа, только буквы)
	Возврат СтрДлина(Зона) >= 2 и СтрокаСодержитТолькоДопустимыеСимволы(Зона,Буквы);
	
КонецФункции

Функция ЕстьСимволыВНачалеВКонце(Строка, ПроверяемыеСимволы)
	Для Позиция = 1 По СтрДлина(ПроверяемыеСимволы) Цикл
		Символ = Сред(ПроверяемыеСимволы, Позиция, 1);
		СимволНайден = (Лев(Строка,1) = Символ) или (Прав(Строка,1) = Символ);
		Если СимволНайден Тогда
			Возврат Истина;
		КонецЕсли;
	КонецЦикла;
	Возврат Ложь;
КонецФункции

Функция СтрокаСодержитТолькоДопустимыеСимволы(Строка, ДопустимыеСимволы)
	МассивСимволов = Новый Массив;
	Для Позиция = 1 по СтрДлина(ДопустимыеСимволы) Цикл
		МассивСимволов.Добавить(Сред(ДопустимыеСимволы,Позиция,1));
	КонецЦикла;
	
	Для Позиция = 1 по СтрДлина(Строка) Цикл
		Если МассивСимволов.Найти(Сред(Строка, Позиция, 1)) = Неопределено Тогда
			Возврат Ложь;
		КонецЕсли;
	КонецЦикла;
	
	Возврат Истина;
КонецФункции

// Формирует структуру с ключами Статус (Истина) и Значение
//
Функция ЗаполнитьРезультат(знач Значение, знач Статус = Истина) Экспорт
	
	Если Статус Тогда
		Возврат Новый Структура("Статус, Значение", Истина, Значение);
	Иначе
		Возврат Новый Структура("Статус, СообщениеОбОшибке", Ложь, Значение);
	КонецЕсли;
	
КонецФункции

// Сдвигает маркер позиции пока встречается символ Символ
// возвращает номер позиции в строке, на которое установился маркер
//
Функция ПропуститьПробелы(знач Строка,
                          знач ТекущийИндекс,
                          знач ПропускаемыйСимвол)
	
	Результат = ТекущийИндекс;
	
	// убираем лишние пробелы если они есть
	Пока ТекущийИндекс < СтрДлина(Строка) Цикл
		Если Сред(Строка, ТекущийИндекс, 1) <> ПропускаемыйСимвол Тогда
			Возврат ТекущийИндекс;
		КонецЕсли;
		ТекущийИндекс = ТекущийИндекс + 1;
	КонецЦикла;
	
	Возврат ТекущийИндекс;
	
КонецФункции

#Если Не ВебКлиент Тогда
// Возвращает полный путь к новому каталогу в каталоге временных файлов.
//
// Параметры:
//  Идентификатор - Строка, начальная часть имени каталога во временном каталоге.
//
// Возвращаемое значение:
//  Строка - полное имя временного каталога, например "КаталогВременныхФайлов() + Обработка123\".
// 
Функция ПолучитьИмяКаталога(знач Идентификатор) Экспорт
	
	Индекс = 0;
	
	Пока Истина Цикл
		
		ПутьККаталогу = КаталогВременныхФайлов () + Идентификатор + строка(Индекс) + "/";
		КаталогНаДиске = Новый Файл(ПутьККаталогу);
		Если НЕ КаталогНаДиске.Существует() Тогда
			СоздатьКаталог(ПутьККаталогу);
			Возврат ПутьККаталогу;
		КонецЕсли;
		Индекс = Индекс + 1;
		
	КонецЦикла;
	
КонецФункции // ПолучитьИмяКаталога()
#КонецЕсли

////////////////////////////////////////////////////////////////////////////////
// Функции для работы с отборами динамических списков
//

// Поиск элементов и групп отбора динамического списка
// Параметры:
//  ОбластьПоиска - контейнер с элементами и группами отбора, например
//                  Список.Отбор или группа в отборе
//  ИмяПоля - имя поля компоновки (не используется для групп)
//  Представление - представление поля компоновки
//  Примечание: поиск может осуществляться или по ЛевомуЗначению, или по Представлению
//
Функция НайтиЭлементыИГруппыОтбора(знач ОбластьПоиска,
									знач ИмяПоля = Неопределено,
									знач Представление = Неопределено) Экспорт
	
	Если ЗначениеЗаполнено(ИмяПоля) Тогда
		ЗначениеПоиска = Новый ПолеКомпоновкиДанных(ИмяПоля);
		СпособПоиска = 1;
	Иначе
		СпособПоиска = 2;
		ЗначениеПоиска = Представление;
	КонецЕсли;
	
	МассивЭлементов = Новый Массив;
	
	НайтиРекурсивно(ОбластьПоиска.Элементы, МассивЭлементов, СпособПоиска, ЗначениеПоиска);
	
	Возврат МассивЭлементов;
	
КонецФункции

// Добавление группы отбора
// Параметры:
//  КоллекцияЭлементов - контейнер с элементами и группами отбора, например
//                      Список.Отбор.Элементы или группа в отборе
//  ТипГруппы - ТипГруппыЭлементовОтбораКомпоновкиДанных - тип группы
//  Представление строка - представление группы
//
Функция СоздатьГруппуЭлементовОтбора(КоллекцияЭлементов, Представление, ТипГруппы) Экспорт
	
	ГруппаЭлементовОтбора = НайтиЭлементОтбораПоПредставлению(КоллекцияЭлементов, Представление);
	Если ГруппаЭлементовОтбора = Неопределено Тогда
		ГруппаЭлементовОтбора = КоллекцияЭлементов.Добавить(Тип("ГруппаЭлементовОтбораКомпоновкиДанных"));
	Иначе
		ГруппаЭлементовОтбора.Элементы.Очистить();
	КонецЕсли;
	
	ГруппаЭлементовОтбора.Представление    = Представление;
	ГруппаЭлементовОтбора.Применение       = ТипПримененияОтбораКомпоновкиДанных.Элементы;
	ГруппаЭлементовОтбора.РежимОтображения = РежимОтображенияЭлементаНастройкиКомпоновкиДанных.Недоступный;
	ГруппаЭлементовОтбора.ТипГруппы        = ТипГруппы;
	ГруппаЭлементовОтбора.Использование    = Истина;
	
	Возврат ГруппаЭлементовОтбора;
	
КонецФункции

// Добавление элемента компоновки в контейнер элементов компоновки
// Параметры:
//  ОбластьДобавления - контейнер с элементами и группами отбора, например
//                  Список.Отбор или группа в отборе
//  ИмяПоля - строка - имя для поля компоновки данных
//  ВидСравнения - ВидСравненияКомпоновкиДанных - вид сравнения
//  ПравоеЗначение - произвольный
//  Представление - представление элемента компоновки данных
//  Использование - булево - использование элемента
//  РежимОтображения - РежимОтображенияЭлементаНастройкиКомпоновкиДанных - режим отображения
//
Функция ДобавитьЭлементКомпоновки(ОбластьДобавления,
									знач ИмяПоля,
									знач ВидСравнения,
									знач ПравоеЗначение = Неопределено,
									знач Представление  = Неопределено,
									знач Использование  = Неопределено,
									знач РежимОтображения = Неопределено) Экспорт
	
	Элемент = ОбластьДобавления.Элементы.Добавить(Тип("ЭлементОтбораКомпоновкиДанных"));
	Элемент.ЛевоеЗначение = Новый ПолеКомпоновкиДанных(ИмяПоля);
	Элемент.ВидСравнения = ВидСравнения;
	
	Если РежимОтображения = Неопределено Тогда
		Элемент.РежимОтображения = РежимОтображенияЭлементаНастройкиКомпоновкиДанных.Недоступный;
	Иначе
		Элемент.РежимОтображения = РежимОтображения;
	КонецЕсли;
	
	Если ПравоеЗначение <> Неопределено Тогда
		Элемент.ПравоеЗначение = ПравоеЗначение;
	КонецЕсли;
	
	Если Представление <> Неопределено Тогда
		Элемент.Представление = Представление;
	КонецЕсли;
	
	Если Использование <> Неопределено Тогда
		Элемент.Использование = Использование;
	КонецЕсли;
	
	Возврат Элемент;
	
КонецФункции

// Изменение элементов отбора
// Параметры
//  ИмяПоля - строка - имя поля компоновки
//  ВидСравнения - ВидСравненияКомпоновкиДанных - вид сравнения
//  ПравоеЗначение - произвольный
//  Представление - строка - представление элемента компоновки данных
//  Использование - булево - использование элемента
//  РежимОтображения - РежимОтображенияЭлементаНастройкиКомпоновкиДанных - режим отображения
//
Функция ИзменитьЭлементыОтбора(ОбластьПоиска,
								знач ИмяПоля = Неопределено,
								знач Представление = Неопределено,
								знач ПравоеЗначение = Неопределено,
								знач ВидСравнения = Неопределено,
								знач Использование = Неопределено,
								знач РежимОтображения = Неопределено) Экспорт
	
	Если ЗначениеЗаполнено(ИмяПоля) Тогда
		ЗначениеПоиска = Новый ПолеКомпоновкиДанных(ИмяПоля);
		СпособПоиска = 1;
	Иначе
		СпособПоиска = 2;
		ЗначениеПоиска = Представление;
	КонецЕсли;
	
	МассивЭлементов = Новый Массив;
	
	НайтиРекурсивно(ОбластьПоиска.Элементы, МассивЭлементов, СпособПоиска, ЗначениеПоиска);
	
	Для Каждого Элемент Из МассивЭлементов Цикл
		Если ИмяПоля <> Неопределено Тогда
			Элемент.ЛевоеЗначение = Новый ПолеКомпоновкиДанных(ИмяПоля);
		КонецЕсли;
		Если Представление <> Неопределено Тогда
			Элемент.Представление = Представление;
		КонецЕсли;
		Если Использование <> Неопределено Тогда
			Элемент.Использование = Использование;
		КонецЕсли;
		Если ВидСравнения <> Неопределено Тогда
			Элемент.ВидСравнения = ВидСравнения;
		КонецЕсли;
		Если ПравоеЗначение <> Неопределено Тогда
			Элемент.ПравоеЗначение = ПравоеЗначение;
		КонецЕсли;
		Если РежимОтображения <> Неопределено Тогда
			Элемент.РежимОтображения = РежимОтображения;
		КонецЕсли;
	КонецЦикла;
	
	Возврат МассивЭлементов.Количество();
	
КонецФункции

// Поиск элементов и групп отбора динамического списка
// Параметры:
//  ОбластьУдаления - контейнер с элементами и группами отбора, например
//                  Список.Отбор или группа в отборе
//  ИмяПоля - имя поля компоновки (не используется для групп)
//  Представление - представление поля компоновки
//  Примечание: поиск может осуществляться или по ЛевомуЗначению, или по Представлению
//
Процедура УдалитьЭлементыГруппыОтбора(знач ОбластьУдаления,
										знач ИмяПоля = Неопределено,
										знач Представление = Неопределено) Экспорт
	
	Если ЗначениеЗаполнено(ИмяПоля) Тогда
		ЗначениеПоиска = Новый ПолеКомпоновкиДанных(ИмяПоля);
		СпособПоиска = 1;
	Иначе
		СпособПоиска = 2;
		ЗначениеПоиска = Представление;
	КонецЕсли;
	
	МассивЭлементов = Новый Массив;
	
	НайтиРекурсивно(ОбластьУдаления.Элементы, МассивЭлементов, СпособПоиска, ЗначениеПоиска);
	
	Для Каждого Элемент Из МассивЭлементов Цикл
		Если Элемент.Родитель = Неопределено Тогда
			ОбластьУдаления.Элементы.Удалить(Элемент);
		Иначе
			Элемент.Родитель.Элементы.Удалить(Элемент);
		КонецЕсли;
	КонецЦикла;
	
КонецПроцедуры

// Используется для создания элемента отбора или, если таковой не найден,
// установления существующим элементам свойств
// Параметры
//  ОбластьПоискаДобавления - контейнер с элементами и группами отбора, например
//                  Список.Отбор или группа в отборе
//  ИмяПоля - строка - имя для поля компоновки данных (заполняется всегда)
// Устанавливаемые поля:
//  ВидСравнения - ВидСравненияКомпоновкиДанных - вид сравнения
//  ПравоеЗначение - произвольный
//  Представление - представление элемента компоновки данных
//  Использование - булево - использование элемента
//  РежимОтображения - РежимОтображенияЭлементаНастройкиКомпоновкиДанных - режим отображения
//
Процедура УстановитьЭлементОтбора(ОбластьПоискаДобавления,
								знач ИмяПоля,
								знач ПравоеЗначение = Неопределено,
								знач ВидСравнения = Неопределено,
								знач Представление = Неопределено,
								знач Использование = Неопределено,
								знач РежимОтображения = Неопределено) Экспорт
	
	ЧислоИзмененных = ИзменитьЭлементыОтбора(ОбластьПоискаДобавления, ИмяПоля, Представление,
							ПравоеЗначение, ВидСравнения, Использование, РежимОтображения);
	
	Если ЧислоИзмененных = 0 Тогда
		Если ВидСравнения = Неопределено Тогда
			ВидСравнения = ВидСравненияКомпоновкиДанных.Равно;
		КонецЕсли;
		ДобавитьЭлементКомпоновки(ОбластьПоискаДобавления, ИмяПоля, ВидСравнения,
								ПравоеЗначение, Представление, Использование, РежимОтображения);
	КонецЕсли;
	
КонецПроцедуры

// Устанавливает значение Значение параметра ИмяПараметра динамического списка Список 
// или отключает его использование в зависимости от признака Использование.
//
Процедура УстановитьПараметрДинамическогоСписка(Список, ИмяПараметра, Значение, Использование = Истина) Экспорт
	
	Если Использование Тогда
		Список.Параметры.УстановитьЗначениеПараметра(ИмяПараметра, Значение);
	Иначе
		ЗначениеПараметра = Список.Параметры.НайтиЗначениеПараметра(Новый ПараметрКомпоновкиДанных(ИмяПараметра));
		Если ЗначениеПараметра <> Неопределено Тогда
			ЗначениеПараметра.Значение = Значение;
			ЗначениеПараметра.Использование = Ложь;
		КонецЕсли;
	КонецЕсли;
	
КонецПроцедуры 

////////////////////////////////////////////////////////////////////////////////
// Функции для работы с управляемыми формами
//

// Получает значение реквизита формы
// Параметры:
//		Форма
//		ПутьРеквизита - строка, путь к данным, например: "Объект.МесяцНачисления"
Функция ПолучитьРеквизитФормыПоПути(Форма, ПутьРеквизита) Экспорт
	
	МассивИмен = СтроковыеФункцииКлиентСервер.РазложитьСтрокуВМассивПодстрок(ПутьРеквизита, ".");
	
	Объект        = Форма;
	ПоследнееПоле = МассивИмен[МассивИмен.Количество()-1];
	
	Для Сч = 0 по МассивИмен.Количество()-2 Цикл
		Объект = Объект[МассивИмен[Сч]]
	КонецЦикла;
	
	Возврат Объект[ПоследнееПоле];
	
КонецФункции

// Устанавливает значение реквизиту формы
// Параметры:
//		Форма
//		ПутьРеквизита - строка, путь к данным, например: "Объект.МесяцНачисления"
//		Значение
Процедура УстановитьРеквизитФормыПоПути(Форма, ПутьРеквизита, Значение, ТолькоЕслиНеЗаполнен = Ложь) Экспорт
	
	МассивИмен = СтроковыеФункцииКлиентСервер.РазложитьСтрокуВМассивПодстрок(ПутьРеквизита, ".");
	
	Объект        = Форма;
	ПоследнееПоле = МассивИмен[МассивИмен.Количество()-1];
	
	Для Сч = 0 по МассивИмен.Количество()-2 Цикл
		Объект = Объект[МассивИмен[Сч]]
	КонецЦикла;
	Если НЕ ТолькоЕслиНеЗаполнен ИЛИ НЕ ЗначениеЗаполнено(Объект[ПоследнееПоле]) Тогда
		Объект[ПоследнееПоле] = Значение;
	КонецЕсли;
	
КонецПроцедуры

// Выполняет поиск элемента отбора в коллекции по заданному представлению
//
// Параметры:
//  КоллекцияЭлементов - контейнер с элементами и группами отбора, например
//                      Список.Отбор.Элементы или группа в отборе
//  Представление строка - представление группы
// 
Функция НайтиЭлементОтбораПоПредставлению(КоллекцияЭлементов, Представление) Экспорт
	
	ВозвращаемоеЗначение = Неопределено;
	
	Для каждого ЭлементОтбора Из КоллекцияЭлементов Цикл
		Если ЭлементОтбора.Представление = Представление Тогда
			ВозвращаемоеЗначение = ЭлементОтбора;
			Прервать;
		КонецЕсли;
	КонецЦикла;
	
	Возврат ВозвращаемоеЗначение
	
КонецФункции

// Устанавливает свойство ИмяСвойства элемента формы с именем ИмяЭлемента в значение Значение.
// Применяется в тех случаях, когда элемент формы может не быть на форме из-за отсутствия прав у пользователя
// на объект, реквизит объекта или команду.
//
// Параметры:
//  ЭлементыФормы - свойство ЭлементыФормы управляемой формы.
//  ИмяЭлемента   - Строка       - имя элемента формы
//  ИмяСвойства   - Строка       - имя устанавливаемого свойства элемента формы
//  Значение      - Произвольный - новое значение элемента
// 
Процедура УстановитьСвойствоЭлементаФормы(ЭлементыФормы, ИмяЭлемента, ИмяСвойства, Значение) Экспорт

	ЭлементФормы = ЭлементыФормы.Найти(ИмяЭлемента);
	Если ЭлементФормы <> Неопределено  Тогда
		ЭлементФормы[ИмяСвойства] = Значение;
	КонецЕсли;

КонецПроцедуры 

// Возвращает значение свойства ИмяСвойства элемента формы с именем ИмяЭлемента.
// Применяется в тех случаях, когда элемент формы может не быть на форме из-за отсутствия прав у пользователя
// на объект, реквизит объекта или команду.
//
// Параметры:
//  ЭлементыФормы - свойство ЭлементыФормы управляемой формы.
//  ИмяЭлемента   - Строка       - имя элемента формы
//  ИмяСвойства   - Строка       - имя свойства элемента формы
// 
// Возвращаемое значение:
//   Произвольный - значение свойства ИмяСвойства элемента формы ИмяЭлемента.
// 
Функция ЗначениеСвойстваЭлементаФормы(ЭлементыФормы, ИмяЭлемента, ИмяСвойства) Экспорт

	ЭлементФормы = ЭлементыФормы.Найти(ИмяЭлемента);
	Возврат ?(ЭлементФормы <> Неопределено, ЭлементФормы[ИмяСвойства], Неопределено);

КонецФункции 

////////////////////////////////////////////////////////////////////////////////
// Служебные и вспомогательные функции
//

Процедура НайтиРекурсивно(КоллекцияЭлементов, МассивЭлементов, СпособПоиска, ЗначениеПоиска)
	
	Для каждого ЭлементОтбора Из КоллекцияЭлементов Цикл
		
		Если ТипЗнч(ЭлементОтбора) = Тип("ЭлементОтбораКомпоновкиДанных") Тогда
			
			Если СпособПоиска = 1 Тогда
				Если ЭлементОтбора.ЛевоеЗначение = ЗначениеПоиска Тогда
					МассивЭлементов.Добавить(ЭлементОтбора);
				КонецЕсли;
			ИначеЕсли СпособПоиска = 2 Тогда
				Если ЭлементОтбора.Представление = ЗначениеПоиска Тогда
					МассивЭлементов.Добавить(ЭлементОтбора);
				КонецЕсли;
			КонецЕсли;
		Иначе
			
			НайтиРекурсивно(ЭлементОтбора.Элементы, МассивЭлементов, СпособПоиска, ЗначениеПоиска);
			
			Если СпособПоиска = 2 И ЭлементОтбора.Представление = ЗначениеПоиска Тогда
				МассивЭлементов.Добавить(ЭлементОтбора);
			КонецЕсли;
			
		КонецЕсли;
		
	КонецЦикла;
	
КонецПроцедуры

// добавляет в конце "\" или "/"
Процедура ДобавитьСлешЕслиНужно(НовыйПуть, ТипПлатформыТекущий) Экспорт
	
	Если СтрДлина(НовыйПуть) = 0 Тогда
		Возврат;
	КонецЕсли;	
	
	Если Прав(НовыйПуть, 1) <> "\" И Прав(НовыйПуть,1) <> "/" Тогда
		
		Если ТипПлатформыТекущий = ТипПлатформы.Windows_x86 ИЛИ ТипПлатформыТекущий = ТипПлатформы.Windows_x86_64 Тогда
			НовыйПуть = НовыйПуть + "\";
		Иначе	
			НовыйПуть = НовыйПуть + "/";
		КонецЕсли;			
	КонецЕсли;
	
КонецПроцедуры	

// Получает представление сообщения ошибке на основании Информации об ошибке
// Может вызываться в операторных скобках Попытка ... Исключение ... КонецПопытки;
// для получения сообщения об ошибке.
//
Функция ПолучитьПредставлениеОписанияОшибки(ИнформацияОбОшибке) Экспорт
	
	Возврат ? (ИнформацияОбОшибке.Причина = Неопределено, ИнформацияОбОшибке.Описание, ИнформацияОбОшибке.Причина.Описание);
	
КонецФункции

// Копирует элементы из одной коллекции в другую
//
Процедура СкопироватьЭлементы(ПриемникЗначения, ИсточникЗначения, ПроверятьДоступность = Ложь, ОчищатьПриемник = Истина) Экспорт
	
	Если ТипЗнч(ИсточникЗначения) = Тип("УсловноеОформлениеКомпоновкиДанных")
		ИЛИ ТипЗнч(ИсточникЗначения) = Тип("ВариантыПользовательскогоПоляВыборКомпоновкиДанных")
		ИЛИ ТипЗнч(ИсточникЗначения) = Тип("ОформляемыеПоляКомпоновкиДанных")
		ИЛИ ТипЗнч(ИсточникЗначения) = Тип("ЗначенияПараметровДанныхКомпоновкиДанных") Тогда
		СоздаватьПоТипу = Ложь;
	Иначе
		СоздаватьПоТипу = Истина;
	КонецЕсли;
	ПриемникЭлементов = ПриемникЗначения.Элементы;
	ИсточникЭлементов = ИсточникЗначения.Элементы;
	Если ОчищатьПриемник Тогда
		ПриемникЭлементов.Очистить();
	КонецЕсли;
	
	Для каждого ЭлементИсточник Из ИсточникЭлементов Цикл
		
		Если ТипЗнч(ЭлементИсточник) = Тип("ЭлементПорядкаКомпоновкиДанных") Тогда
			// Элементы порядка добавляем в начало
			Индекс = ИсточникЭлементов.Индекс(ЭлементИсточник);
			ЭлементПриемник = ПриемникЭлементов.Вставить(Индекс, ТипЗнч(ЭлементИсточник));
		Иначе
			Если СоздаватьПоТипу Тогда
				ЭлементПриемник = ПриемникЭлементов.Добавить(ТипЗнч(ЭлементИсточник));
			Иначе
				ЭлементПриемник = ПриемникЭлементов.Добавить();
			КонецЕсли;
		КонецЕсли;
		
		ЗаполнитьЗначенияСвойств(ЭлементПриемник, ЭлементИсточник);
		// В некоторых коллекциях необходимо заполнить другие коллекции
		Если ТипЗнч(ИсточникЭлементов) = Тип("КоллекцияЭлементовУсловногоОформленияКомпоновкиДанных") Тогда
			СкопироватьЭлементы(ЭлементПриемник.Поля, ЭлементИсточник.Поля);
			СкопироватьЭлементы(ЭлементПриемник.Отбор, ЭлементИсточник.Отбор);
			ЗаполнитьЭлементы(ЭлементПриемник.Оформление, ЭлементИсточник.Оформление); 
		ИначеЕсли ТипЗнч(ИсточникЭлементов)	= Тип("КоллекцияВариантовПользовательскогоПоляВыборКомпоновкиДанных") Тогда
			СкопироватьЭлементы(ЭлементПриемник.Отбор, ЭлементИсточник.Отбор);
		КонецЕсли;
		
		// В некоторых элементах коллекции необходимо заполнить другие коллекции
		Если ТипЗнч(ЭлементИсточник) = Тип("ГруппаЭлементовОтбораКомпоновкиДанных") Тогда
			СкопироватьЭлементы(ЭлементПриемник, ЭлементИсточник);
		ИначеЕсли ТипЗнч(ЭлементИсточник) = Тип("ГруппаВыбранныхПолейКомпоновкиДанных") Тогда
			СкопироватьЭлементы(ЭлементПриемник, ЭлементИсточник);
		ИначеЕсли ТипЗнч(ЭлементИсточник) = Тип("ПользовательскоеПолеВыборКомпоновкиДанных") Тогда
			СкопироватьЭлементы(ЭлементПриемник.Варианты, ЭлементИсточник.Варианты);
		ИначеЕсли ТипЗнч(ЭлементИсточник) = Тип("ПользовательскоеПолеВыражениеКомпоновкиДанных") Тогда
			ЭлементПриемник.УстановитьВыражениеДетальныхЗаписей (ЭлементИсточник.ПолучитьВыражениеДетальныхЗаписей());
			ЭлементПриемник.УстановитьВыражениеИтоговыхЗаписей(ЭлементИсточник.ПолучитьВыражениеИтоговыхЗаписей());
			ЭлементПриемник.УстановитьПредставлениеВыраженияДетальныхЗаписей(ЭлементИсточник.ПолучитьПредставлениеВыраженияДетальныхЗаписей ());
			ЭлементПриемник.УстановитьПредставлениеВыраженияИтоговыхЗаписей(ЭлементИсточник.ПолучитьПредставлениеВыраженияИтоговыхЗаписей ());
		КонецЕсли;
		
	КонецЦикла;
	
КонецПроцедуры

Процедура ЗаполнитьЭлементы(ПриемникЗначения, ИсточникЗначения, ПервыйУровень = Неопределено) Экспорт
	
	Если ТипЗнч(ПриемникЗначения) = Тип("КоллекцияЗначенийПараметровКомпоновкиДанных") Тогда
		КоллекцияЗначений = ИсточникЗначения;
	Иначе
		КоллекцияЗначений = ИсточникЗначения.Элементы;
	КонецЕсли;
	
	Для каждого ЭлементИсточник Из КоллекцияЗначений Цикл
		Если ПервыйУровень = Неопределено Тогда
			ЭлементПриемник = ПриемникЗначения.НайтиЗначениеПараметра(ЭлементИсточник.Параметр);
		Иначе
			ЭлементПриемник = ПервыйУровень.НайтиЗначениеПараметра(ЭлементИсточник.Параметр);
		КонецЕсли;
		Если ЭлементПриемник = Неопределено Тогда
			Продолжить;
		КонецЕсли;
		ЗаполнитьЗначенияСвойств(ЭлементПриемник, ЭлементИсточник);
		Если ТипЗнч(ЭлементИсточник) = Тип("ЗначениеПараметраКомпоновкиДанных") Тогда
			Если ЭлементИсточник.ЗначенияВложенныхПараметров.Количество() <> 0 Тогда
				ЗаполнитьЭлементы(ЭлементПриемник.ЗначенияВложенныхПараметров, ЭлементИсточник.ЗначенияВложенныхПараметров, ПриемникЗначения);
			КонецЕсли;
		КонецЕсли;
	КонецЦикла;
	
КонецПроцедуры

// Функция выполняет получение имени поля из доступных полей компоновки данных.
//
Функция ПолучитьИмяПоляВШаблоне(Знач ИмяПоля) Экспорт
	
	ИмяПоля = СтрЗаменить(ИмяПоля, ".DeletionMark", ".ПометкаУдаления");
	ИмяПоля = СтрЗаменить(ИмяПоля, ".Owner", ".Владелец");
	ИмяПоля = СтрЗаменить(ИмяПоля, ".Code", ".Код");
	ИмяПоля = СтрЗаменить(ИмяПоля, ".Parent", ".Родитель");
	ИмяПоля = СтрЗаменить(ИмяПоля, ".Predefined", ".Предопределенный");
	ИмяПоля = СтрЗаменить(ИмяПоля, ".IsFolder", ".ЭтоГруппа");
	ИмяПоля = СтрЗаменить(ИмяПоля, ".Description", ".Наименование");
	
	Возврат ИмяПоля;
	
КонецФункции // ПолучитьИмяПоляВШаблоне()

////////////////////////////////////////////////////////////////////////////////
// Клиентские и серверные процедуры общего назначения

// Функция формирует текст в формате, необходимом для выдачи сообщений по табличной части.
//
// Параметры:
//  ИмяТЧ - Строка. Имя табличной части.
//  НомерСтроки - Число. Номер строки табличной части.
//  ИмяРеквизита - Строка. Имя реквизита.
//
// Возвращаемое значение:
//  Строка.
//
Функция ПолучитьТекстДляВыдачиСообщенийПоСтрокеТЧ(ИмяТЧ, НомерСтроки, ИмяРеквизита) Экспорт

	Возврат ИмяТЧ + "[" + Формат(НомерСтроки - 1, "ЧН=0; ЧГ=0") + "]." + ИмяРеквизита;

КонецФункции // ПолучитьТекстДляВыдачиСообщенийПоСтрокеТЧ()

//Процедуры подготовки исходных данных при проведении документов

// Обрабатывает таблицу значений: заполняет незаполненные колонки с НоменклатурнойГруппой и СтатьейЗатрат по данным других реквизитов
// Параметры:
// 	ТаблицаДокумента - обрабатываемая таблица значений
// 	СтруктураОбрабатываемыхКолонок - Структура, содержит обрабатываемые колонки
// 		Ключ - имя колонки которую необходимо заполнить
// 		Значение - имя колонки являющейся источником для заполнения
// 	СтруктураЗависимыхКолонок - Структура - содержит сведения о колонках, необходимость заполнения которых зависит от заполнения других колонок 
// 		Ключ - имя зависимой колонки
// 		Значение - имя колонки, от заполнения которой зависит нужно ли заполнять зависимую колонку
//
Процедура ЗаполнитьНоменклатурнуюГруппуИСтатьюЗатратВТаблицеДокумента(ТаблицаДокумента, СтруктураОбрабатываемыхКолонок, СтруктураЗависимыхКолонок = Неопределено) Экспорт
	
	Если СтруктураЗависимыхКолонок = Неопределено Тогда
		СтруктураЗависимыхКолонок = Новый Структура();
	КонецЕсли;
	
	Для Каждого СтрокаТаблицыЗначений ИЗ ТаблицаДокумента Цикл
		Для Каждого Колонка ИЗ СтруктураОбрабатываемыхКолонок Цикл
			
			ЗаполняемаяКолонка = Колонка.Ключ;
			КолонкаИсточникЗаполнения = Колонка.Значение;
			
			Если ЗначениеЗаполнено(СтрокаТаблицыЗначений[ЗаполняемаяКолонка]) Тогда
				Продолжить;
			КонецЕсли;
			
			// Если в колонке, от которой зависит текущая, заполнено значение, 
			// то текущую колонку заполнять не требуется - в ней пустое значение является правильным
			Если СтруктураЗависимыхКолонок.Свойство(ЗаполняемаяКолонка)
				И ЗначениеЗаполнено(СтрокаТаблицыЗначений[СтруктураЗависимыхКолонок[ЗаполняемаяКолонка]]) Тогда
				Продолжить;
			КонецЕсли;
			
			СтрокаТаблицыЗначений[ЗаполняемаяКолонка] = СтрокаТаблицыЗначений[КолонкаИсточникЗаполнения];
			
		КонецЦикла;
	КонецЦикла;
	
КонецПроцедуры

//Процедура добавляет в СтруктуруШапкиДокумента сведения о счетах расчетов по умолчанию, если эти данные не заполнились из шапки документа
Процедура ДобавитьВСтруктуруШапкиСведенияОСчетахРасчетов(ДокументОбъект, СтруктураШапкиДокумента) Экспорт
	Если НЕ СтруктураШапкиДокумента.ОтражатьВБухгалтерскомУчете Тогда
		Возврат;
	КонецЕсли;
	//Получим структуру счетов учета расчетов: 
	//	ключ - имя реквизита шапки, значение - счет учета расчетов по умолчанию
	СтруктураСчетовУчетаРасчетов = ДокументОбъект.ЗаполнитьСтруктуруСчетовУчетаШапки();
	//Заполним недостающие свойства в структуре шапки документа 
	Для Каждого СчетУчетаРасчетов Из СтруктураСчетовУчетаРасчетов Цикл
		Если НЕ ЗначениеЗаполнено(СтруктураШапкиДокумента[СчетУчетаРасчетов.Ключ]) Тогда
			СтруктураШапкиДокумента[СчетУчетаРасчетов.Ключ] = СчетУчетаРасчетов.Значение;
		КонецЕсли;
	КонецЦикла;
КонецПроцедуры

//Процедура добавляет в СтруктуруШапкиДокумента сведения о подразделении организации, 
//Если в шапке документа «Подразделение организации» оказалось незаполненным, то соответствующее свойство структуры заполняется вычисленным по подразделению
//Если Подразделение организации не удалось определить по подразделению, то выдается ошибка
Процедура ДополнитьСтруктуруШапкиПодразделениемОрганизации(Заголовок, СтруктураШапкиДокумента, Отказ) Экспорт
	Если НЕ СтруктураШапкиДокумента.ОтражатьВБухгалтерскомУчете Тогда
		Возврат;
	КонецЕсли;
	
	Если НЕ ЗначениеЗаполнено(СтруктураШапкиДокумента.ПодразделениеОрганизации) Тогда
		СтруктураШапкиДокумента.ПодразделениеОрганизации = РаботаСДиалогамиСервер.ПодразделениеОрганизации(СтруктураШапкиДокумента.Подразделение, СтруктураШапкиДокумента.Организация);
	КонецЕсли;	
	
	Если НЕ ЗначениеЗаполнено(СтруктураШапкиДокумента.ПодразделениеОрганизации) Тогда
		ОбщегоНазначения.СообщитьОбОшибке(Нстр("ru = 'Не заполнено подразделение организации'"), Отказ, Заголовок);
	КонецЕсли;	
КонецПроцедуры//ДополнитьСтруктуруШапкиПодразделениемОрганизации()

//Процедура добавляет в ТаблицуДокумента сведения о подразделении организации, 
//Если в табличной части документа «Подразделение организации» оказалось незаполненным, то соответствующая колонка таблицы заполняется вычисленным значением по подразделению
//Окончательная проверка заполненности подразделения организации выполняется в модуле документа
Процедура ДополнитьТаблицуДокументаПодразделениемОрганизации(СтруктураШапкиДокумента, ТаблицаДокумента) Экспорт
	Если НЕ СтруктураШапкиДокумента.ОтражатьВБухгалтерскомУчете Тогда
		Возврат;
	КонецЕсли;	
	
	Если ТаблицаДокумента.Колонки.Найти("Подразделение") <> Неопределено Тогда
		ИмяКолонкиПодразделение = "Подразделение";
		ИмяКолонкиПодразделениеОрганизации = "ПодразделениеОрганизации";
	ИначеЕсли ТаблицаДокумента.Колонки.Найти("ПодразделениеПолучатель") <> Неопределено Тогда
		ИмяКолонкиПодразделение = "ПодразделениеПолучатель";
		ИмяКолонкиПодразделениеОрганизации = "ПодразделениеОрганизацииПолучатель";
	Иначе
		Возврат;//Нет колонки с подразделением
	КонецЕсли;	
	
	Для Каждого ТекущаяСтрока Из ТаблицаДокумента Цикл
		Если НЕ ЗначениеЗаполнено(ТекущаяСтрока[ИмяКолонкиПодразделениеОрганизации]) Тогда
			ТекущаяСтрока[ИмяКолонкиПодразделениеОрганизации] = РаботаСДиалогамиСервер.ПодразделениеОрганизации(ТекущаяСтрока[ИмяКолонкиПодразделение], СтруктураШапкиДокумента.Организация);
		КонецЕсли;	
	КонецЦикла;	
КонецПроцедуры

// Проверяет правильность заполнения шапки документа по структуре шапки документа.
// Если какой-то из реквизитов шапки, влияющий на проведение, не заполнен или
// заполнен не корректно, то выставляется флаг отказа в проведении.
// Проверяется также правильность заполнения реквизитов ссылочных полей документа.
// Проверка выполняется по объекту и по выборке из результата запроса по шапке.
//
// Параметры: 
//  ДокументОбъект             - объект проводимого документа, 
//  СтруктураОбязательныхПолей - структура, содержащая имена полей, которые собственно и надо проверить.
//  СтруктураШапкиДокумента    - структура шапки проводимого документа
//  Отказ                      - флаг отказа в проведении.
//  Заголовок                  - строка, заголовок сообщения об ошибке проведения.
//
Процедура ПроверитьЗаполнениеВычисляемыхРеквизитовШапки(ДокументОбъект, СтруктураОбязательныхПолей, СтруктураШапкиДокумента, Отказ, Заголовок) Экспорт
	
	МетаданныеРеквизиты = ДокументОбъект.Метаданные().Реквизиты;
	
	Для каждого КлючЗначение Из СтруктураОбязательныхПолей Цикл

		Значение = СтруктураШапкиДокумента[КлючЗначение.Ключ];
		Если НЕ ЗначениеЗаполнено(Значение) Тогда

			Если НЕ ЗначениеЗаполнено(КлючЗначение.Значение) Тогда
				ПредставлениеРеквизита = МетаданныеРеквизиты[КлючЗначение.Ключ].Представление();
				СтрокаСообщения = "Не заполнен """ + СокрЛП(ПредставлениеРеквизита) + """";
			Иначе
				СтрокаСообщения = КлючЗначение.Значение;
			КонецЕсли;
			ОбщегоНазначения.СообщитьОбОшибке(СтрокаСообщения, Отказ, Заголовок);

		КонецЕсли;

	КонецЦикла;

КонецПроцедуры // ПроверитьЗаполнениеШапкиДокумента()