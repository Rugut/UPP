// Формирование полной копии отбора
//
// Параметры
//  Отбор  – Отбор – Исходный отбор, копию которого необходимо получить
//
// Возвращаемое значение:
//   ТаблицаЗначений   – Копия исходного отбора
//
Функция ПолучитьКопиюОтбораВТЗ(Отбор) Экспорт

	Копия = Новый ТаблицаЗначений;
	Копия.Колонки.Добавить("ВидСравнения");
	Копия.Колонки.Добавить("Значение");
	Копия.Колонки.Добавить("ЗначениеПо");
	Копия.Колонки.Добавить("ЗначениеС");
	Копия.Колонки.Добавить("Имя");
	Копия.Колонки.Добавить("Использование");
	Копия.Колонки.Добавить("Представление");
	Копия.Колонки.Добавить("ПутьКДанным");
	Копия.Колонки.Добавить("ТипЗначения");
	
	Для каждого ЭлементОтбора Из Отбор Цикл
	
		//стр = Копия.Добавить();
		ЗаполнитьЗначенияСвойств(Копия.Добавить(), ЭлементОтбора);
	
	КонецЦикла;
	
	Возврат Копия;

КонецФункции // ПолучитьКопиюОтбора(Отбор)

// Заполнение отбора значениями из таблицы значений.
// Соответствие полей устанавливается по представлению и типам значений
//
// Параметры
//  Отбор  – Отбор           – Отбор, который требуется заполнить значениями
//  ТЗ     – ТаблицаЗначений – Таблица содержит значения для отбора.
//                             Структура колонок повторяет структуру отбора
//
Процедура УстановитьОтборИзТаблицы(Отбор, ТЗ) Экспорт

	Для каждого ЭлементОтбора Из Отбор Цикл
	
		СтрокаТаблицы = Неопределено;
		Для каждого стр Из ТЗ Цикл
			
			Если ПустаяСтрока(стр.Представление)
				И ПустаяСтрока(стр.ПутьКданным) Тогда
				
				Продолжить;
				
			КонецЕсли;
			
			Если стр.Представление = ЭлементОтбора.Представление
				И стр.ТипЗначения = ЭлементОтбора.ТипЗначения Тогда
				
				СтрокаТаблицы = стр;
				Прервать;
				
			КонецЕсли;
			
		КонецЦикла;
		
		Если СтрокаТаблицы <> Неопределено Тогда
			ЭлементОтбора.ВидСравнения = СтрокаТаблицы.ВидСравнения;
			ЗаполнитьЗначенияСвойств(ЭлементОтбора, СтрокаТаблицы, "Значение, ЗначениеПо, ЗначениеС, Использование");
		КонецЕсли;
	
	КонецЦикла;

КонецПроцедуры // УстановитьОтборИзТаблицы(Отбор, ТЗ)

// Функция возвращает Строку Вида отбора для запроса
// 
// Параметры
// ВыбВидСравнения       - ВидСравнения
// ЗначениеОтбора        - Значение отбора запроса
// СтрокаАргументаОтбора - Строка, Аргумент запроса, т.е. то что должно быть написано до вида сревнения
// ЗначениеОтбораНач     - Произвольный, значение отбора для видов сравнения, у которых необходимо указывать два значения, начальное значение
// ЗначениеОтбораКон     - Произвольный, значение отбора для видов сравнения, у которых необходимо указывать два значения, конечное значение
// 
// Возвращаемое значение 
//  Строка для запроса
//
Функция ПолучитьСтрокуОтбора(ВыбВидСравнения, ЗначениеОтбора, СтрокаПоляОтбора, ЗначениеОтбораС = Неопределено, ЗначениеОтбораПо = Неопределено, СамоЗначение = Неопределено, СамоЗначениеС = Неопределено, СамоЗначениеПо = Неопределено) Экспорт

	СтрокаВозврата = "";
	Если ВыбВидСравнения = ВидСравнения.Равно Тогда
		СтрокаВозврата = СтрокаПоляОтбора + Строка(" = " + ЗначениеОтбора);
	ИначеЕсли ВыбВидСравнения = ВидСравнения.НеРавно Тогда
		СтрокаВозврата = СтрокаПоляОтбора + Строка(" <> " + ЗначениеОтбора);
	ИначеЕсли ВыбВидСравнения = ВидСравнения.ВСписке Тогда
		СтрокаВозврата = СтрокаПоляОтбора + Строка(" В (" + ЗначениеОтбора+")");
	ИначеЕсли ВыбВидСравнения = ВидСравнения.ВСпискеПоИерархии ИЛИ ВыбВидСравнения = ВидСравнения.ВИерархии Тогда
		СтрокаВозврата = СтрокаПоляОтбора + Строка(" В ИЕРАРХИИ(" + ЗначениеОтбора+")");
	ИначеЕсли ВыбВидСравнения = ВидСравнения.НеВСписке Тогда
		СтрокаВозврата = СтрокаПоляОтбора + Строка(" НЕ В (" + ЗначениеОтбора+")");
	ИначеЕсли ВыбВидСравнения = ВидСравнения.НеВСпискеПоИерархии ИЛИ ВыбВидСравнения = ВидСравнения.НеВИерархии Тогда
		СтрокаВозврата = СтрокаПоляОтбора + Строка(" НЕ В ИЕРАРХИИ(" + ЗначениеОтбора+")");
	ИначеЕсли ВыбВидСравнения = ВидСравнения.Больше Тогда
		СтрокаВозврата = СтрокаПоляОтбора + Строка(" > " + ЗначениеОтбора);
	ИначеЕсли ВыбВидСравнения = ВидСравнения.БольшеИлиРавно Тогда
		СтрокаВозврата = СтрокаПоляОтбора + Строка(" >= " + ЗначениеОтбора);
	ИначеЕсли ВыбВидСравнения = ВидСравнения.Меньше Тогда
		Если НЕ (ТипЗнч(СамоЗначение) = Тип("Дата") И НЕ ЗначениеЗаполнено(СамоЗначение)) Тогда
			СтрокаВозврата = СтрокаПоляОтбора + Строка(" < " + ЗначениеОтбора);
		КонецЕсли; 
	ИначеЕсли ВыбВидСравнения = ВидСравнения.МеньшеИлиРавно Тогда
		Если НЕ (ТипЗнч(СамоЗначение) = Тип("Дата") И НЕ ЗначениеЗаполнено(СамоЗначение)) Тогда
			СтрокаВозврата = СтрокаПоляОтбора + Строка(" <= " + ЗначениеОтбора);
		КонецЕсли; 
	ИначеЕсли ВыбВидСравнения = ВидСравнения.Интервал Тогда
		Если ТипЗнч(СамоЗначениеПо) = Тип("Дата") И НЕ ЗначениеЗаполнено(СамоЗначениеПо) Тогда
			СтрокаВозврата = "(" + СтрокаПоляОтбора + Строка(" > " + ЗначениеОтбораС) + ")";
		Иначе
			СтрокаВозврата = "(" + СтрокаПоляОтбора + Строка(" > " + ЗначениеОтбораС) + " И " + СтрокаПоляОтбора + Строка(" < " + ЗначениеОтбораПо) + ")";
		КонецЕсли;
	ИначеЕсли ВыбВидСравнения = ВидСравнения.ИнтервалВключаяГраницы Тогда
		Если ТипЗнч(СамоЗначениеПо) = Тип("Дата") И НЕ ЗначениеЗаполнено(СамоЗначениеПо) Тогда
			СтрокаВозврата = "(" + СтрокаПоляОтбора + Строка(" >= " + ЗначениеОтбораС) + ")";
		Иначе
			СтрокаВозврата = "(" + СтрокаПоляОтбора + Строка(" >= " + ЗначениеОтбораС) + " И " + СтрокаПоляОтбора + Строка(" <= " + ЗначениеОтбораПо) + ")";
		КонецЕсли;
	ИначеЕсли ВыбВидСравнения = ВидСравнения.ИнтервалВключаяНачало Тогда
		Если ТипЗнч(СамоЗначениеПо) = Тип("Дата") И НЕ ЗначениеЗаполнено(СамоЗначениеПо) Тогда
			СтрокаВозврата = "(" + СтрокаПоляОтбора + Строка(" >= " + ЗначениеОтбораС) + ")";
		Иначе
			СтрокаВозврата = "(" + СтрокаПоляОтбора + Строка(" >= " + ЗначениеОтбораС) + " И " + СтрокаПоляОтбора + Строка(" < " + ЗначениеОтбораПо) + ")";
		КонецЕсли;
	ИначеЕсли ВыбВидСравнения = ВидСравнения.ИнтервалВключаяОкончание Тогда
		Если ТипЗнч(СамоЗначениеПо) = Тип("Дата") И НЕ ЗначениеЗаполнено(СамоЗначениеПо) Тогда
			СтрокаВозврата = "(" + СтрокаПоляОтбора + Строка(" > " + ЗначениеОтбораС) + ")";
		Иначе
			СтрокаВозврата = "(" + СтрокаПоляОтбора + Строка(" > " + ЗначениеОтбораС) + " И " + СтрокаПоляОтбора + Строка(" <= " + ЗначениеОтбораПо) + ")";
		КонецЕсли;
	ИначеЕсли ВыбВидСравнения = ВидСравнения.Содержит Тогда
		СтрокаВозврата = СтрокаПоляОтбора + Строка(" ПОДОБНО " + ЗначениеОтбора);
	ИначеЕсли ВыбВидСравнения = ВидСравнения.НеСодержит Тогда
		СтрокаВозврата = "НЕ (" + СтрокаПоляОтбора + Строка(" ПОДОБНО " + ЗначениеОтбора + ")");
	КонецЕсли;

	Возврат СтрокаВозврата;
	
КонецФункции // ПолучитьСтрокуОтбора()

// Функция анализирует измерения Построителя Отчета и ищет среди них повторы
// Конечно же, например, возможен вывод в кросс-таблицу при одном и том же 
// измерении, встречающемся в строках и столбцах, но тогда отчет будет нечитабален
// и непонятно, зачем он вообще нужен.
//
// Параметры
//
//	ПостроительОтчета - Построитель отчета, измерения которого анализируются.
//
Функция ПроверитьПовторыИзмеренийПостроителя(ПостроительОтчета) Экспорт

	Для Инд=0 По ПостроительОтчета.ИзмеренияКолонки.Количество()-1  Цикл
	
		Для Инд2=0 По ПостроительОтчета.ИзмеренияСтроки.Количество()-1  Цикл

			Если ПостроительОтчета.ИзмеренияКолонки[Инд].ПутьКДанным = ПостроительОтчета.ИзмеренияСтроки[Инд2].ПутьКДанным Тогда

				#Если Клиент тогда
					Предупреждение("Повторяющаяся группировка " + ПостроительОтчета.ИзмеренияКолонки[Инд].Представление +"."+ Символы.ПС+
					"Нельзя использовать одинаковые поля группировки в строках и в колонках!", 30);
				#Иначе
					Сообщить("Повторяющаяся группировка " + ПостроительОтчета.ИзмеренияКолонки[Инд].Представление +"."+ Символы.ПС+
					"Нельзя использовать одинаковые поля группировки в строках и в колонках!");
				#КонецЕсли
				Возврат Ложь;
			
			КонецЕсли; 
		КонецЦикла;
	
	КонецЦикла;


	СписокЗначений = Новый СписокЗначений;
	
	Для Инд=0 По ПостроительОтчета.ИзмеренияСтроки.Количество()-1  Цикл
		
		Если СписокЗначений.НайтиПоЗначению(ПостроительОтчета.ИзмеренияСтроки[Инд].ПутьКДанным) = Неопределено Тогда
			СписокЗначений.Добавить(ПостроительОтчета.ИзмеренияСтроки[Инд].ПутьКДанным);
		Иначе
			#Если Клиент тогда
				Предупреждение("Повторяющаяся группировка " + ПостроительОтчета.ИзмеренияСтроки[Инд].Представление +"."+ Символы.ПС+
				"Нельзя использовать одинаковые поля группировки строк!", 30);
			#Иначе
				Сообщить("Повторяющаяся группировка " + ПостроительОтчета.ИзмеренияСтроки[Инд].Представление +"."+ Символы.ПС+
				"Нельзя использовать одинаковые поля группировки строк!");
			#КонецЕсли
			Возврат Ложь;
			
		КонецЕсли;

		// Если добавлялись одни и те же поля в строки и в колонки, то 
		//  у них будет неправильное автогенеренное имя, оканчивающееся на число
		ИмяИзмерения = ПостроительОтчета.ИзмеренияСтроки[Инд].Имя;

		ПоследнийСимвол = Сред(ИмяИзмерения, СтрДлина(ИмяИзмерения));

		Если ПоследнийСимвол = "1"
			ИЛИ ПоследнийСимвол = "2" 
			ИЛИ ПоследнийСимвол = "3" 
			ИЛИ ПоследнийСимвол = "4" 
			ИЛИ ПоследнийСимвол = "5" 
			ИЛИ ПоследнийСимвол = "6" 
			ИЛИ ПоследнийСимвол = "7" 
			ИЛИ ПоследнийСимвол = "8" 
			ИЛИ ПоследнийСимвол = "9" 
			ИЛИ ПоследнийСимвол = "0" Тогда
			
			// Удалим старое измерение и добавим новое
            //Применение данного способа обусловлено тем, что методы "Вставить" и "Сдвинуть" не могут применяться
			//	для построителя отчета в 8.0.6.3
			ВремСписок = Новый СписокЗначений;
			ВремСписокИмяИзмерения = Новый СписокЗначений;
			ВремСписокТипИзмерения = Новый СписокЗначений;
			
			Пока ПостроительОтчета.ИзмеренияСтроки.КОличество() - 1 >= Инд Цикл

				СтрПутьКДанным = ПостроительОтчета.ИзмеренияСтроки[Инд].ПутьКДанным;
				ВремСписок.Добавить(ПостроительОтчета.ИзмеренияСтроки[Инд].ПутьКДанным);

				Если ИмяИзмерения = ПостроительОтчета.ИзмеренияСтроки[Инд].Имя Тогда //первая итерация

					ВремСписокИмяИзмерения.Добавить(Лев(ПостроительОтчета.ИзмеренияСтроки[Инд].Имя, СтрДлина(ИмяИзмерения) - 1));

				Иначе

					ВремСписокИмяИзмерения.Добавить(ПостроительОтчета.ИзмеренияСтроки[Инд].Имя);

				КонецЕсли;

				ВремСписокТипИзмерения.Добавить(ПостроительОтчета.ИзмеренияСтроки[Инд].ТипИзмерения);
				ПостроительОтчета.ИзмеренияСтроки.Удалить(ПостроительОтчета.ИзмеренияСтроки[Инд]);

			КОнецЦикла;
			Для Инд = 0 по ВремСписок.Количество() - 1 Цикл
				ПостроительОтчета.ИзмеренияСтроки.Добавить(ВремСписок[Инд].Значение, ВремСписокИмяИзмерения[Инд].Значение, ВремСписокТипИзмерения[Инд].Значение);
			КОнецЦикла;
		КонецЕсли;
		
	КонецЦикла;

	СписокЗначений = Новый СписокЗначений;
	
	Для Инд=0 По ПостроительОтчета.ИзмеренияКолонки.Количество()-1  Цикл
		
		Если СписокЗначений.НайтиПоЗначению(ПостроительОтчета.ИзмеренияКолонки[Инд].ПутьКДанным) = Неопределено Тогда
			СписокЗначений.Добавить(ПостроительОтчета.ИзмеренияКолонки[Инд].ПутьКДанным);
		Иначе
		#Если Клиент Тогда
			Предупреждение("Повторяющаяся группировка " + ПостроительОтчета.ИзмеренияКолонки[Инд].Представление +"."+ Символы.ПС+
			"Нельзя использовать одинаковые поля группировки колонок!", 30);
		#Иначе
			Сообщить("Повторяющаяся группировка " + ПостроительОтчета.ИзмеренияКолонки[Инд].Представление +"."+ Символы.ПС+
			"Нельзя использовать одинаковые поля группировки колонок!");
		#КонецЕсли
			Возврат Ложь;
			
		КонецЕсли;

		// Если добавлялись одни и те же поля в строки и в колонки, то 
		// у них будет неправильное автогенеренное имя, оканчивающееся на число
		ИмяИзмерения = ПостроительОтчета.ИзмеренияКолонки[Инд].Имя;

		ПоследнийСимвол = Сред(ИмяИзмерения, СтрДлина(ИмяИзмерения));

		Если ПоследнийСимвол = "1"
			ИЛИ ПоследнийСимвол = "2" 
			ИЛИ ПоследнийСимвол = "3" 
			ИЛИ ПоследнийСимвол = "4" 
			ИЛИ ПоследнийСимвол = "5" 
			ИЛИ ПоследнийСимвол = "6" 
			ИЛИ ПоследнийСимвол = "7" 
			ИЛИ ПоследнийСимвол = "8" 
			ИЛИ ПоследнийСимвол = "9" 
			ИЛИ ПоследнийСимвол = "0" Тогда

			// Удалим старое измерение и добавим новое

			ВремСписок = Новый СписокЗначений;
			ВремСписокИмяИзмерения = Новый СписокЗначений;
			ВремСписокТипИзмерения = Новый СписокЗначений;
			
			Пока ПостроительОтчета.ИзмеренияКолонки.КОличество() - 1 >= Инд Цикл
				СтрПутьКДанным = ПостроительОтчета.ИзмеренияКолонки[Инд].ПутьКДанным;
				ВремСписок.Добавить(ПостроительОтчета.ИзмеренияКолонки[Инд].ПутьКДанным);

				Если ИмяИзмерения = ПостроительОтчета.ИзмеренияКолонки[Инд].Имя Тогда //первая итерация

					ВремСписокИмяИзмерения.Добавить(Лев(ПостроительОтчета.ИзмеренияКолонки[Инд].Имя, СтрДлина(ИмяИзмерения) - 1));

				Иначе

					ВремСписокИмяИзмерения.Добавить(ПостроительОтчета.ИзмеренияКолонки[Инд].Имя);

				КонецЕсли;

				ВремСписокТипИзмерения.Добавить(ПостроительОтчета.ИзмеренияКолонки[Инд].ТипИзмерения);
				ПостроительОтчета.ИзмеренияКолонки.Удалить(ПостроительОтчета.ИзмеренияКолонки[Инд]);
			КОнецЦикла;
			Для Инд = 0 по ВремСписок.Количество() - 1 Цикл
				ПостроительОтчета.ИзмеренияКолонки.Добавить(ВремСписок[Инд].Значение, ВремСписокИмяИзмерения[Инд].Значение, ВремСписокТипИзмерения[Инд].Значение);
			КОнецЦикла;
			
		КонецЕсли;
		
	КонецЦикла;

КонецФункции // ПроверитьПовторыИзмеренийПостроителя()

// Процедура обрабатывает Порядок Построителя отчета и удаляет из него те элементы порядка,
// которые не связаны с выбранными полями или измерениями.
// Это делается для несоздания ложного впечатления о том, что что-то как-то отсортировали
// в одних случаях, и для избежания ошибки времени выполнения при выполнении запроса
// в других случаях
//
// Параметры:
//	ПостроительОтчета - ПостроительОтчета, Порядок которого надо обработать
//
Процедура ПроверитьПорядокПостроителяОтчета(ПостроительОтчета) Экспорт

	КоличествоЭлементовПорядка = ПостроительОтчета.Порядок.Количество();

	Конструктор = Новый КонструкторЗапроса;

	ПопыткаПровалилась = Ложь;
	
	Если КоличествоЭлементовПорядка > 0 Тогда
		Попытка
			Конструктор.Текст = ПостроительОтчета.ПолучитьЗапрос().Текст;
		Исключение
			ПопыткаПровалилась = Истина;
		КонецПопытки;
	КонецЕсли;

	КопияПостроителя = Новый ПостроительОтчета;
	
	// Запрос оказался синтаксически неправильным...
	Попытка
		КопияПостроителя.Текст = ПостроительОтчета.Текст;// <- Здесь может произойти ошибка при исходно неправильном тексте запроса Построителя
	Исключение
		Возврат; // Ничего не делать.
	КонецПопытки;
		
	КопияПостроителя.УстановитьНастройки(ПостроительОтчета.ПолучитьНастройки(Истина, Ложь, Истина, Истина), Истина, Ложь, Истина, Истина);

	Если ПопыткаПровалилась Тогда
	
		// Побочным эффектом этой процедуры может послужить прочистка всего Порядка у
		// построителя отчета запросом, который прошел первую проверку, но имеет поля упорядочивания,
		// которые отсутствуют в выбранных полях

		Для Инд = 0 по КоличествоЭлементовПорядка - 1 Цикл
			// Это мы делаем для того, чтобы можно было бездумно удалять и переходить к следующему - 
			// обход с конца.
			ЭлементПорядка = ПостроительОтчета.Порядок[КоличествоЭлементовПорядка - 1 - Инд];
			КопияПостроителя.Порядок.Очистить();
			КопияПостроителя.Порядок.Добавить(ЭлементПорядка.ПутьКДанным);
			Попытка
				Конструктор.Текст = КопияПостроителя.ПолучитьЗапрос().Текст;
			Исключение
				ПостроительОтчета.Порядок.Удалить(КоличествоЭлементовПорядка - 1 - Инд);
			КонецПопытки;
		КонецЦикла;
		
	КонецЕсли; 

	// Теперь проверим порядки на то, что если в выбранных полях есть регистратор,
	// то для корректной работы необходимо установить порядок по периоду и самому регитстратору
	
	Если ПостроительОтчета.ВыбранныеПоля.Найти("Регистратор") <> Неопределено Тогда
		
		ЕстьРегистратор = Ложь;
		ЕстьПериод = Ложь;
		
		КоличествоЭлементовПорядка = ПостроительОтчета.Порядок.Количество();
		
		Для Инд = 0 по КоличествоЭлементовПорядка - 1 Цикл
			ЭлементПорядка = ПостроительОтчета.Порядок[КоличествоЭлементовПорядка - 1 - Инд];
			Если ЭлементПорядка.ПутьКДанным = "Регистратор" Тогда
				ЕстьРегистратор = Истина;
			КонецЕсли; 
			Если ЭлементПорядка.ПутьКДанным = "Период" Тогда
				ЕстьПериод = Истина;
			КонецЕсли; 
		КонецЦикла;
		
		Если КопияПостроителя.ДоступныеПоля.Найти("Период") <> Неопределено Тогда
			Если НЕ ЕстьПериод Тогда
				КопияПостроителя.Порядок.Очистить();
				Попытка
					КопияПостроителя.Порядок.Добавить("Период");
					Если КопияПостроителя.ВыбранныеПоля.Найти("Период") = Неопределено Тогда
						КопияПостроителя.ВыбранныеПоля.Добавить("Период");
					КонецЕсли; 
					КопияПостроителя.ВыбранныеПоля.Добавить("Период");
					Попытка
						Конструктор.Текст = КопияПостроителя.ПолучитьЗапрос().Текст;
						ПостроительОтчета.Порядок.Добавить("Период");
						Если ПостроительОтчета.ВыбранныеПоля.Найти("Период") = Неопределено Тогда
							ПостроительОтчета.ВыбранныеПоля.Вставить("Период",, 0);
						КонецЕсли; 
					Исключение
						// Ничего добавлять не будем
					КонецПопытки;
				Исключение
				КонецПопытки;
			Иначе
				Если ПостроительОтчета.ВыбранныеПоля.Найти("Период") = Неопределено Тогда
					Попытка
						ПостроительОтчета.ВыбранныеПоля.Вставить("Период",, 0);
					Исключение
					КонецПопытки;
				КонецЕсли; 
			КонецЕсли;
		КонецЕсли; 
		
		Если КопияПостроителя.ДоступныеПоля.Найти("Регистратор") <> Неопределено Тогда
			Если НЕ ЕстьРегистратор Тогда
				КопияПостроителя.Порядок.Очистить();
				Попытка
					КопияПостроителя.Порядок.Добавить("Регистратор");
					Если КопияПостроителя.ВыбранныеПоля.Найти("Регистратор") = Неопределено Тогда
						КопияПостроителя.ВыбранныеПоля.Добавить("Регистратор");
					КонецЕсли; 
					Попытка
						Конструктор.Текст = КопияПостроителя.ПолучитьЗапрос().Текст;
						ПостроительОтчета.Порядок.Добавить("Регистратор");
					Исключение
						// Ничего добавлять не будем
					КонецПопытки;
				Исключение
				КонецПопытки;
			КонецЕсли;
		КонецЕсли; 
		
	КонецЕсли; 
	
КонецПроцедуры // ПроверитьПорядокПостроителяОтчета()

// Удаляет автоматически добавляемые Построителем при инициализации дополнительные поля с измерениями
//
// Параметры:
//	нет
//
Процедура ОчиститьДополнительныеПоляПостроителя(ПостроительОтчета) Экспорт

	Сч=0;
	Пока Сч<ПостроительОтчета.ВыбранныеПоля.Количество() Цикл

		Если ПостроительОтчета.ИзмеренияСтроки.Найти(ПостроительОтчета.ВыбранныеПоля[Сч].Имя)<>Неопределено Тогда

			ПостроительОтчета.ВыбранныеПоля.Удалить(ПостроительОтчета.ВыбранныеПоля[Сч]);

		ИначеЕсли ПостроительОтчета.ИзмеренияКолонки.Найти(ПостроительОтчета.ВыбранныеПоля[Сч].Имя)<>Неопределено Тогда

			ПостроительОтчета.ВыбранныеПоля.Удалить(ПостроительОтчета.ВыбранныеПоля[Сч]);
			
		Иначе

			Сч=Сч+1;

		КонецЕсли;
	КонецЦикла;

КонецПроцедуры // ОчиститьДополнительныеПоляПостроителя()

// Процедура добавляет показатель в выбранные поля. Вызывается перед выполнением запроса.
// 
// Параметры:
//	ИмяПоляПостроителя - строка, идентификатор поля построителя
//	ПостроительОтчета  - Построитель отчета
//
Процедура ОбработкаПоказателейДобавитьВВыбранныеПоля(ИмяПоляПостроителя, ПостроительОтчета) Экспорт
	
	ПостроительОтчета.ДоступныеПоля.Найти(ИмяПоляПостроителя).Поле = Истина;
	
	ВыбранноеПолеПоказателя = ПостроительОтчета.ВыбранныеПоля.Найти(ИмяПоляПостроителя);
	
	Если ВыбранноеПолеПоказателя = Неопределено Тогда
		ВыбранноеПолеПоказателя = ПостроительОтчета.ВыбранныеПоля.Добавить(ИмяПоляПостроителя, ИмяПоляПостроителя);
	КонецЕсли;
	
	ВыбранноеПолеПоказателя.Представление = ПостроительОтчета.ДоступныеПоля.Найти(ИмяПоляПостроителя).Представление;
	
КонецПроцедуры // ОбработкаПоказателейДобавитьВВыбранныеПоля()

// Процедура запоняет данными отбор из структуры.
//
// Параметры
//  Отбор - Отбор
//  СтруктураОтбора - Структура
//
Процедура ЗаполнитьОтборИзСтруктуры(Отбор, СтруктураОтбора) Экспорт

	Если ТипЗнч(СтруктураОтбора) = Тип("Структура") Тогда
		Для каждого ЭлементСтруктуры Из СтруктураОтбора Цикл
			ЗначениеЭлементаСтруктуры = ЭлементСтруктуры.Значение;
			ЭлементОтбора = Неопределено;
			Если НЕ ПустаяСтрока(ЗначениеЭлементаСтруктуры.Имя) Тогда
				ЭлементОтбора = Отбор.Найти(ЗначениеЭлементаСтруктуры.Имя);
			КонецЕсли; 
			Если ЭлементОтбора = Неопределено Тогда
				ЭлементОтбора = Отбор.Добавить(ЗначениеЭлементаСтруктуры.ПутьКДанным, ЗначениеЭлементаСтруктуры.Имя);
			КонецЕсли;
			Для каждого РеквизитОтбора Из ЗначениеЭлементаСтруктуры Цикл
				Попытка
					ЭлементОтбора[РеквизитОтбора.Ключ] = РеквизитОтбора.Значение;
				Исключение
				КонецПопытки;
			КонецЦикла; 
		КонецЦикла; 
	КонецЕсли; 

КонецПроцедуры // ЗаполнитьОтборИзСтруктуры()

// Процедура запоняет данными отбор из таблицы значений.
//
// Параметры
//  Отбор - Отбор
//  Таблица - ТаблицаЗначений, структурой колонок полностью повторяющая структуру отбора
//
Процедура ЗаполнитьОтборИзТаблицыЗначений(Отбор, Таблица, Знач ВызыватьИсключениеПриОшибкеУстановки = Истина) Экспорт

	Если ТипЗнч(Таблица) = Тип("ТаблицаЗначений") Тогда
		
		Для каждого СтрокаТаблицы Из Таблица Цикл
			
			ЭлементОтбора = Неопределено;
			Если НЕ ПустаяСтрока(СтрокаТаблицы.Имя) Тогда
				ЭлементОтбора = Отбор.Найти(СтрокаТаблицы.Имя);
			КонецЕсли;
			
			Попытка
				
				Если ЭлементОтбора = Неопределено Тогда
				
					ЭлементОтбора = Отбор.Добавить(СтрокаТаблицы.ПутьКДанным, СтрокаТаблицы.Имя);
					
				КонецЕсли;
				
				ЭлементОтбора.ВидСравнения = СтрокаТаблицы.ВидСравнения;
				ЭлементОтбора.Использование = СтрокаТаблицы.Использование;
				
				Если СтрокаТаблицы.Значение <> Null Тогда
					ЭлементОтбора.Значение = СтрокаТаблицы.Значение;
				КонецЕсли;
				Если СтрокаТаблицы.ЗначениеС <> Null Тогда
					ЭлементОтбора.ЗначениеС = СтрокаТаблицы.ЗначениеС;
				КонецЕсли;
				Если СтрокаТаблицы.ЗначениеПо <> Null Тогда
					ЭлементОтбора.ЗначениеПо = СтрокаТаблицы.ЗначениеПо;
				КонецЕсли;
				
			Исключение
				
				Если ВызыватьИсключениеПриОшибкеУстановки Тогда
					
					ВызватьИсключение ОписаниеОшибки();
					
				Иначе
					
					Продолжить;
					
				КонецЕсли;
				
			КонецПопытки;
			
		КонецЦикла;
		
	КонецЕсли;

КонецПроцедуры

// Процедура заполнения начальных настроек по метаданным для универсального отчета или отчета на базе универсального
Процедура ЗаполнитьНачальныеНастройкиПоМетаданнымРегистра(СтруктураПредставлениеПолей, МассивОтбора, Контекст, ТипОтчета) Экспорт

	ИмяРегистра = Контекст.ИмяРегистра;
	ПостроительОтчета = Контекст.ПостроительОтчета;

	МетаданныеРегистра = Метаданные.РегистрыНакопления.Найти(ИмяРегистра);
	Если МетаданныеРегистра = Неопределено Тогда
	
		Возврат;
	
	КонецЕсли; 

	ТекстПоляЗапроса = "";
	ТекстПоляИтоговЗапроса = "";
	ТекстПоляПоказатели = "";
	ТекстПоляИтогов = "";
	ТекстВыводимыеПоляЗапроса = "";
	ТекстПоляУпорядочивания = "";
	ТекстПоляИзмерений = "";

	ТекстВыводимыеПоляПериоды = "";
	ТекстПоляИтоговПериоды = "";

	ТекстИсточникиСведений ="";
	ТекстПоляКатегорий = "";
	ТекстПоляГруппировки = "";

	МассивИзмеренийКолонки = Новый Массив;
	
	МассивВыбранныеПоляПоУмолчанию = Новый Массив;
	
	МассивИзмеренияСтрокиПоУмолчанию = Новый Массив;

	Если НЕ ЗначениеЗаполнено(Контекст.мНазваниеОтчета) И Не ПустаяСтрока(ИмяРегистра) Тогда

		Контекст.мНазваниеОтчета = Метаданные.РегистрыНакопления[ИмяРегистра].Представление() + ?(ТипОтчета = "ОстаткиИОбороты", ": остатки и обороты", "");

	КонецЕсли; 

	ВидРегистра = Метаданные.РегистрыНакопления[ИмяРегистра].ВидРегистра;

	Если ВидРегистра = Метаданные.СвойстваОбъектов.ВидРегистраНакопления.Остатки Тогда
		ТипПоляРегистра="Остаток";

		// Отчеты по остаткам - на дату
		
		Если ТипОтчета = "СписокКроссТаблица" Тогда
			Контекст.мРежимВводаПериода = 1;
		КонецЕсли;
		
	ИначеЕсли ВидРегистра = Метаданные.СвойстваОбъектов.ВидРегистраНакопления.Обороты Тогда
		ТипПоляРегистра="Оборот";

		Если ТипОтчета = "СписокКроссТаблица" Тогда 
			Контекст.мРежимВводаПериода = 0;
		КонецЕсли;
		
	КонецЕсли;

	Для Инд = 0 По МетаданныеРегистра.Ресурсы.Количество()-1 Цикл

		Ресурс = МетаданныеРегистра.Ресурсы[Инд];
		
		Если Лев(Ресурс.Имя, 7) = "Удалить" Тогда
			
			Продолжить;
			
		КонецЕсли;
		
		ИмяПоля           = Ресурс.Имя;
		ПредставлениеПоля = Ресурс.Представление();
		ОписаниеПоля      = Ресурс.Имя+"#";
		ВклПоУмолчанию    = Истина;
		ФорматнаяСтрока   = "ЧЦ = " + Формат(Ресурс.Тип.КвалификаторыЧисла.Разрядность, "ЧГ=0") + " ; ЧДЦ = " + Формат(Ресурс.Тип.КвалификаторыЧисла.РазрядностьДробнойЧасти, "ЧГ=0");
		СтрИзмерения      = "";
		СтдВалюта         = "";

		Если ТипОтчета = "СписокКроссТаблица" Тогда
			Контекст.мСтруктураСвязиПоказателейИИзмерений.Вставить(ИмяПоля, Новый Структура(СтрИзмерения));
		КОнецЕсли;

		Если ПустаяСтрока(ОписаниеПоля) Тогда
			ОписаниеПоля = ИмяПоля;
		КонецЕсли;

		Если (ТипОтчета = "СписокКроссТаблица") ИЛИ (ТипОтчета = "Диаграмма") Тогда
			ТекстПоляПоказатели = ТекстПоляПоказатели + ",
			|	" + СтрЗаменить("СУММА("+ОписаниеПоля+")","#", ТипПоляРегистра) + " КАК " + ИмяПоля;

			ТекстПоляИтоговЗапроса = ТекстПоляИтоговЗапроса + ",
			|	СУММА(" + ИмяПоля + ")";

			ТекстПоляУпорядочивания = ТекстПоляУпорядочивания + ",
			|	" + ИмяПоля;

			СтруктураПредставлениеПолей.Вставить(ИмяПоля, ПредставлениеПоля);
		ИначеЕсли ТипОтчета = "ОстаткиИОбороты" Тогда
			ТекстПоляПоказатели = ТекстПоляПоказатели + ",
			|	" + СтрЗаменить("СУММА("+ОписаниеПоля+")","#", "НачальныйОстаток") + " КАК " + ИмяПоля + "НачальныйОстаток,
			|	" + СтрЗаменить("СУММА("+ОписаниеПоля+")","#", "КонечныйОстаток")  + " КАК " + ИмяПоля + "КонечныйОстаток,
			|	" + СтрЗаменить("СУММА("+ОписаниеПоля+")","#", "Приход") 		  + " КАК " + ИмяПоля + "Приход,
			|	" + СтрЗаменить("СУММА("+ОписаниеПоля+")","#", "Расход") 		  + " КАК " + ИмяПоля + "Расход";

			ТекстПоляИтоговЗапроса = ТекстПоляИтоговЗапроса + ",
			|	СУММА(" + ИмяПоля + "НачальныйОстаток),
			|	СУММА(" + ИмяПоля + "КонечныйОстаток),
			|	СУММА(" + ИмяПоля + "Приход),
			|	СУММА(" + ИмяПоля + "Расход)";

			ТекстПоляУпорядочивания = ТекстПоляУпорядочивания + ",
			|	" + ИмяПоля + "НачальныйОстаток,
			|	" + ИмяПоля + "КонечныйОстаток,
			|	" + ИмяПоля + "Приход,
			|	" + ИмяПоля + "Расход";

			СтруктураПредставлениеПолей.Вставить(ИмяПоля+"НачальныйОстаток", ПредставлениеПоля + " нач.ост.");
			СтруктураПредставлениеПолей.Вставить(ИмяПоля+"КонечныйОстаток", ПредставлениеПоля + " кон.ост." );
			СтруктураПредставлениеПолей.Вставить(ИмяПоля+"Приход", ПредставлениеПоля+" приход");
			СтруктураПредставлениеПолей.Вставить(ИмяПоля+"Расход", ПредставлениеПоля+" расход");
		КонецЕсли;
		// Показатели заносятся в специальную таблицу 
		СтрПоказатели = Контекст.мТаблицаПоказатели.Добавить();
		СтрПоказатели.ИмяПоля           = ИмяПоля;
		СтрПоказатели.ПредставлениеПоля = ПредставлениеПоля;
		СтрПоказатели.ФорматнаяСтрока   = ФорматнаяСтрока;

		// ... и добавляются в список
		Показатель = Контекст.Показатели.Добавить();
		Показатель.Имя           = ИмяПоля;
		Показатель.Представление = ПредставлениеПоля;
		Показатель.Использование = ВклПоУмолчанию;

	КонецЦикла;
	
	Если ТипОтчета = "СписокКроссТаблица" Тогда
		Контекст.ВыводитьПоказателиВСтроку=Истина;
	КонецЕсли;



	ТаблицаПолей = Новый ТаблицаЗначений;
	ТаблицаПолей.Колонки.Добавить("ПутьКДанным");  // описание поля запроса поля, для которого добавляются свойства и
	                                               // категории. Используется в условии соединения с регистром сведений,
	                                               // хранящим значения свойств или категорий
	ТаблицаПолей.Колонки.Добавить("Представление");// представление поля, для которого добавляются свойства и категории. 
	ТаблицаПолей.Колонки.Добавить("Назначение");   // назначение свойств/категорий объектов для данного поля
//	ТаблицаПолей.Колонки.Добавить("ТипЗначения");  // тип значения поля, для которого добавляются свойства и категории.
	                                               // Не используется.
	ТаблицаПолей.Колонки.Добавить("НетКатегорий"); // признак НЕиспользования категорий для объекта

	Для Инд = 0 По МетаданныеРегистра.Измерения.Количество()-1 Цикл

		Измерение = МетаданныеРегистра.Измерения[Инд];
		
		Если Лев(Измерение.Имя, 7) = "Удалить" Тогда
			
			Продолжить;
			
		КонецЕсли;
		
		ИмяПоля           = Измерение.Имя;
		ПредставлениеПоля = Измерение.Представление();
		ОписаниеПоля      = Измерение.Имя;


		Если (ТипОтчета <> "Диаграмма") Тогда
			РассчитыватьИтогиПоИерархии = Истина;
			
			// По умолчанию в отчете группировки и выбранные поля - по трем первым измерениям
			//ВклПоУмолчанию    = ?(Инд<3, Истина, Ложь);
			//РассчитыватьИтоги = ?(Инд<3, Истина, Ложь);
			//ВклПоУмолчанию    = ?(Инд<3, Истина, Ложь);
			//РассчитыватьИтоги = ?(Инд<3, Истина, Ложь);
			РассчитыватьИтоги = ?(Инд<1, Истина, Ложь);
			ВклПоУмолчанию    = Истина;
		Иначе
			РассчитыватьИтогиПоИерархии = Ложь;
			// По умолчанию в отчете группировки и выбранные поля - по трем первым измерениям
			ВклПоУмолчанию    = ?(Инд<1, Истина, Ложь);
			РассчитыватьИтоги = ?(Инд<1, Истина, Ложь);
		КонецЕсли;

		ИтогВКолонке      = Ложь;

		ВклВОтбор    = Истина;

		Если ПустаяСтрока(ОписаниеПоля) И (ТипОтчета <> "Диаграмма") Тогда
			ОписаниеПоля = ИмяПоля;
		КонецЕсли;

		// Для итогов
		ТекстПоляИтогов = ТекстПоляИтогов + ",
		|	" + ОписаниеПоля + ".* КАК " + ИмяПоля;

		// Для списка всех полей
		ТекстВыводимыеПоляЗапроса = ТекстВыводимыеПоляЗапроса + ",
		|	" + ОписаниеПоля + ".* КАК " + ИмяПоля;

		Если ВклПоУмолчанию Тогда // добавим сразу в список полей

			МассивВыбранныеПоляПоУмолчанию.Добавить(ИмяПоля);

			Если РассчитыватьИтоги Тогда // добавим сразу в итоги
				
				МассивИзмеренияСтрокиПоУмолчанию.Добавить(ИмяПоля);

			КонецЕсли;

			Если ИтогВКолонке Тогда
				МассивИзмеренийКолонки.Добавить(ИмяПоля);
			КонецЕсли;

		КонецЕсли; 

		Если ВклВОтбор Тогда

			МассивОтбора.Добавить(ИмяПоля);

		КонецЕсли;

		СтруктураПредставлениеПолей.Вставить(ИмяПоля, ПредставлениеПоля);

		Тип0 = Измерение.Тип.Типы().Получить(0);

		// Ссылочные типы, для которых могут задаваться пользовательские свойства и категории
		Если Измерение.Тип.СодержитТип(Тип("СправочникСсылка.ХарактеристикиНоменклатуры")) Тогда
			
			Назначение = ПланыВидовХарактеристик.НазначенияСвойствКатегорийОбъектов.Справочник_ХарактеристикиНоменклатуры;
		
		ИначеЕсли Измерение.Тип.СодержитТип(Тип("СправочникСсылка.ДоговорыКонтрагентов")) Тогда
			
			Назначение = ПланыВидовХарактеристик.НазначенияСвойствКатегорийОбъектов.Справочник_ДоговорыКонтрагентов;
		
		ИначеЕсли Измерение.Тип.СодержитТип(Тип("СправочникСсылка.КонтактныеЛицаКонтрагентов")) Тогда
			
			Назначение = ПланыВидовХарактеристик.НазначенияСвойствКатегорийОбъектов.Справочник_КонтактныеЛицаКонтрагентов;
		
		ИначеЕсли Измерение.Тип.СодержитТип(Тип("СправочникСсылка.КонтактныеЛица")) Тогда
			
			Назначение = ПланыВидовХарактеристик.НазначенияСвойствКатегорийОбъектов.Справочник_КонтактныеЛица;
		
		ИначеЕсли Измерение.Тип.СодержитТип(Тип("СправочникСсылка.Контрагенты")) Тогда
			
			Назначение = ПланыВидовХарактеристик.НазначенияСвойствКатегорийОбъектов.Справочник_Контрагенты;
		
		ИначеЕсли Измерение.Тип.СодержитТип(Тип("СправочникСсылка.Номенклатура")) Тогда
			
			Назначение = ПланыВидовХарактеристик.НазначенияСвойствКатегорийОбъектов.Справочник_Номенклатура;
		
		ИначеЕсли Измерение.Тип.СодержитТип(Тип("СправочникСсылка.НоменклатурныеГруппы")) Тогда
			
			Назначение = ПланыВидовХарактеристик.НазначенияСвойствКатегорийОбъектов.Справочник_НоменклатурныеГруппы;
		
		ИначеЕсли Измерение.Тип.СодержитТип(Тип("СправочникСсылка.Организации")) Тогда
			
			Назначение = ПланыВидовХарактеристик.НазначенияСвойствКатегорийОбъектов.Справочник_Организации;
		
		ИначеЕсли Измерение.Тип.СодержитТип(Тип("СправочникСсылка.ОсновныеСредства")) Тогда
			
			Назначение = ПланыВидовХарактеристик.НазначенияСвойствКатегорийОбъектов.Справочник_ОсновныеСредства;
		
		ИначеЕсли Измерение.Тип.СодержитТип(Тип("СправочникСсылка.Подразделения")) Тогда
			
			Назначение = ПланыВидовХарактеристик.НазначенияСвойствКатегорийОбъектов.Справочник_Подразделения;
		
		ИначеЕсли Измерение.Тип.СодержитТип(Тип("СправочникСсылка.Проекты")) Тогда
			
			Назначение = ПланыВидовХарактеристик.НазначенияСвойствКатегорийОбъектов.Справочник_Проекты;
		
		ИначеЕсли Измерение.Тип.СодержитТип(Тип("СправочникСсылка.Склады")) Тогда
			
			Назначение = ПланыВидовХарактеристик.НазначенияСвойствКатегорийОбъектов.Справочник_Склады;
		
		ИначеЕсли Измерение.Тип.СодержитТип(Тип("СправочникСсылка.ФизическиеЛица")) Тогда
			
			Назначение = ПланыВидовХарактеристик.НазначенияСвойствКатегорийОбъектов.Справочник_ФизическиеЛица;
			
		ИначеЕсли Документы.ТипВсеСсылки().СодержитТип(Тип0) Тогда
		
			Назначение = ПланыВидовХарактеристик.НазначенияСвойствКатегорийОбъектов.Документы;
		
		Иначе
			
			Назначение = Неопределено;
			
		КонецЕсли;
		
		Индекс = Инд;

		Если Контекст.ИспользоватьСвойстваИКатегории И Назначение <> Неопределено Тогда

			НоваяСтрока = ТаблицаПолей.Добавить();
			НоваяСтрока.ПутьКДанным = ОписаниеПоля;
			НоваяСтрока.Представление = ПредставлениеПоля;
			НоваяСтрока.Назначение = Назначение;

		КонецЕсли;

	КонецЦикла;

	ТекстПоляГде = Сред(ТекстВыводимыеПоляЗапроса, 2);

	// Предопределенные группировки по стандартным периодам

	Если (ВидРегистра = Метаданные.СвойстваОбъектов.ВидРегистраНакопления.Обороты И ((ТипОтчета = "СписокКроссТаблица") ИЛИ (ТипОтчета = "Диаграмма"))) или (ТипОтчета = "ОстаткиИОбороты") Тогда

		// Для списка всех полей
		ТекстПоляИтоговПериоды = ТекстПоляИтоговПериоды + ",
		|	НачалоПериода(Период, День) КАК ПериодДень ,
		|	НачалоПериода(Период, Неделя) КАК ПериодНеделя ,
		|	НачалоПериода(Период, Декада) КАК ПериодДекада ,
		|	НачалоПериода(Период, Месяц) КАК ПериодМесяц ,
		|	НачалоПериода(Период, Квартал) КАК ПериодКвартал ,
		|	НачалоПериода(Период, Полугодие) КАК ПериодПолугодие ,
		|	НачалоПериода(Период, Год) КАК ПериодГод";

		ТекстВыводимыеПоляПериоды = ТекстВыводимыеПоляПериоды + ",
		|	НачалоПериода(Период, День) КАК ПериодДень ,
		|	НачалоПериода(Период, Неделя) КАК ПериодНеделя ,
		|	НачалоПериода(Период, Декада) КАК ПериодДекада ,
		|	НачалоПериода(Период, Месяц) КАК ПериодМесяц ,
		|	НачалоПериода(Период, Квартал) КАК ПериодКвартал ,
		|	НачалоПериода(Период, Полугодие) КАК ПериодПолугодие ,
		|	НачалоПериода(Период, Год) КАК ПериодГод";

		СтруктураПредставлениеПолей.Вставить("Период", "Период");
		СтруктураПредставлениеПолей.Вставить("ПериодДень", "По дням");
		СтруктураПредставлениеПолей.Вставить("ПериодНеделя", "По неделям");
		СтруктураПредставлениеПолей.Вставить("ПериодДекада", "По декадам");
		СтруктураПредставлениеПолей.Вставить("ПериодМесяц", "По месяцам");
		СтруктураПредставлениеПолей.Вставить("ПериодКвартал", "По кварталам");
		СтруктураПредставлениеПолей.Вставить("ПериодПолугодие", "По полугодиям");
		СтруктураПредставлениеПолей.Вставить("ПериодГод", "По годам");

		// Для списка всех полей
		ТекстВыводимыеПоляЗапроса = ТекстВыводимыеПоляЗапроса + ",
		|	Период ,
		|	Регистратор.* КАК Регистратор";

		СтруктураПредставлениеПолей.Вставить("Регистратор", "Документ движения (Регистратор)");
	КонецЕсли;

	Текст = 
	"ВЫБРАТЬ РАЗРЕШЕННЫЕ //РАЗЛИЧНЫЕ" 
	+ Сред(ТекстПоляЗапроса + ТекстПоляПоказатели,2) 
	+ Символы.ПС + "{ВЫБРАТЬ " + Сред(ТекстВыводимыеПоляЗапроса+ТекстПоляПоказатели+"
	|	//СВОЙСТВА
	|"+ТекстВыводимыеПоляПериоды, 2) + "}"
	;
	
	Если (ВидРегистра = Метаданные.СвойстваОбъектов.ВидРегистраНакопления.Обороты И ((ТипОтчета = "СписокКроссТаблица") ИЛИ (ТипОтчета = "Диаграмма"))) Тогда
		Текст =  Текст +
		"
		|ИЗ РегистрНакопления." + ИмяРегистра + ".Обороты(&ДатаНач, &ДатаКон, {&Периодичность}, ";

		СтруктураПредставлениеПолей.Вставить("Периодичность", "Периодичность разворота итогов");

	ИначеЕсли (ВидРегистра = Метаданные.СвойстваОбъектов.ВидРегистраНакопления.Остатки И ((ТипОтчета = "СписокКроссТаблица") ИЛИ (ТипОтчета = "Диаграмма"))) Тогда
		Текст =  Текст +
		"
		|ИЗ РегистрНакопления." + ИмяРегистра + ".Остатки(&ДатаКон, ";
	ИначеЕсли ТипОтчета = "ОстаткиИОбороты" Тогда
		Текст = Текст+
		"
		|ИЗ РегистрНакопления." + ИмяРегистра + ".ОстаткиИОбороты(&ДатаНач, &ДатаКон, {&Периодичность}, , ";
	
		СтруктураПредставлениеПолей.Вставить("Периодичность", "Периодичность разворота итогов");
	КонецЕсли;

	Текст = Текст + "{"+ ТекстПоляГде + "}) КАК ТаблицаРегистра
	|//СОЕДИНЕНИЯ";

	Текст = Текст + ТекстИсточникиСведений;

	Если Не ПустаяСтрока(ТекстПоляГруппировки) Тогда

		Текст = Текст + Символы.ПС + "СГРУППИРОВАТЬ ПО " + Сред(ТекстПоляГруппировки, 2)+"
		|//СГРУППИРОВАТЬПО";

	КонецЕсли; 

	// Отбор
	Текст = Текст + Символы.ПС + "{ГДЕ " + Сред(ТекстВыводимыеПоляЗапроса, 2) + "
	|//СВОЙСТВА
	|//КАТЕГОРИИ
	|}";

	// Порядок
	Текст = Текст + Символы.ПС + "{УПОРЯДОЧИТЬ ПО " + Сред(ТекстВыводимыеПоляЗапроса + ТекстПоляУпорядочивания, 2) + "
	|//СВОЙСТВА
	|}";

	Если Не ПустаяСтрока(ТекстПоляИтогов) Тогда 
		Текст = Текст + Символы.ПС +  
		"{ИТОГИ ПО " + Сред(ТекстПоляИтогов+ТекстПоляИтоговПериоды, 2) + "
		|//СВОЙСТВА
		|}";
	КонецЕсли;

	Текст = Текст + Символы.ПС +  
	"ИТОГИ  " + Сред(ТекстПоляИтоговЗапроса, 2) + Символы.ПС + 
	"ПО ОБЩИЕ " + ТекстПоляИзмерений;

	// Автоупорядочивание
	Текст = Текст + Символы.ПС + "АВТОУПОРЯДОЧИВАНИЕ ";
	
	ТекстПоляКатегорий = "";
	ТекстПоляСвойств = "";

	Если Контекст.ИспользоватьСвойстваИКатегории = Истина Тогда

		ДобавитьВТекстСвойстваИКатегории(ТаблицаПолей, Текст, СтруктураПредставлениеПолей, 
				Контекст.мСоответствиеНазначений, ПостроительОтчета.Параметры
				,, ТекстПоляКатегорий, ТекстПоляСвойств,,,,,,Контекст.мСтруктураДляОтбораПоКатегориям);

	КонецЕсли;

	ПостроительОтчета.Текст = Текст;
	
	Для каждого Элемент Из МассивВыбранныеПоляПоУмолчанию Цикл
	
		ПостроительОтчета.ВыбранныеПоля.Добавить(Элемент);
	
	КонецЦикла;
	
	Для каждого Элемент Из МассивИзмеренияСтрокиПоУмолчанию Цикл
	
		ПостроительОтчета.ИзмеренияСтроки.Добавить(Элемент);
	
	КонецЦикла;

	Для Каждого Показатель из Контекст.мТаблицаПоказатели Цикл
		Если (ТипОтчета = "СписокКроссТаблица") Или (ТипОтчета = "Диаграмма") Тогда

			ОбработкаПоказателейУдалитьИзДоступныхПолей(Показатель.ИмяПоля, ПостроительОтчета);

		ИначеЕсли ТипОтчета = "ОстаткиИОбороты" Тогда

			ОбработкаПоказателейУдалитьИзДоступныхПолей(Показатель.ИмяПоля + "НачальныйОстаток", ПостроительОтчета);
			ОбработкаПоказателейУдалитьИзДоступныхПолей(Показатель.ИмяПоля + "КонечныйОстаток", ПостроительОтчета);
			ОбработкаПоказателейУдалитьИзДоступныхПолей(Показатель.ИмяПоля + "Приход", ПостроительОтчета);
			ОбработкаПоказателейУдалитьИзДоступныхПолей(Показатель.ИмяПоля + "Расход", ПостроительОтчета);

		КонецЕсли;
	КонецЦикла;

	Если Контекст.ИспользоватьСвойстваИКатегории = Истина Тогда

		УстановитьТипыЗначенийСвойствИКатегорийДляОтбора(ПостроительОтчета, ТекстПоляКатегорий, ТекстПоляСвойств, Контекст.мСоответствиеНазначений, СтруктураПредставлениеПолей);

	КонецЕсли;

	Для каждого Элемент Из МассивИзмеренийКолонки Цикл

		Измерение = ПостроительОтчета.ИзмеренияСтроки.Найти(Элемент);
		Если Измерение <> Неопределено Тогда
			ПостроительОтчета.ИзмеренияСтроки.Удалить(Измерение);
		КонецЕсли;

		ПостроительОтчета.ИзмеренияКолонки.Добавить(Элемент);
	
	КонецЦикла; 


КонецПроцедуры // ЗаполнитьНачальныеНастройкиПоМетаданнымРегистра()

// Процедура делает показатель недоступным для выбора как поле, удаляет из выбранных полей
// Вызывается после формирования отчета.
// 
// Параметры:
//	ИмяПоляПостроителя - строка, идентификатор поля построителя
//	ПостроительОтчета  - Построитель отчета
//
Процедура ОбработкаПоказателейУдалитьИзДоступныхПолей(ИмяПоляПостроителя, ПостроительОтчета) Экспорт
	
	Представление = "";
	
	ВыбранноеПоле = ПостроительОтчета.ВыбранныеПоля.Найти(ИмяПоляПостроителя);
	Если ВыбранноеПоле<>Неопределено Тогда
		ПостроительОтчета.ВыбранныеПоля.Удалить(ВыбранноеПоле);
	КонецЕсли;
	
	ДоступноеПоле = ПостроительОтчета.ДоступныеПоля.Найти(ИмяПоляПостроителя);
	Если ДоступноеПоле<>Неопределено Тогда
		Представление = ДоступноеПоле.Представление;
		ТипЗначения = ДоступноеПоле.ТипЗначения;
		ПостроительОтчета.ДоступныеПоля.Удалить(ДоступноеПоле);
	Иначе
		возврат;
	КонецЕсли;
	
	Если НЕ ЗначениеЗаполнено(Представление) Тогда

		Представление = ИмяПоляПостроителя;

	КонецЕсли;

	Поле = ПостроительОтчета.ДоступныеПоля.Добавить(ИмяПоляПостроителя, Представление, ТипЗначения);
	Поле.Порядок = Истина;
	
КонецПроцедуры // ОбработкаПоказателейУдалитьИзДоступныхПолей()

// Функция сохраняет реквизиты отчета в структуре. Данные можно восстановить процедурой ВосстановитьРеквизитыОтчета().
// Используется для передачи реквизитов отчета при расшифровке.
// По умолчанию сохраняются все реквизиты отчета, кроме реквизитов имеющих тип Строка, Отчет или Обработка.
// Табличные части также сохраняются.
// Если список реквизитов для сохранения задан явно, список исключений игнорируется.
// Данные передаются в структуре с ключом "_РеквизитыОтчета", значением является структура с сохраненными значениями, ключ - имя реквизита отчета.
// Если передан параметр СтруктНастройка, то данные сохраняются в переданной структуре (под указанным ключом), иначе в новой.
//
Функция СохранитьРеквизитыОтчета(ОтчетОбъект, СтруктНастройка = Неопределено, Знач СтрСохранять = "", Знач СтрНеСохранять = "") Экспорт
	
	СтруктПараметры = ?(СтруктНастройка = Неопределено, Новый Структура, СтруктНастройка);
	
	МетаОтчет = ОтчетОбъект.Метаданные();
	Если ПустаяСтрока(СтрСохранять) Тогда
	
		СтруктДанные = Новый Структура;
		СтруктИсключений = ?(ПустаяСтрока(СтрНеСохранять), Новый Структура, Новый Структура(СтрНеСохранять));
		
		МетаОтчеты    = Метаданные.Отчеты;
		МетаОбработки = Метаданные.Обработки;
		Для Каждого МетаРекв Из МетаОтчет.Реквизиты Цикл
		
			Если СтруктИсключений.Свойство(МетаРекв.Имя) Тогда
				Продолжить; // Реквизит содержится в списке исключений
			КонецЕсли;
			
			ТипыРекв = ОтчетОбъект.Метаданные().Реквизиты[МетаРекв.Имя].Тип.Типы();
			Если ТипыРекв.Количество() = 1 Тогда
			
				// Исключим реквизиты типа Отчет и Обработка (например Унинверсальный отчет)
				МетаНайтиПоТипу = Метаданные.НайтиПоТипу(ТипыРекв[0]);
				Если НЕ МетаНайтиПоТипу = Неопределено  // Реквизит простого типа (число, булево)
				     И (МетаОтчеты.Содержит(МетаНайтиПоТипу) ИЛИ МетаОбработки.Содержит(МетаНайтиПоТипу)) Тогда
					Продолжить; // Отчеты и обработки пропускаем
				КонецЕсли;
				
				// Добавим реквизит в структуру
				СтруктДанные.Вставить(МетаРекв.Имя, ОтчетОбъект[МетаРекв.Имя]);
				
			Иначе // составной тип. считаем что это реквизит, который надо сохранять.
			
				СтруктДанные.Вставить(МетаРекв.Имя, ОтчетОбъект[МетаРекв.Имя]);
				
			КонецЕсли;
			
		КонецЦикла;
		
		// Сохраним табличные части
		Для Каждого МетаРекв Из МетаОтчет.ТабличныеЧасти Цикл
		
			Если СтруктИсключений.Свойство(МетаРекв.Имя) Тогда
				Продолжить; // Реквизит содержится в списке исключений
			КонецЕсли;
			
			СтруктДанные.Вставить(МетаРекв.Имя, ОтчетОбъект[МетаРекв.Имя].Выгрузить());
			
		КонецЦикла;
		
	Иначе // Список реквизитов задан явно. Их и сохраняем
	
		СтруктДанные = Новый Структура(СтрСохранять);
		Для Каждого ТекРекв Из СтруктДанные Цикл
		
			Если МетаОтчет.Реквизиты.Найти(ТекРекв.Ключ) <> Неопределено Тогда
				СтруктДанные.Вставить(ТекРекв.Ключ, ОтчетОбъект[ТекРекв.Ключ]);
			ИначеЕсли МетаОтчет.ТабличныеЧасти.Найти(ТекРекв.Ключ) <> Неопределено Тогда
				СтруктДанные.Вставить(ТекРекв.Ключ, ОтчетОбъект[ТекРекв.Ключ].Выгрузить());
			КонецЕсли;
			
		КонецЦикла;
		
	КонецЕсли;
	
	СтруктПараметры.Вставить("_РеквизитыОтчета", СтруктДанные);
	
	Возврат СтруктПараметры;

КонецФункции // СохранитьРеквизитыОтчета()

// Функция восстанавливает значения реквизитов отчета, сохраненные в структуре функцией СохранитьРеквизитыОтчета()
//
Процедура ВосстановитьРеквизитыОтчета(ОтчетОбъект, СтруктНастройка) Экспорт
	
	Если ТипЗнч(СтруктНастройка) <> Тип("Структура")
	 ИЛИ НЕ СтруктНастройка.Свойство("_РеквизитыОтчета") Тогда
		Возврат;
	КонецЕсли;
	
	МетаОтчет = ОтчетОбъект.Метаданные();
	Для Каждого СохрРекв Из СтруктНастройка["_РеквизитыОтчета"] Цикл
		Если МетаОтчет.Реквизиты.Найти(СохрРекв.Ключ) <> Неопределено Тогда
			ОтчетОбъект[СохрРекв.Ключ] = СохрРекв.Значение;
		ИначеЕсли МетаОтчет.ТабличныеЧасти.Найти(СохрРекв.Ключ) <> Неопределено Тогда
			ОтчетОбъект[СохрРекв.Ключ].Загрузить(СохрРекв.Значение);
		КонецЕсли;
	КонецЦикла;

КонецПроцедуры // ВосстановитьРеквизитыОтчета()

// Функция формирует выборку вложенных записей, если текущая запись не Неопределено
Функция СформироватьВыборку(Выборка, ОбходРезультатаЗапроса, Измерение, ГруппировкиДляЗначенийГруппировок = Неопределено) Экспорт
	
	Если Выборка <> Неопределено Тогда
		Если ГруппировкиДляЗначенийГруппировок = Неопределено Тогда
			Выборка = Выборка.Выбрать(ОбходРезультатаЗапроса, Измерение);
		Иначе
			Выборка = Выборка.Выбрать(ОбходРезультатаЗапроса, Измерение, ГруппировкиДляЗначенийГруппировок);
		КонецЕсли;
		
		Возврат Истина;
	Иначе
		Возврат Ложь;
	КонецЕсли;
	
КонецФункции

// Процедура устанавливает курсор в ячейке Таб. документа если выводится группа
Процедура УстановитьКурсивПоТипуЗаписи(Ячейка, ТипЗаписи) Экспорт
	
	Если ТипЗаписи = ТипЗаписиЗапроса.ИтогПоИерархии Тогда
		Ячейка.Шрифт = Новый Шрифт(Ячейка.Шрифт , , , , Истина);
	Иначе
		Ячейка.Шрифт = Новый Шрифт(Ячейка.Шрифт , , , , Ложь);
	КонецЕсли;
	
КонецПроцедуры

////////////////////////////////////////////////////////////////////////////////////////////////////
// ПРОЦЕДУРЫ ИНТЕРФЕЙСА ОТЧЕТОВ


// Связывает поля отбора на основной форме с данными, устанавливает представления, прячет лишние
Процедура ОбработатьПоляОтбораНаОсновнойФормеУниверсальногоОтчета(ЭлементыФормы, ПостроительОтчета, СтруктураСвязиЭлементовСДанными = Неопределено, ПутьКПостроителю = "ОтчетОбъект") Экспорт

	// Структура для хранения связи э.у. с данными
	СтруктураСвязиЭлементовСДанными = Новый Структура;

	КоличествоОтборов = 0;
	Для Сч = 0 По ПостроительОтчета.Отбор.Количество()-1 Цикл

		ПолеОтбора = ПостроительОтчета.Отбор[Сч];

		Если НЕ (ПустаяСтрока(ПолеОтбора.Имя) ИЛИ ПолеОтбора.Имя = "Периодичность") Тогда
		
			КоличествоОтборов=КоличествоОтборов+1;
		
		КонецЕсли; 
	КонецЦикла;
	Если КоличествоОтборов>5 Тогда
		КоличествоОтборов = 5;
	КонецЕсли;

	Сч = 0;
	Для Инд = 0 По ПостроительОтчета.Отбор.Количество()-1 Цикл

		ПолеОтбора = ПостроительОтчета.Отбор[Инд];

		Если ПустаяСтрока(ПолеОтбора.Имя) ИЛИ ПолеОтбора.Имя = "Периодичность" Тогда
		
			Продолжить;
		
		КонецЕсли; 

		Сч = Сч + 1;
		Если Сч>КоличествоОтборов Тогда
			прервать;
		КонецЕсли;
		Флажок = ЭлементыФормы["ФлажокНастройки"+Сч];
		
		ПолеВыбора = ЭлементыФормы["ПолеВидаСравнения"+Сч];

//			ПолеВыбора.УстановитьДействие("ПриИзменении", ЭталонПолеВыбора.ПолучитьДействие("ПриИзменении"));
		
		ПолеВвода = ЭлементыФормы["ПолеНастройки"+Сч];

//			ПолеВвода.УстановитьДействие("ПриИзменении", ЭталонПолеВвода.ПолучитьДействие("ПриИзменении"));

		ПолеВводаС = ЭлементыФормы["ПолеНастройкиС"+Сч];

//			ПолеВводаС.УстановитьДействие("ПриИзменении", ЭталонПолеВводаС.ПолучитьДействие("ПриИзменении"));
		
		ПолеВводаПо = ЭлементыФормы["ПолеНастройкиПо"+Сч];;
//			ПолеВводаПо.УстановитьДействие("ПриИзменении", ЭталонПолеВводаПо.ПолучитьДействие("ПриИзменении"));

		ТипОтбора = ПостроительОтчета.Отбор[ПолеОтбора.Имя].ТипЗначения;

		ПолеВыбора.СписокВыбора = ПолучитьСписокВидовСравненияПоТипу(ТипОтбора);

		ЭлементыФормы["ФлажокНастройки"+Сч].Заголовок = ПолеОтбора.Представление;
		ЭлементыФормы["ФлажокНастройки"+Сч].Данные   = ПутьКПостроителю+".ПостроительОтчета.Отбор."+ПолеОтбора.Имя+".Использование";
		ЭлементыФормы["ПолеВидаСравнения"+Сч].Данные = ПутьКПостроителю+".ПостроительОтчета.Отбор."+ПолеОтбора.Имя+".ВидСравнения";
		ЭлементыФормы["ПолеНастройки"+Сч].Данные     = ПутьКПостроителю+".ПостроительОтчета.Отбор."+ПолеОтбора.Имя+".Значение";
		ЭлементыФормы["ПолеНастройкиС"+Сч].Данные    = ПутьКПостроителю+".ПостроительОтчета.Отбор."+ПолеОтбора.Имя+".ЗначениеС";
		ЭлементыФормы["ПолеНастройкиПо"+Сч].Данные   = ПутьКПостроителю+".ПостроительОтчета.Отбор."+ПолеОтбора.Имя+".ЗначениеПо";

		СтруктураСвязиЭлементовСДанными.Вставить("ФлажокНастройки"+Сч,   ПутьКПостроителю+".ПостроительОтчета.Отбор."+ПолеОтбора.Имя+".Использование");
		СтруктураСвязиЭлементовСДанными.Вставить("ПолеВидаСравнения"+Сч, ПутьКПостроителю+".ПостроительОтчета.Отбор."+ПолеОтбора.Имя+".ВидСравнения");
		СтруктураСвязиЭлементовСДанными.Вставить("ПолеНастройки"+Сч,     ПутьКПостроителю+".ПостроительОтчета.Отбор."+ПолеОтбора.Имя+".Значение");
		СтруктураСвязиЭлементовСДанными.Вставить("ПолеНастройкиС"+Сч,    ПутьКПостроителю+".ПостроительОтчета.Отбор."+ПолеОтбора.Имя+".ЗначениеС");
		СтруктураСвязиЭлементовСДанными.Вставить("ПолеНастройкиПо"+Сч,   ПутьКПостроителю+".ПостроительОтчета.Отбор."+ПолеОтбора.Имя+".ЗначениеПо");

		// Если только один тип, то тип выбирать не будем
		ЭлементыФормы["ПолеНастройки"+Сч].ВыбиратьТип   = НЕ (ТипОтбора.Типы().Количество()=1);
		ЭлементыФормы["ПолеНастройкиС"+Сч].ВыбиратьТип  = НЕ (ТипОтбора.Типы().Количество()=1);
		ЭлементыФормы["ПолеНастройкиПо"+Сч].ВыбиратьТип = НЕ (ТипОтбора.Типы().Количество()=1);

		Если ЭлементыФормы["ПолеВидаСравнения"+Сч].Значение = ВидСравнения.Интервал
			ИЛИ ЭлементыФормы["ПолеВидаСравнения"+Сч].Значение = ВидСравнения.ИнтервалВключаяГраницы 
			ИЛИ ЭлементыФормы["ПолеВидаСравнения"+Сч].Значение = ВидСравнения.ИнтервалВключаяНачало 
			ИЛИ ЭлементыФормы["ПолеВидаСравнения"+Сч].Значение = ВидСравнения.ИнтервалВключаяОкончание Тогда
		
			ЭлементыФормы["ПолеНастройки"+Сч].Видимость = Ложь;
			ЭлементыФормы["ПолеНастройкиС"+Сч].Видимость = Истина;
			ЭлементыФормы["ПолеНастройкиПо"+Сч].Видимость = Истина;
		
		Иначе
		
			ЭлементыФормы["ПолеНастройки"+Сч].Видимость = Истина;
			ЭлементыФормы["ПолеНастройкиС"+Сч].Видимость = Ложь;
			ЭлементыФормы["ПолеНастройкиПо"+Сч].Видимость = Ложь;
		
		КонецЕсли;
	
	КонецЦикла; 

КонецПроцедуры // ОбработатьПоляОтбораНаОсновнойФормеУниверсальногоОтчета()

// Процедура-обработчик изменения поля настройки
Процедура ПолеНастройкиПриИзменении(Элемент, Отбор, СтруктураСвязиЭУсДанными=Неопределено) Экспорт

	Поз = Найти(Элемент.Имя, "ПолеНастройки");
	Если Поз>0 Тогда
		
		Если ТипЗнч(СтруктураСвязиЭУсДанными)= Тип("Структура") Тогда
			
			// Имяполя отбора найдем из пути к данным
			ПутьКДанным="";
			Если СтруктураСвязиЭУсДанными.Свойство(Элемент.Имя, ПутьКДанным) Тогда
				
				ПутьКДанным = Сред(ПутьКДанным, Найти(ПутьКДанным, "Отбор.")+СтрДлина("Отбор."));
				ИмяПоля = Лев(ПутьКДанным, Найти(ПутьКДанным, ".")-1);
				
			КонецЕсли;
		Иначе
			ИмяПоля = Сред(Элемент.Имя, СтрДлина("ПолеНастройки")+1);
		КонецЕсли;
		
		МетаданныеЗначения = Метаданные.НайтиПоТипу(ТипЗнч(Элемент.Значение));
		Если МетаданныеЗначения <> Неопределено Тогда
			Если Метаданные.Справочники.Найти(МетаданныеЗначения.Имя) <> Неопределено Тогда
				Если Элемент.Значение.ЭтоГруппа Тогда
					Отбор[ИмяПоля].ВидСравнения = ВидСравнения.ВИерархии;
				КонецЕсли;
			КонецЕсли;
		Иначе
			Если Элемент.ТипЗначения.Типы().Количество() = 2 Тогда
				ПустойСписок = Новый СписокЗначений;
				Если Элемент.ТипЗначения.СодержитТип(Тип("СписокЗначений")) Тогда
					ТипНеСписок = ?(Элемент.ТипЗначения.Типы()[0] = Тип("СписокЗначений"), Элемент.ТипЗначения.Типы()[1], Элемент.ТипЗначения.Типы()[0]);
					
					Если НЕ ЗначениеЗаполнено(Элемент.Значение) или (ТипЗнч(Элемент.Значение) = Тип("СписокЗначений") и Элемент.Значение.Количество() = 0) Тогда
						Если (Отбор[ИмяПоля].ВидСравнения = ВидСравнения.ВСписке)
							Или (Отбор[ИмяПоля].ВидСравнения = ВидСравнения.ВСпискеПоИерархии)
							Или (Отбор[ИмяПоля].ВидСравнения = ВидСравнения.НеВСписке)
							Или (Отбор[ИмяПоля].ВидСравнения = ВидСравнения.НеВСпискеПоИерархии) Тогда
							МассивСТипом = Новый массив(1);
							
							МассивСТипом[0] = ТипНеСписок;
							
							ПустойСписок.ТипЗначения = Новый ОписаниеТипов(МассивСТипом);
							
							Элемент.Значение = ПустойСписок;
						Иначе
							Элемент.Значение = ОбщегоНазначения.ПустоеЗначениеТипа(ТипНеСписок);
						КонецЕсли;
					КонецЕсли;
				КонецЕсли;
			КонецЕсли;
		КонецЕсли;

		Если НЕ (НЕ ЗначениеЗаполнено(Элемент.Значение) или (ТипЗнч(Элемент.Значение) = Тип("СписокЗначений") и Элемент.Значение.Количество() = 0)) Тогда
			Отбор[ИмяПоля].Использование = Истина;
		КонецЕсли;
		
	КонецЕсли;

КонецПроцедуры // ПолеНастройкиПриИзменении()

// Процедура-обработчик изменения поля настройки С
Процедура ПолеНастройкиСПриИзменении(Элемент, Отбор, СтруктураСвязиЭУсДанными=Неопределено) Экспорт

	Поз = Найти(Элемент.Имя, "ПолеНастройкиC");
	Если Поз>0 Тогда
		
		Если ТипЗнч(СтруктураСвязиЭУсДанными)= Тип("Структура") Тогда
			
			// Имяполя отбора найдем из пути к данным
			ПутьКДанным="";
			Если СтруктураСвязиЭУсДанными.Свойство(Элемент.Имя, ПутьКДанным) Тогда
				
				ПутьКДанным = Сред(ПутьКДанным, Найти(ПутьКДанным, "Отбор.")+СтрДлина("Отбор."));
				ИмяПоля = Лев(ПутьКДанным, Найти(ПутьКДанным, ".")-1);
				
			КонецЕсли;
		Иначе
			ИмяПоля = Сред(Элемент.Имя, СтрДлина("ПолеНастройкиC")+1);
		КонецЕсли;

		Если ЗначениеЗаполнено(Элемент.Значение) Тогда
			Отбор[ИмяПоля].Использование = Истина;
		КонецЕсли;
		
	КонецЕсли;

КонецПроцедуры // ПолеНастройкиСПриИзменении()

// Процедура-обработчик изменения поля настройки ПО
Процедура ПолеНастройкиПоПриИзменении(Элемент, Отбор, СтруктураСвязиЭУсДанными=Неопределено) Экспорт

	Поз = Найти(Элемент.Имя, "ПолеНастройкиПо");
	Если Поз>0 Тогда
		
		Если ТипЗнч(СтруктураСвязиЭУсДанными)= Тип("Структура") Тогда
			
			// Имяполя отбора найдем из пути к данным
			ПутьКДанным="";
			Если СтруктураСвязиЭУсДанными.Свойство(Элемент.Имя, ПутьКДанным) Тогда
				
				ПутьКДанным = Сред(ПутьКДанным, Найти(ПутьКДанным, "Отбор.")+СтрДлина("Отбор."));
				ИмяПоля = Лев(ПутьКДанным, Найти(ПутьКДанным, ".")-1);
				
			КонецЕсли;
		Иначе
			ИмяПоля = Сред(Элемент.Имя, СтрДлина("ПолеНастройкиПо")+1);
		КонецЕсли;

		Если ЗначениеЗаполнено(Элемент.Значение) Тогда
			Отбор[ИмяПоля].Использование = Истина;
		КонецЕсли;
		
	КонецЕсли;
	
КонецПроцедуры // ПолеНастройкиПоПриИзменении()

// Процедура-обработчик изменения поля вида сравнения
Процедура ПолеВидаСравненияПриИзменении(Элемент, ЭлементыФормы) Экспорт

	ИмяОтбора = Сред(Элемент.Имя, Найти(Элемент.Имя, "ПолеВидаСравнения")+СтрДлина("ПолеВидаСравнения"));
	
	// Управление полями настройки в зависимости от вида сравнения
		Если Элемент.Значение = ВидСравнения.Интервал
			ИЛИ Элемент.Значение = ВидСравнения.ИнтервалВключаяГраницы 
			ИЛИ Элемент.Значение = ВидСравнения.ИнтервалВключаяНачало 
			ИЛИ Элемент.Значение = ВидСравнения.ИнтервалВключаяОкончание Тогда
		
			Если ЭлементыФормы.Найти("ПолеНастройки" + ИмяОтбора) <> НеОпределено Тогда
				ЭлементыФормы["ПолеНастройки"+ИмяОтбора].Видимость = Ложь;
			КонецЕсли;
			Если ЭлементыФормы.Найти("ПолеНастройкиС" + ИмяОтбора) <> НеОпределено Тогда
				ЭлементыФормы["ПолеНастройкиС"+ИмяОтбора].Видимость = Истина;
			КонецЕсли;
			Если ЭлементыФормы.Найти("ПолеНастройкиПо" + ИмяОтбора) <> НеОпределено Тогда
				ЭлементыФормы["ПолеНастройкиПо"+ИмяОтбора].Видимость = Истина;
			КонецЕсли;
		
		Иначе
		
			Если ЭлементыФормы.Найти("ПолеНастройки" + ИмяОтбора) <> НеОпределено Тогда
				ПолеНастройки = ЭлементыФормы["ПолеНастройки"+ИмяОтбора];
				ПолеНастройки.Видимость = Истина;
				Если Элемент.Значение = ВидСравнения.ВСписке
					ИЛИ Элемент.Значение = ВидСравнения.НеВСписке
					ИЛИ Элемент.Значение = ВидСравнения.ВСпискеПоИерархии
					ИЛИ Элемент.Значение = ВидСравнения.НеВСпискеПоИерархии Тогда
					ПолеНастройки.ОграничениеТипа = Новый ОписаниеТипов("СписокЗначений");
				Иначе
					ПолеНастройки.ОграничениеТипа = Новый ОписаниеТипов(ПолеНастройки.ТипЗначения,, "СписокЗначений");
				КонецЕсли;
			КонецЕсли;
			Если ЭлементыФормы.Найти("ПолеНастройкиС" + ИмяОтбора) <> НеОпределено Тогда
				ЭлементыФормы["ПолеНастройкиС"+ИмяОтбора].Видимость = Ложь;
			КонецЕсли;
			Если ЭлементыФормы.Найти("ПолеНастройкиПо" + ИмяОтбора) <> НеОпределено Тогда
				ЭлементыФормы["ПолеНастройкиПо"+ИмяОтбора].Видимость = Ложь;
			КонецЕсли;
		
		КонецЕсли;

КонецПроцедуры // ПолеВидаСравненияПриИзменении()

// Формирует текст-заголовок формы отчета
Функция СформироватьЗаголовокОсновнойФормы(ДатаНач, ДатаКон, НазваниеОтчета, РежимВводаПериода) Экспорт

	// Вывод заголовка, описателя периода и фильтров и заголовка
	Если РежимВводаПериода =  0 Тогда  // произвольный период
		Если ДатаНач = '00010101000000' И ДатаКон = '00010101000000' Тогда
			ОписаниеПериода     = "Период не установлен";

		Иначе
			Если ДатаНач = '00010101000000' ИЛИ ДатаКон = '00010101000000' Тогда
				ОписаниеПериода = "" + Формат(ДатаНач, "ДФ = ""дд.ММ.гггг""; ДП = ""...""") 
				+ " - "      + Формат(ДатаКон, "ДФ = ""дд.ММ.гггг""; ДП = ""...""");

			Иначе
				Если ДатаНач <= ДатаКон Тогда
					ОписаниеПериода = "" + ПредставлениеПериода(НачалоДня(ДатаНач), КонецДня(ДатаКон), "ФП = Истина");
				Иначе
					ОписаниеПериода = "Неправильно задан период!"
				КонецЕсли;

			КонецЕсли;

		КонецЕсли;
		
	ИначеЕсли РежимВводаПериода =  1 Тогда   // на дату
		Если ДатаКон = '00010101000000' Тогда
			ОписаниеПериода = "на текущее время " + Формат(ТекущаяДата(), "ДФ = ""дд.ММ.гггг""; ДП = ""...""");

		Иначе
			ОписаниеПериода = "на конец дня " + Формат(ДатаКон, "ДФ = ""дд.ММ.гггг""; ДП = ""...""");
			
		КонецЕсли;

	ИначеЕсли РежимВводаПериода = 2 Тогда   // месяц
		Если ДатаНач = '00010101000000' Тогда
			ОписаниеПериода     = "Период не установлен";

		Иначе
			ОписаниеПериода = "" + ПредставлениеПериода(НачалоМесяца(ДатаНач), КонецМесяца(ДатаНач), "ФП = Истина");
			
		КонецЕсли;
		
	ИначеЕсли РежимВводаПериода = 3 Тогда   // квартал
		Если ДатаНач = '00010101000000' Тогда
			ОписаниеПериода     = "Период не установлен";

		Иначе
			ОписаниеПериода = "" + ПредставлениеПериода(НачалоКвартала(ДатаНач), КонецКвартала(ДатаНач), "ФП = Истина");
			
		КонецЕсли;
		
	ИначеЕсли РежимВводаПериода = 4 Тогда   // год
		Если ДатаНач = '00010101000000' Тогда
			ОписаниеПериода     = "Период не установлен";

		Иначе
			ОписаниеПериода = "" + ПредставлениеПериода(НачалоГода(ДатаНач), КонецГода(ДатаНач), "ФП = Истина");
			
		КонецЕсли;
		
	КонецЕсли;

	Если НЕ ЗначениеЗаполнено(ОписаниеПериода) Тогда
		Возврат НазваниеОтчета;
	Иначе
		Возврат НазваниеОтчета+" (" + ОписаниеПериода + ") ";
	КонецЕсли;

КонецФункции // СформироватьЗаголовокОсновнойФормы()

// Формирует список регистров остатков
//
// Параметры: 
//	Нет.
//
// Возвращаемое значение: 
//	список значений, содержащийимена всех регистров остатков
//
Функция ПолучитьСписокРегистровНакопления() Экспорт

	СписокРегистровОстатков = Новый СписокЗначений;

	Для Каждого МетаданныеРегистр Из Метаданные.РегистрыНакопления Цикл
		
		Если НЕ ПравоДоступа("Чтение", МетаданныеРегистр) Тогда
			Продолжить;
		КонецЕсли;

		СписокРегистровОстатков.Добавить(МетаданныеРегистр.Имя, МетаданныеРегистр.Представление());

	КонецЦикла;
	
	Возврат СписокРегистровОстатков;
	
Конецфункции // ПолучитьСписокРегистровНакопления()

// Формирует список регистров остатков
//
// Параметры: 
//	Нет.
//
// Возвращаемое значение: 
//	список значений, содержащийимена всех регистров остатков
//
Функция ПолучитьСписокРегистровОстатков() Экспорт

	СписокРегистровОстатков = Новый СписокЗначений;

	Для Каждого МетаданныеРегистр Из Метаданные.РегистрыНакопления Цикл
		
		Если НЕ ПравоДоступа("Чтение", МетаданныеРегистр) Тогда
			Продолжить;
		КонецЕсли;

		Если МетаданныеРегистр.ВидРегистра = Метаданные.СвойстваОбъектов.ВидРегистраНакопления.Остатки Тогда

			СписокРегистровОстатков.Добавить(МетаданныеРегистр.Имя, МетаданныеРегистр.Представление());

		КонецЕсли;

	КонецЦикла;
	
	Возврат СписокРегистровОстатков;
	
Конецфункции // ПолучитьСписокРегистровОстатков()

// Формирует список допустимых значений Вида Сравнения
//
// Параметры: 
//	ОпТипов - Описание Типов поля
//
// Возвращаемое значение: 
//	список значений, содержащийимена всех регистров остатков
//
Функция ПолучитьСписокВидовСравненияПоТипу(ОпТипов) Экспорт
	
	ТаблицаДоступныхЗначений = Новый ТаблицаЗначений;
	ТаблицаДоступныхЗначений.Колонки.Добавить("ВидСравнения");
	ТаблицаДоступныхЗначений.Колонки.Добавить("ЧислоВида");
	
	Для каждого ТипОписания Из ОпТипов.Типы() Цикл
	
		НоваяСтрокаТаблицы = ТаблицаДоступныхЗначений.Добавить();
		НоваяСтрокаТаблицы.ВидСравнения = ВидСравнения.Равно;
		НоваяСтрокаТаблицы.ЧислоВида = 1;
		
		НоваяСтрокаТаблицы = ТаблицаДоступныхЗначений.Добавить();
		НоваяСтрокаТаблицы.ВидСравнения = ВидСравнения.НеРавно;
		НоваяСтрокаТаблицы.ЧислоВида = 1;
		
		НоваяСтрокаТаблицы = ТаблицаДоступныхЗначений.Добавить();
		НоваяСтрокаТаблицы.ВидСравнения = ВидСравнения.ВСписке;
		НоваяСтрокаТаблицы.ЧислоВида = 1;
		
		НоваяСтрокаТаблицы = ТаблицаДоступныхЗначений.Добавить();
		НоваяСтрокаТаблицы.ВидСравнения = ВидСравнения.НеВСписке;
		НоваяСтрокаТаблицы.ЧислоВида = 1;

		Если Справочники.ТипВсеСсылки().СодержитТип(ТипОписания) И Метаданные.НайтиПоТипу(ТипОписания).Иерархический Тогда
			
			НоваяСтрокаТаблицы = ТаблицаДоступныхЗначений.Добавить();
			НоваяСтрокаТаблицы.ВидСравнения = ВидСравнения.ВСпискеПоИерархии;
			НоваяСтрокаТаблицы.ЧислоВида = 1;
			
			НоваяСтрокаТаблицы = ТаблицаДоступныхЗначений.Добавить();
			НоваяСтрокаТаблицы.ВидСравнения = ВидСравнения.НеВСпискеПоИерархии;
			НоваяСтрокаТаблицы.ЧислоВида = 1;
			
			НоваяСтрокаТаблицы = ТаблицаДоступныхЗначений.Добавить();
			НоваяСтрокаТаблицы.ВидСравнения = ВидСравнения.ВИерархии;
			НоваяСтрокаТаблицы.ЧислоВида = 1;
			
			НоваяСтрокаТаблицы = ТаблицаДоступныхЗначений.Добавить();
			НоваяСтрокаТаблицы.ВидСравнения = ВидСравнения.НеВИерархии;
			НоваяСтрокаТаблицы.ЧислоВида = 1;
			
		ИначеЕсли ТипОписания = Тип("Число")
			  ИЛИ ТипОписания = Тип("Строка")
			  ИЛИ ТипОписания = Тип("Дата") Тогда
			
			НоваяСтрокаТаблицы = ТаблицаДоступныхЗначений.Добавить();
			НоваяСтрокаТаблицы.ВидСравнения = ВидСравнения.Больше;
			НоваяСтрокаТаблицы.ЧислоВида = 1;
			
			НоваяСтрокаТаблицы = ТаблицаДоступныхЗначений.Добавить();
			НоваяСтрокаТаблицы.ВидСравнения = ВидСравнения.БольшеИлиРавно;
			НоваяСтрокаТаблицы.ЧислоВида = 1;
			
			НоваяСтрокаТаблицы = ТаблицаДоступныхЗначений.Добавить();
			НоваяСтрокаТаблицы.ВидСравнения = ВидСравнения.Меньше;
			НоваяСтрокаТаблицы.ЧислоВида = 1;
			
			НоваяСтрокаТаблицы = ТаблицаДоступныхЗначений.Добавить();
			НоваяСтрокаТаблицы.ВидСравнения = ВидСравнения.МеньшеИлиРавно;
			НоваяСтрокаТаблицы.ЧислоВида = 1;
			
			НоваяСтрокаТаблицы = ТаблицаДоступныхЗначений.Добавить();
			НоваяСтрокаТаблицы.ВидСравнения = ВидСравнения.Интервал;
			НоваяСтрокаТаблицы.ЧислоВида = 1;
			
			НоваяСтрокаТаблицы = ТаблицаДоступныхЗначений.Добавить();
			НоваяСтрокаТаблицы.ВидСравнения = ВидСравнения.ИнтервалВключаяГраницы;
			НоваяСтрокаТаблицы.ЧислоВида = 1;
			
			НоваяСтрокаТаблицы = ТаблицаДоступныхЗначений.Добавить();
			НоваяСтрокаТаблицы.ВидСравнения = ВидСравнения.ИнтервалВключаяНачало;
			НоваяСтрокаТаблицы.ЧислоВида = 1;
			
			НоваяСтрокаТаблицы = ТаблицаДоступныхЗначений.Добавить();
			НоваяСтрокаТаблицы.ВидСравнения = ВидСравнения.ИнтервалВключаяОкончание;
			НоваяСтрокаТаблицы.ЧислоВида = 1;
			
		КонецЕсли;
		
		Если ТипОписания = Тип("Строка") Тогда
			НоваяСтрокаТаблицы = ТаблицаДоступныхЗначений.Добавить();
			НоваяСтрокаТаблицы.ВидСравнения = ВидСравнения.Содержит;
			НоваяСтрокаТаблицы.ЧислоВида = 1;
		КонецЕсли;
		
	КонецЦикла;
	
	ТаблицаДоступныхЗначений.Свернуть("ВидСравнения", "ЧислоВида");
	
	СписокВидовСравнения = Новый СписокЗначений;
	КолТипов = ОпТипов.Типы().Количество();
	
	Для каждого СтрокаТаблицы Из ТаблицаДоступныхЗначений Цикл
		Если СтрокаТаблицы.ЧислоВида = КолТипов Тогда
			СписокВидовСравнения.Добавить(СтрокаТаблицы.ВидСравнения);
		КонецЕсли; 
	КонецЦикла; 
	
	Возврат СписокВидовСравнения;
	
Конецфункции //


// Процедура инициализирует отправку печатного документа по электронной почте
//
// Параметры: 
//  Документ - табличный документ
//  ОбъектПечати - ДокументСсылка, СправочникСсылка, СписокЗначений - объекты из которых вызвана печать. Параметр тип список значений содержит объекты печати.
//
// Возвращаемое значение:
//  Нет.
//
Процедура ОтправитьДокументПоЭлектроннойПочте(Документ, ИмяФайлаВложения = "", ОбъектПечати = Неопределено) Экспорт

	Если НЕ Константы.ИспользованиеВстроенногоПочтовогоКлиента.Получить() Тогда
		ОбщегоНазначения.СообщитьОбОшибке("Отправлять документы по электронной почте можно только из встроенного почтового клиента.
		|В настоящее время в настройках параметров учета установлено использование основного почтового клиента операционной системы.");
		#Если Клиент Тогда
			Предупреждение("Операция не выполнена");
		#Иначе
			Сообщить("Операция не выполнена");
		#КонецЕсли
		Возврат;
	КонецЕсли;
	
	ФормаОтправкиДокумента = ПолучитьОбщуюФорму("НастройкаОтправкиОтчета");
	ФормаОтправкиДокумента.Отчет            = Документ;
	ФормаОтправкиДокумента.ИмяФайлаВложения = СтрЗаменить(ИмяФайлаВложения, ".", " ");
	ФормаОтправкиДокумента.ТемаСообщения    = ИмяФайлаВложения;
	ФормаОтправкиДокумента.ОбъектПечати     = ОбъектПечати;
	ФормаОтправкиДокумента.ОткрытьМодально();

КонецПроцедуры

// Функция формирует необходимую структуру данных для создания на форме отчета панели
// с переключателями типов учета. По умолчанию создается панель с 4-мя видами учета (упр, бух, нал, МСФО).
//
Функция ПодготовитьДанныеДляСозданияПанелиВидыУчета(ДействиеПриИзменении, Знач ВидыУчета = "Упр,Бух,Нал,МСФО") Экспорт

	ПанельВидыУчета = Новый Массив;
	
	ГруппаЭлементов = Новый Структура("Имя, Заголовок, Ширина, СоставГруппы",
		"ФормироватьПоДанным",    // Имя
		"Формировать по данным:", // Заголовок
		136,                      // Ширина
		Новый Массив);            // СоставГруппы
	
	ВидыУчета = "," + СтрЗаменить(ВидыУчета, " ", "") + ",";
	Если Найти(ВидыУчета, ",Упр,") > 0 Тогда
		ЭлементГруппы = Новый Структура("Имя, Заголовок, Ширина, Данные, ВыбираемоеЗначение, ПервыйВГруппе, Видимость, Доступность, ДействиеПриИзменении",
			"ВидУчетаУпр",            // Имя
			"Управленческого учета",  // Заголовок
			139,                      // Ширина
			"ВидУчета",               // Данные
			0,                        // Выбираемое значение
			Истина,                   // Первый в группе
			Истина,                   // Видимость
			Истина,                   // Доступность
			ДействиеПриИзменении);    // Действие при изменении
			
		ГруппаЭлементов.СоставГруппы.Добавить(ЭлементГруппы);
	КонецЕсли;
	
	Если Найти(ВидыУчета, ",Бух,") > 0 Тогда
		ЭлементГруппы  = Новый Структура("Имя, Заголовок, Ширина, Данные, ВыбираемоеЗначение, ПервыйВГруппе, Видимость, Доступность, ДействиеПриИзменении",
			"ВидУчетаБух",            // Имя
			"Бухгалтерского учета",   // Заголовок
			129,                      // Ширина
			"ВидУчета",               // Данные
			1,                        // Выбираемое значение
			Ложь,                     // Первый в группе
			Истина,                   // Видимость
			Истина,                   // Доступность
			ДействиеПриИзменении);    // Действие при изменении
				
		ГруппаЭлементов.СоставГруппы.Добавить(ЭлементГруппы);
	КонецЕсли;

	Если Найти(ВидыУчета, ",Нал,") > 0 Тогда
		ЭлементГруппы  = Новый Структура("Имя, Заголовок, Ширина, Данные, ВыбираемоеЗначение, ПервыйВГруппе, Видимость, Доступность, ДействиеПриИзменении",
			"ВидУчетаНал",            // Имя
			"Налогового учета",       // Заголовок
			109,                      // Ширина
			"ВидУчета",               // Данные
			2,                        // Выбираемое значение
			Ложь,                     // Первый в группе
			Истина,                   // Видимость
			Истина,                   // Доступность
			ДействиеПриИзменении);    // Действие при изменении
			
		ГруппаЭлементов.СоставГруппы.Добавить(ЭлементГруппы);
	КонецЕсли;
		
	Если Найти(ВидыУчета, ",МСФО,") > 0 Тогда
		ЭлементГруппы = Новый Структура("Имя, Заголовок, Ширина, Данные, ВыбираемоеЗначение, ПервыйВГруппе, Видимость, Доступность, ДействиеПриИзменении",
			"ВидУчетаМСФО",           // Имя
			"Международного учета",   // Заголовок
			137,                      // Ширина
			"ВидУчета",               // Данные
			3,                        // Выбираемое значение
			Ложь,                     // Первый в группе
			Истина,                   // Видимость
			Истина,                   // Доступность
			ДействиеПриИзменении);    // Действие при изменении
		
		ГруппаЭлементов.СоставГруппы.Добавить(ЭлементГруппы);
	КонецЕсли;
	
	ПанельВидыУчета.Добавить(ГруппаЭлементов);
	
	Возврат ПанельВидыУчета;
	
КонецФункции // ПодготовитьДанныеДляСозданияПанелиВидыУчета()

////////////////////////////////////////////////////////////////////////////////////////////////////
// ПРОЦЕДУРЫ ОТЧЕТОВ НА ПОСТРОИТЕЛЕ ОТЧЕТОВ

// В текст для построителя отчета вставляет свойства и категории
Процедура ДобавитьВТекстСвойстваИКатегории(ТаблицаПолей, Текст, СтруктураПредставлениеПолей, мСоответствиеНазначений, 
	                                          СтруктураПараметры, ТекстИсточникиСведений="", ТекстПоляКатегорий="", 
	                                          ТекстПоляСвойств="", ТекстПоляСгруппироватьПо = "", 
	                                          ЗаменятьСвойства = "//СВОЙСТВА", ЗаменятьКатегории = "//КАТЕГОРИИ", 
	                                          ЗаменятьСоединения = "//СОЕДИНЕНИЯ", ЗаменятьСгруппироватьПо = "//СГРУППИРОВАТЬПО",
	                                          ИдентификаторыПараметровДляОтборовПоКатегориям = "") Экспорт

	// Добавляемые фрагменты запроса
	ТекстПоляКатегорийДляГруппировки ="";
	ТекстПоляСвойствДляГруппировки = "";
	ТекстИсточникиСведений ="";
	ТекстПоляКатегорий = "";
	ТекстПоляСвойств = "";
	
	Если НЕ ТипЗнч(ИдентификаторыПараметровДляОтборовПоКатегориям)=Тип("Структура") Тогда
		
		ИдентификаторыПараметровДляОтборовПоКатегориям = Новый Структура;
		
	КонецЕсли;

	Индекс = 0;

	Выборка = ПланыВидовХарактеристик.СвойстваОбъектов.Выбрать();
	Пока Выборка.Следующий() Цикл

		Если Выборка.ЭтоГруппа ИЛИ Выборка.ПометкаУдаления Тогда
			Продолжить;
		КонецЕсли;

		НайденнаяСтрока = ТаблицаПолей.Найти(Выборка.НазначениеСвойства, "Назначение");
		Если НайденнаяСтрока <> Неопределено Тогда

			// Для списка всех полей
			ТекстПоляСвойств = ТекстПоляСвойств + ",
			|	Свойство"+Индекс+".Значение" + " КАК " + "Свойство"+Индекс+"Значение";
			
			ТекстПоляСвойствДляГруппировки = ТекстПоляСвойствДляГруппировки + ",
			|	Свойство"+Индекс+".Значение";

			// Источник для свойств
			ТекстИсточникиСведений = ТекстИсточникиСведений + Символы.ПС + 
			"{ЛЕВОЕ СОЕДИНЕНИЕ РегистрСведений.ЗначенияСвойствОбъектов КАК Свойство"+Индекс+"
			|ПО Свойство"+Индекс+".Объект = " + НайденнаяСтрока.ПутьКДанным + "
			|И  Свойство"+Индекс+".Свойство = &ПараметрСвойство"+Индекс+ "}";

			СтруктураПараметры.Вставить("ПараметрСвойство"+Индекс, Выборка.Ссылка);

			СтруктураПредставлениеПолей.Вставить("Свойство"+Индекс+"Значение", Выборка.Наименование + " (св-во " + НайденнаяСтрока.Представление + ")");

			мСоответствиеНазначений.Вставить(Выборка.Наименование + " (св-во " + НайденнаяСтрока.Представление + ")", Выборка.Ссылка);

			Индекс = Индекс + 1;

		КонецЕсли;

	КонецЦикла;

	Индекс = 0;

	Для Каждого Строка Из ТаблицаПолей Цикл

		Если НЕ (Строка.НетКатегорий=Истина) Тогда

			ТекстИсточникиСведений = ТекстИсточникиСведений + Символы.ПС + 
			"{ЛЕВОЕ СОЕДИНЕНИЕ РегистрСведений.КатегорииОбъектов КАК Категории"+Индекс+"
			|ПО Категории"+Индекс+".Объект = " + Строка.ПутьКДанным + "
			|И  Категории"+Индекс+".Категория В (&ПараметрКатегории"+Индекс+")}";

			ТекстПоляКатегорий = ТекстПоляКатегорий + ",
			|	ВЫБОР
			|		КОГДА Категории"+Индекс+".Категория ЕСТЬ НЕ NULL 
			|			ТОГДА Категории"+Индекс+".Категория
			|	ИНАЧЕ "+Строка.ПутьКДанным + "
			|	КОНЕЦ КАК Категории"+Индекс+"Категория";

			ТекстПоляКатегорийДляГруппировки = ТекстПоляКатегорийДляГруппировки + ",
			|	Категории"+Индекс+".Категория";

			СтруктураПредставлениеПолей.Вставить("Категории"+Индекс+"Категория", "Категории " + Строка.Представление);

			ИдентификаторыПараметровДляОтборовПоКатегориям.Вставить("Категории"+Индекс+"Категория", "ПараметрКатегории"+Индекс);

			мСоответствиеНазначений.Вставить("Категории " + Строка.Представление, Строка.Назначение);
			
			Индекс = Индекс + 1;
			
		КонецЕсли;
	
	КонецЦикла;
	
	Индекс = 0;


	//ВЫБРАТЬ РАЗЛИЧНЫЕ съедает достаточно много ресурсов - поэтому если 
	//не надо, то обойдемся без него.
	Если ТекстПоляКатегорийДляГруппировки <> "" Тогда

		Текст = СтрЗаменить(Текст, "//РАЗЛИЧНЫЕ", "РАЗЛИЧНЫЕ");

	КонецЕсли;
	
	Текст = СтрЗаменить(Текст, ЗаменятьСвойства, ТекстПоляСвойств);
	Текст = СтрЗаменить(Текст, ЗаменятьКатегории, ТекстПоляКатегорий);
	Текст = СтрЗаменить(Текст, ЗаменятьСоединения, ТекстИсточникиСведений);
	Текст = СтрЗаменить(Текст, ЗаменятьСгруппироватьПо, ТекстПоляСвойствДляГруппировки + ТекстПоляКатегорийДляГруппировки);

КонецПроцедуры // ДобавитьВТекстСвойстваИКатегории()

// В текст запроса построителя вносит изменения с целью выборки всей информации о физлице
// Параметры:
// 	ТекстЗапроса 				- модифицируемый текст запроса построителя,
// 	СтруктураПредставлениеПолей - структура, в которую ложится представление добавленных полей физлица,
// 	СтруктураФорматаПолей 		- структура, в которую ложится формат добавленных полей физлица,
// 	ИмяОсновнойВыборки 			- имя таблицы запроса, к которой присоединяется информация о физлице
// 	ИмяПоляФизЛицо 				- имя реквизита основной выборки, имеющего тип "СправочникСсылка.ФизическиеЛица"
Процедура ДобавитьВТекстПостроителяДанныеОФизлице(ТекстЗапроса, СтруктураПредставлениеПолей, СтруктураФорматаПолей, ИмяОсновнойВыборки, ИмяПоляФизЛицо) Экспорт
	
	ПолноеИмяПоляФизЛицо = ИмяОсновнойВыборки + "." + ИмяПоляФизЛицо;
	ТипДата = Тип("Дата");
	
	// данные о физлице
	ТекстОписаниеПолей = ",
	|	" + ПолноеИмяПоляФизЛицо +".ДатаРождения 		КАК ДатаРождения,
	|	" + ПолноеИмяПоляФизЛицо +".ИНН 				КАК ИНН,
	|	" + ПолноеИмяПоляФизЛицо +".КодИМНС 			КАК КодИМНС,
	|	" + ПолноеИмяПоляФизЛицо +".Комментарий 		КАК Комментарий,
	|	" + ПолноеИмяПоляФизЛицо +".СтраховойНомерПФР КАК СтраховойНомерПФР,
	|	" + ПолноеИмяПоляФизЛицо +".Пол 				КАК Пол,
	|	" + ПолноеИмяПоляФизЛицо +".МестоРождения 		КАК МестоРождения,
	|	" + ПолноеИмяПоляФизЛицо +".МестоРожденияКодПоОКАТО КАК МестоРожденияКодПоОКАТО,
	|	ЕСТЬNULL(ФИОФизЛиц.Фамилия + "" "" + ФИОФизЛиц.Имя + "" "" + ФИОФизЛиц.Отчество, " + ПолноеИмяПоляФизЛицо + ".Наименование) КАК ФиоПолное,
	|	ЕСТЬNULL(ФИОФизЛиц.Фамилия + ВЫБОР КОГДА ПОДСТРОКА(ФИОФизЛиц.Имя, 1, 1) <> """" ТОГДА "" "" + ПОДСТРОКА(ФИОФизЛиц.Имя, 1, 1) + ""."" ИНАЧЕ """" КОНЕЦ + ВЫБОР КОГДА ПОДСТРОКА(ФИОФизЛиц.Отчество, 1, 1) <> """" ТОГДА "" "" + ПОДСТРОКА(ФИОФизЛиц.Отчество, 1, 1) + ""."" ИНАЧЕ """" КОНЕЦ, " + ПолноеИмяПоляФизЛицо +".Наименование) КАК ФиоКраткое,
	|	ВЫБОР КОГДА ГОД(" + ПолноеИмяПоляФизЛицо +".ДатаРождения) = 1 ТОГДА 0 ИНАЧЕ &ДатаАктуальности_Год - ГОД(" + ПолноеИмяПоляФизЛицо +".ДатаРождения) + ВЫБОР КОГДА (Месяц(" + ПолноеИмяПоляФизЛицо +".ДатаРождения)*100+День(" + ПолноеИмяПоляФизЛицо +".ДатаРождения)) > (&ДатаАктуальности_Месяц*100+&ДатаАктуальности_День) ТОГДА -1 ИНАЧЕ 0 КОНЕЦ КОНЕЦ КАК Возраст,";
	
	ТекстСоединения = "
	|		{ЛЕВОЕ СОЕДИНЕНИЕ РегистрСведений.ФИОФизЛиц.СрезПоследних(&ДатаАктуальности) КАК ФИОФизЛиц
	|		ПО " + ПолноеИмяПоляФизЛицо + " = ФИОФизЛиц.ФизЛицо}";
	
	// данные из табличных частей физлица
	МетаданныеФизЛица = Метаданные.Справочники.ФизическиеЛица;
	Для каждого ОписаниеТЧФизЛица Из МетаданныеФизЛица.ТабличныеЧасти Цикл
		ИмяТЧ = ОписаниеТЧФизЛица.Имя;
		Если ИмяТЧ = "Стажи" Тогда
			ТекстОписаниеПолей = ТекстОписаниеПолей + "
			|	СтажиФизЛица.ВидСтажа КАК СтажиВидСтажа,";
			СтруктураПредставлениеПолей.Вставить("СтажиВидСтажа", "Вид стажа");
			// сам стаж пока не выводим ...
		Иначе
			// из остальных т.ч. выводим данные без дополнительной обработки
			Для каждого ОписаниеРеквизита Из ОписаниеТЧФизЛица.Реквизиты Цикл
				ИмяРеквизита = ОписаниеРеквизита.Имя;
				ТекстОписаниеПолей = ТекстОписаниеПолей + "
				|	" + ИмяТЧ + "ФизЛица." + ИмяРеквизита + " КАК " + ИмяТЧ + ИмяРеквизита + ",";
				СтруктураПредставлениеПолей.Вставить(ИмяТЧ + ИмяРеквизита, ОписаниеРеквизита.Синоним);
				Если ОписаниеРеквизита.Тип.СодержитТип(ТипДата) Тогда
					СтруктураФорматаПолей.Вставить(ИмяТЧ + ИмяРеквизита, "ДФ=dd.MM.yyyy");
				КонецЕсли;	
			КонецЦикла;
		КонецЕсли;
		ТекстСоединения = ТекстСоединения + "
		|		{ЛЕВОЕ СОЕДИНЕНИЕ Справочник.ФизическиеЛица." + ИмяТЧ + " КАК " + ИмяТЧ + "ФизЛица
		|		ПО " + ПолноеИмяПоляФизЛицо + " = " + ИмяТЧ + "ФизЛица.Ссылка}";
	КонецЦикла; 
	
	// данные из регистров сведений о физлице
	МассивРегистров = Новый Массив;
	МассивРегистров.Добавить("ПаспортныеДанныеФизЛиц");
	МассивРегистров.Добавить("ГражданствоФизЛиц");
	МассивРегистров.Добавить("ВоинскийУчет");
	МассивРегистров.Добавить("СемейноеПоложениеФизЛиц");
	МассивРегистров.Добавить("СведенияОбИнвалидностиФизлиц");
	МассивРегистров.Добавить("СведенияОСтажеРаботыНаСевере");
	
	Для каждого ИмяРегистра Из МассивРегистров Цикл
	
		МетаданныеРегистра = Метаданные.РегистрыСведений[ИмяРегистра];
		Для каждого ОписаниеРесурса Из МетаданныеРегистра.Ресурсы Цикл
			ИмяРесурса = ОписаниеРесурса.Имя;
			ТекстОписаниеПолей = ТекстОписаниеПолей + "
			|	" + ИмяРегистра + "." + ИмяРесурса + " КАК " + ИмяРегистра + ИмяРесурса + ",";
			СтруктураПредставлениеПолей.Вставить(ИмяРегистра + ИмяРесурса, ОписаниеРесурса.Синоним);
			Если ОписаниеРесурса.Тип.СодержитТип(ТипДата) Тогда
				СтруктураФорматаПолей.Вставить(ИмяРегистра + ИмяРесурса, "ДФ=dd.MM.yyyy");
			КонецЕсли;	
		КонецЦикла;
		
		ТекстСоединения = ТекстСоединения + "
		|		{ЛЕВОЕ СОЕДИНЕНИЕ РегистрСведений." + ИмяРегистра + ?(МетаданныеРегистра.ПериодичностьРегистраСведений = Метаданные.СвойстваОбъектов.ПериодичностьРегистраСведений.Непериодический,"",".СрезПоследних(&ДатаАктуальности)") + " КАК " + ИмяРегистра + "
		|		ПО " + ПолноеИмяПоляФизЛицо + " = " + ИмяРегистра + ".ФизЛицо}";
		
	КонецЦикла;

	ТекстЗапроса = СтрЗаменить(ТекстЗапроса, "//ДАННЫЕ О ФИЗЛИЦЕ: ПОЛЯ", Лев(ТекстОписаниеПолей,СтрДлина(ТекстОписаниеПолей)-1));
	ТекстЗапроса = СтрЗаменить(ТекстЗапроса, "//ДАННЫЕ О ФИЗЛИЦЕ: СОЕДИНЕНИЯ", ТекстСоединения);
	
	// ПРЕДСТАВЛЕНИЕ ПОЛЕЙ
	
	//данные физлица
	СтруктураПредставлениеПолей.Вставить("ДатаРождения", "Дата рождения");
	СтруктураПредставлениеПолей.Вставить("КодИМНС", "Код ИМНС");
	СтруктураПредставлениеПолей.Вставить("СтраховойНомерПФР", "Страховой номер ПФР");
	СтруктураПредставлениеПолей.Вставить("МестоРождения", "Место рождения");
	СтруктураПредставлениеПолей.Вставить("МестоРожденияКодПоОКАТО", "Код по ОКАТО места рождения");
	СтруктураПредставлениеПолей.Вставить("ФиоПолное", "ФИО (полностью)");
	СтруктураПредставлениеПолей.Вставить("ФиоКраткое", "Фамилия И. О. ");
	// трудовая деятельность
	СтруктураПредставлениеПолей.Вставить("ТрудоваяДеятельностьОрганизация", "Трудовая деятельность: организация");
	СтруктураПредставлениеПолей.Вставить("ТрудоваяДеятельностьДатаНачала", "Трудовая деятельность: начало работы");
	СтруктураПредставлениеПолей.Вставить("ТрудоваяДеятельностьДатаОкончания", "Трудовая деятельность: окончание работы");
	СтруктураПредставлениеПолей.Вставить("ТрудоваяДеятельностьДолжность", "Трудовая деятельность: должность");
	
	// ФОРМАТ ПОЛЕЙ
	СтруктураФорматаПолей.Вставить("ДатаРождения", "ДФ=dd.MM.yyyy");
	
КонецПроцедуры // ДобавитьВТекстПостроителяДанныеОФизлице()


// форматируем числа интервалов для формирования строк запроса
//
// Параметры:
//	Значение       - форматируемое число
//
// Возвращаемое значение:
//	строка - отформатированная число
//
Функция ЗнчВТекстЗапроса(Значение) 
	
	Если ТипЗнч(Значение)=Тип("Число") Тогда
		Результат = Формат(Значение,"ЧГ=0;ЧРД=.;ЧН=");
	ИначеЕсли ТипЗнч(Значение)=Тип("Строка") Тогда
		Результат = """"+Значение+"""";
	ИначеЕсли ТипЗнч(Значение)=Тип("Дата") Тогда
		Результат = "ДатаВремя("
		+ЗнчВТекстЗапроса(Год(Значение))+","
		+ЗнчВТекстЗапроса(Месяц(Значение))+","
		+ЗнчВТекстЗапроса(День(Значение))+","
		+ЗнчВТекстЗапроса(Час(Значение))+","
		+ЗнчВТекстЗапроса(Минута(Значение))+","
		+ЗнчВТекстЗапроса(Секунда(Значение))+")";
	Иначе
		Результат="0";
	КонецЕсли;
	
	Возврат Результат;
КонецФункции	 

// Процедура заполняет представления элементов всех коллекций построителя отчета на
//  основании соответствия имен и представдлений переданных в параметре
//
// Параметры
//  СтруктураСоответствияИмен - Структура, ключ - имя поля, значение - представление поля
//  ПостроительОтчета         - ПостроительОтчета
//
//  Возвращаемое значение
//   НЕТ
//
Процедура ЗаполнитьПредставленияПолей(СтруктураСоответствияИмен, ПостроительОтчета) Экспорт

	СтруктураКоллекцийПостроителяОтчета = Новый Структура("ДоступныеПоля, ВыбранныеПоля, ИзмеренияКолонки, ИзмеренияСтроки, Отбор");
	
	Для каждого ЭлементСтруктуры Из СтруктураКоллекцийПостроителяОтчета Цикл
		Для а = 0 По ПостроительОтчета[ЭлементСтруктуры.Ключ].Количество() - 1 Цикл
			Если ПустаяСтрока(ПостроительОтчета[ЭлементСтруктуры.Ключ][а].Имя) Тогда
				Продолжить;
			КонецЕсли;
			Если СтруктураСоответствияИмен.Свойство(ПостроительОтчета[ЭлементСтруктуры.Ключ][а].Имя) Тогда
				ПостроительОтчета[ЭлементСтруктуры.Ключ][а].Представление = СтруктураСоответствияИмен[ПостроительОтчета[ЭлементСтруктуры.Ключ][а].Имя];
			КонецЕсли; 
		КонецЦикла; 
	КонецЦикла; 
	
КонецПроцедуры // ЗаполнитьПредставленияПолей()

// Добавляет в параметры построителя отчета использованные в отборах категории
//
// Параметры:
//	ПостроительОтчета              - Построитель, отбор которого обрабатывается, и в Параметры 
//                                    которого добавляются категории
//	СтруктураДляОтбораПоКатегориям - структура, связывающая пути к данным Отборов Построителя и 
//                                    идентицфикаторы параметров
//
// Возвращаемое значение:
//	Истина, если добавление параметров произошло успешно
//	Ложь, если есть повторный отбор по одной и той же категории.
//
// Вообще-то, повторный отбор по одной и той же категории невозможен не всегда - 
//  можно отобрать два раза с видом сравнения "не равно". Контроль возвращаемого
//  этой функцией значения отключить можно, но нужно после этого понимать,
//  что два отбора по одной категории с видом сравнения "Равно" приведут к тому,
//  что отчет окажется пустым.
//
Функция ЗадатьПараметрыОтбораПоКатегориям(ПостроительОтчета, СтруктураДляОтбораПоКатегориям) Экспорт

	Если ТипЗнч(СтруктураДляОтбораПоКатегориям) = ТипЗнч(Новый Структура) Тогда

		Для Каждого ЭлементОтбора Из ПостроительОтчета.Отбор Цикл
			//Прочищаем все, независимо от использования элемента отбора
			НазваниеПараметра = "";
			Если ЗначениеЗаполнено(ЭлементОтбора.ПутьКДанным) И Найти(ЭлементОтбора.ПутьКДанным, ".") = 0 Тогда
				Если СтруктураДляОтбораПоКатегориям.Свойство(ЭлементОтбора.ПутьКДанным, НазваниеПараметра) Тогда
					Если ПостроительОтчета.Параметры.Свойство(НазваниеПараметра) Тогда
						ПостроительОтчета.Параметры.Удалить(НазваниеПараметра);
					КонецЕсли;
				КонецЕсли;
			КонецЕсли;
		КонецЦикла;

		Для Каждого ЭлементОтбора Из ПостроительОтчета.Отбор Цикл

			Если Найти(ЭлементОтбора.ПутьКДанным, ".") > 0 Тогда
				Продолжить;
			КонецЕсли;

			Если ЭлементОтбора.Использование Тогда

				ИдентификаторПараметра = "";

				Если ЗначениеЗаполнено(ЭлементОтбора.ПутьКДанным) И СтруктураДляОтбораПоКатегориям.Свойство(ЭлементОтбора.ПутьКДанным, ИдентификаторПараметра) Тогда

					МассивЗначенийКатегорий = НеОпределено;

					Если НЕ ПостроительОтчета.Параметры.Свойство(ИдентификаторПараметра, МассивЗначенийКатегорий) Тогда
						МассивЗначенийКатегорий = Новый Массив;
					Иначе
						#Если Клиент Тогда
							Предупреждение("Нельзя использовать несколько отборов по одной и той же категории!");
						#Иначе
							Сообщить("Нельзя использовать несколько отборов по одной и той же категории!");
						#КонецЕсли
						Возврат Ложь;
					КонецЕсли;

					Если ТипЗнч(ЭлементОтбора.Значение) = ТипЗнч(Новый СписокЗначений) Тогда
						Для Каждого ЗначениеКатегории Из ЭлементОтбора.Значение Цикл
							МассивЗначенийКатегорий.Добавить(ЗначениеКатегории.Значение);
						КонецЦикла;
					Иначе
						МассивЗначенийКатегорий.Добавить(ЭлементОтбора.Значение);
					КонецЕсли;

					ПостроительОтчета.Параметры.Вставить(ИдентификаторПараметра, МассивЗначенийКатегорий);

				КонецЕсли;
				
			КонецЕсли;
				
		КонецЦикла;
	КонецЕсли;

	Возврат Истина;

КонецФункции // ЗадатьПараметрыОтбораПоКатегориям()

// Устанавливает типы значений доступных полей отбора, соответствующих свойствам и категориям
//
// Параметры:
//	ПостроительОтчета      - ПостроительОтчета, его доступные поля анализируются
//	ТекстПоляКатегорий,
//	ТекстПоляСвойств       - Строки, используются для определений того, является ли
//                            ДоступноеПоле значением свойства или категрии
//	мСоответствиеНазначений - Соответствие между представлениями и ПВХ,
//                            используется для установки правильных типов Свойств
//
Процедура УстановитьТипыЗначенийСвойствИКатегорийДляОтбора(ПостроительОтчета, ТекстПоляКатегорий, ТекстПоляСвойств, мСоответствиеНазначений, СтруктураПредставлениеПолей) Экспорт
	
	Для Каждого КлючИЗначение из СтруктураПредставлениеПолей Цикл
		
		Если Найти(ТекстПоляСвойств, "КАК " + КлючИЗначение.Ключ)>0 Тогда

			Назначение = мСоответствиеНазначений.Получить(КлючИЗначение.Значение);
			
			Если Назначение = Неопределено Тогда
				Продолжить;
				
			КонецЕсли;

			ДоступноеПоле = ПостроительОтчета.ДоступныеПоля.Найти(КлючИЗначение.Ключ);
			
			Если ДоступноеПоле = Неопределено Тогда
				
				Продолжить;
				
			КонецЕсли;

			Если ДоступноеПоле.Отбор Тогда
				
				ДоступноеПоле.ТипЗначения = Назначение.ТипЗначения;
				
			КонецЕсли;

		ИначеЕсли Найти(ТекстПоляКатегорий, "КАК " + КлючИЗначение.Ключ)>0 Тогда
			
			ДоступноеПоле = ПостроительОтчета.ДоступныеПоля.Найти(КлючИЗначение.Ключ);

			Если ДоступноеПоле <> Неопределено Тогда
				
				ДоступноеПоле.ТипЗначения = Новый ОписаниеТипов("СправочникСсылка.КатегорииОбъектов");
				
			КонецЕсли;
			
		КонецЕсли;
		
	КонецЦикла;
	
	ВозможныеТипыСвойств = Метаданные.ПланыВидовХарактеристик.СвойстваОбъектов.Тип.Типы();
	
	ИндексТекущегоВозможногоТипа = 0;
			
	Для каждого ВозможныйТипСвойства из ВозможныеТипыСвойств Цикл
				
		ПостроительОтчета.Параметры.Вставить("ПараметрПустоеЗначениеСвойства" + ИндексТекущегоВозможногоТипа, ОбщегоНазначения.ПустоеЗначениеТипа(ВозможныйТипСвойства));
		ИндексТекущегоВозможногоТипа = ИндексТекущегоВозможногоТипа + 1;
				
	КонецЦикла;
	
КонецПроцедуры // УстановитьТипыЗначенийСвойствИКатегорийДляОтбора()


// Процедура добавляет показатель в выбранные поля. Вызывается перед выполнением запроса.
// 
// Параметры:
//	ИмяПоляПостроителя - строка, идентификатор поля построителя
//	ПостроительОтчета  - Построитель отчета
//

// Устанавливает связь полей отбора на основной форме с отбором
Процедура УстановитьСвязьПолейБыстрогоОтбораНаФорме(ЭлементыФормы, Отбор, СтруктураСвязиЭлементовСДанными = Неопределено, ПутьКОтбору = "ОтчетОбъект.ПостроительОтчета.Отбор") Экспорт

	Инд=0;
	СтруктураНаборовСвязываемыхЭлементов = Новый Структура;
	//Перебираем элементы формы
	Пока Инд<ЭлементыФормы.Количество() Цикл

		Элемент = ЭлементыФормы[Инд];
		
		Если (Найти(Элемент.Имя, "ПолеНастройки")
			ИЛИ Найти(Элемент.Имя, "ФлажокНастройки")
			ИЛИ Найти(Элемент.Имя, "ПолеВидаСравнения")) Тогда

			//Если имя элемента формы содержит что-то, нас интересующее,
			//добавляем его в соответствующую структуру

			//Это может плохо работать, например, для "ПолеНастройкиПоПорядку"
			//процедура решит, что это "ПолеНастройкиПо" для "Порядку". Вывод - используем маленькую
			//букву - "ПолеНастройкиПопопрядку"!!!
			Если (Найти(Элемент.Имя, "ПолеНастройкиПо")) и (ВРег(Сред(Элемент.Имя, 16, 1)) = Сред(Элемент.Имя, 16, 1)) Тогда
				ИмяПоляОтбора = СтрЗаменить(Элемент.Имя, "ПолеНастройкиПо", "");
			ИначеЕсли Найти(Элемент.Имя, "ПолеНастройкиС") и (ВРег(Сред(Элемент.Имя, 15, 1)) = Сред(Элемент.Имя, 15, 1)) Тогда
				ИмяПоляОтбора = СтрЗаменить(Элемент.Имя, "ПолеНастройкиС", "");
			ИначеЕсли Найти(Элемент.Имя, "ПолеНастройки") Тогда
				ИмяПоляОтбора = СтрЗаменить(Элемент.Имя, "ПолеНастройки", "");
			ИначеЕсли Найти(Элемент.Имя, "ПолеВидаСравнения") Тогда
				ИмяПоляОтбора = СтрЗаменить(Элемент.Имя, "ПолеВидаСравнения", "");
			Иначе
				ИмяПоляОтбора = СтрЗаменить(Элемент.Имя, "ФлажокНастройки", "");
			КонецЕсли;
			
			СтрНабор = "";
			Если НЕ СтруктураНаборовСвязываемыхЭлементов.Свойство(ИмяПоляОтбора) Тогда
				//Ключами структуры "СтруктураНаборовСвязываемыхЭлементов" являются 
				//идентификаторы полей отбора, значениями - структуры СтрНабор.
				СтрНабор = Новый Структура;
				СтруктураНаборовСвязываемыхЭлементов.Вставить(ИмяПоляОтбора, СтрНабор);
				Иначе СтрНабор = СтруктураНаборовСвязываемыхЭлементов[ИмяПоляОтбора];
			КонецЕсли;
			//В СтрНабор мы складываем в качестве ключа, например, "ПолеНастройки", 
			//значение - ЭУ формы. В общем, откусываем идентификатор отбора
			СтрНабор.Вставить(СтрЗаменить(Элемент.Имя, ИмяПоляОтбора, ""), Элемент);
			
		КонецЕсли;
		
		Инд=Инд+1;
	
	КонецЦикла; 

	// Структура для хранения связи э.у. с данными
	СтруктураСвязиЭлементовСДанными = Новый Структура;

	Для Сч = 0 По Отбор.Количество()-1 Цикл

		ПолеОтбора = Отбор[Сч];
		
		Если ПустаяСтрока(ПолеОтбора.Имя) Тогда
			Продолжить;
		КонецЕсли; 

		Если СтруктураНаборовСвязываемыхЭлементов.Свойство(ПолеОтбора.Имя) Тогда
			//Тогда имеет место комплект (возможно, неполный) контролов для него
			
			КомплектКонтролов = СтруктураНаборовСвязываемыхЭлементов[ПолеОтбора.Имя];
			//напоминаю - ключи - тип ЭУ, значения - сами ЭУ
			//Связываем их с данными.
			
			ТипОтбора = Отбор[ПолеОтбора.Имя].ТипЗначения;
			
			Если КомплектКонтролов.Свойство("ФлажокНастройки") Тогда
				КомплектКонтролов.ФлажокНастройки.Данные = ПутьКОтбору+"."+ПолеОтбора.Имя+".Использование";
				СтруктураСвязиЭлементовСДанными.Вставить("ФлажокНастройки"+ПолеОтбора.Имя,   ПутьКОтбору+"."+ПолеОтбора.Имя+".Использование");
			КонецЕсли;
			
			Если КомплектКонтролов.Свойство("ПолеНастройки") Тогда
				КомплектКонтролов.ПолеНастройки.Данные = ПутьКОтбору+"."+ПолеОтбора.Имя+".Значение";
				СтруктураСвязиЭлементовСДанными.Вставить("ПолеНастройки"+ПолеОтбора.Имя,     ПутьКОтбору+"."+ПолеОтбора.Имя+".Значение");
			КонецЕсли;

			Если КомплектКонтролов.Свойство("ПолеНастройкиС") Тогда
				КомплектКонтролов.ПолеНастройкиС.Данные = ПутьКОтбору+"."+ПолеОтбора.Имя+".ЗначениеС";
				СтруктураСвязиЭлементовСДанными.Вставить("ПолеНастройкиС"+ПолеОтбора.Имя,    ПутьКОтбору+"."+ПолеОтбора.Имя+".ЗначениеС");
			КонецЕсли;

			Если КомплектКонтролов.Свойство("ПолеНастройкиПо") Тогда
				КомплектКонтролов.ПолеНастройкиПо.Данные = ПутьКОтбору+"."+ПолеОтбора.Имя+".ЗначениеПо";
				СтруктураСвязиЭлементовСДанными.Вставить("ПолеНастройкиПо"+ПолеОтбора.Имя,   ПутьКОтбору+"."+ПолеОтбора.Имя+".ЗначениеПо");
			КонецЕсли;

			Если КомплектКонтролов.Свойство("ПолеВидаСравнения") Тогда
				КомплектКонтролов.ПолеВидаСравнения.СписокВыбора = ПолучитьСписокВидовСравненияПоТипу(ТипОтбора);
				КомплектКонтролов.ПолеВидаСравнения.Данные = ПутьКОтбору+"."+ПолеОтбора.Имя+".ВидСравнения";
				СтруктураСвязиЭлементовСДанными.Вставить("ПолеВидаСравнения"+ПолеОтбора.Имя, ПутьКОтбору+"."+ПолеОтбора.Имя+".ВидСравнения");

				//Установим видимость ЭУ "ПолеНастройки*" в зависимости от 
				//уже установленного вида сравнения
				ПолеВидаСравненияПриИзменении(КомплектКонтролов.ПолеВидаСравнения, ЭлементыФормы);

			КонецЕсли;
			
		КонецЕсли;
	КонецЦикла; 

КонецПроцедуры // УстановитьСвязьПолейБыстрогоОтбораНаФорме()


// Заполняет отборы ПостроителяОтчета
//
// Параметры:
//	МассивОтбора - Массив, содержащий идентификаторы отборов
Процедура ЗаполнитьОтбор(МассивОтбора, ПостроительОтчета) Экспорт
	Для Каждого Элемент Из МассивОтбора Цикл

		ПолеОтбора = ПостроительОтчета.Отбор.Добавить(Элемент);

	КонецЦикла; 
КонецПроцедуры // ЗаполнитьОтбор()

// Функция формирует строку представления отборов объекта Отбор
//
// Параметры
//  Отбор - Отбор, по которому формируем строку
//
// Возвращаемое значение:
//   Строка - представление отбора
//
Функция СформироватьСтрокуОтборов(Отбор) Экспорт

	Если ТипЗнч(Отбор) <> Тип("Отбор") Тогда
		Возврат "";
	КонецЕсли; 
	
	СтрокаОтборов = "";
	
	Для а = 0 По Отбор.Количество() - 1 Цикл
		
		ЭлементОтбора = Отбор[а];
		Если НЕ ЭлементОтбора.Использование Тогда
			Продолжить;
		КонецЕсли; 

		Если ЭлементОтбора.Имя = "Периодичность" Тогда
			Продолжить;
		КонецЕсли;

		Если НЕ ПустаяСтрока(СтрокаОтборов) Тогда
			СтрокаОтборов = СтрокаОтборов + ", ";
		КонецЕсли; 
		Если ЭлементОтбора.ВидСравнения = ВидСравнения.Равно Тогда
			СтрокаОтборов = СтрокаОтборов + ЭлементОтбора.Представление + " = "+ ?(ЗначениеЗаполнено(ЭлементОтбора.Значение), СокрЛП(Строка(ЭлементОтбора.Значение)), "Пусто");
		ИначеЕсли ЭлементОтбора.ВидСравнения = ВидСравнения.НеРавно Тогда
			СтрокаОтборов = СтрокаОтборов + ЭлементОтбора.Представление + " <> "+ ?(ЗначениеЗаполнено(ЭлементОтбора.Значение), СокрЛП(Строка(ЭлементОтбора.Значение)), "Пусто");
		ИначеЕсли ЭлементОтбора.ВидСравнения = ВидСравнения.ВСписке Тогда
			СтрокаСписка = "";
			Для каждого ЭлементСписка Из ЭлементОтбора.Значение Цикл
				Если НЕ ПустаяСтрока(СтрокаСписка) Тогда
					СтрокаСписка = СтрокаСписка + "; ";
				КонецЕсли; 
				Если ЗначениеЗаполнено(ЭлементСписка.Представление) Тогда
					СтрокаСписка = СтрокаСписка + СокрЛП(ЭлементСписка.Представление);
				Иначе
					СтрокаСписка = СтрокаСписка + СокрЛП(Строка(ЭлементСписка.Значение));
				КонецЕсли;
			КонецЦикла; 
			СтрокаОтборов = СтрокаОтборов + ЭлементОтбора.Представление + " в списке "+ ?(ЗначениеЗаполнено(ЭлементОтбора.Значение), СтрокаСписка, "Пусто");
		ИначеЕсли ЭлементОтбора.ВидСравнения = ВидСравнения.ВСпискеПоИерархии Тогда
			СтрокаСписка = "";
			Для каждого ЭлементСписка Из ЭлементОтбора.Значение Цикл
				Если НЕ ПустаяСтрока(СтрокаСписка) Тогда
					СтрокаСписка = СтрокаСписка + "; ";
				КонецЕсли; 
				Если ЗначениеЗаполнено(ЭлементСписка.Представление) Тогда
					СтрокаСписка = СтрокаСписка + СокрЛП(ЭлементСписка.Представление);
				Иначе
					СтрокаСписка = СтрокаСписка + СокрЛП(Строка(ЭлементСписка.Значение));
				КонецЕсли;
			КонецЦикла; 
			СтрокаОтборов = СтрокаОтборов + ЭлементОтбора.Представление + " в списке по иерархии "+ ?(ЗначениеЗаполнено(ЭлементОтбора.Значение), СтрокаСписка, "Пусто");
		ИначеЕсли ЭлементОтбора.ВидСравнения = ВидСравнения.НеВСписке Тогда
			СтрокаСписка = "";
			Для каждого ЭлементСписка Из ЭлементОтбора.Значение Цикл
				Если НЕ ПустаяСтрока(СтрокаСписка) Тогда
					СтрокаСписка = СтрокаСписка + "; ";
				КонецЕсли;
				Если ЗначениеЗаполнено(ЭлементСписка.Представление) Тогда
					СтрокаСписка = СтрокаСписка + СокрЛП(ЭлементСписка.Представление);
				Иначе
					СтрокаСписка = СтрокаСписка + СокрЛП(Строка(ЭлементСписка.Значение));
				КонецЕсли;
			КонецЦикла; 
			СтрокаОтборов = СтрокаОтборов + ЭлементОтбора.Представление + " не в списке "+ ?(ЗначениеЗаполнено(ЭлементОтбора.Значение), СтрокаСписка, "Пусто");
		ИначеЕсли ЭлементОтбора.ВидСравнения = ВидСравнения.НеВСпискеПоИерархии Тогда
			СтрокаСписка = "";
			Для каждого ЭлементСписка Из ЭлементОтбора.Значение Цикл
				Если НЕ ПустаяСтрока(СтрокаСписка) Тогда
					СтрокаСписка = СтрокаСписка + "; ";
				КонецЕсли;
				Если ЗначениеЗаполнено(ЭлементСписка.Представление) Тогда
					СтрокаСписка = СтрокаСписка + СокрЛП(ЭлементСписка.Представление);
				Иначе
					СтрокаСписка = СтрокаСписка + СокрЛП(Строка(ЭлементСписка.Значение));
				КонецЕсли;
			КонецЦикла; 
			СтрокаОтборов = СтрокаОтборов + ЭлементОтбора.Представление + " не в списке по иерархии "+ ?(ЗначениеЗаполнено(ЭлементОтбора.Значение), СтрокаСписка, "Пусто");
		ИначеЕсли ЭлементОтбора.ВидСравнения = ВидСравнения.Больше Тогда
			СтрокаОтборов = СтрокаОтборов + ЭлементОтбора.Представление + " > "+ ?(ЗначениеЗаполнено(ЭлементОтбора.Значение), СокрЛП(Строка(ЭлементОтбора.Значение)), "Пусто");
		ИначеЕсли ЭлементОтбора.ВидСравнения = ВидСравнения.БольшеИлиРавно Тогда
			СтрокаОтборов = СтрокаОтборов + ЭлементОтбора.Представление + " >= "+ ?(ЗначениеЗаполнено(ЭлементОтбора.Значение), СокрЛП(Строка(ЭлементОтбора.Значение)), "Пусто");
		ИначеЕсли ЭлементОтбора.ВидСравнения = ВидСравнения.Меньше Тогда
			СтрокаОтборов = СтрокаОтборов + ЭлементОтбора.Представление + " < "+ ?(ЗначениеЗаполнено(ЭлементОтбора.Значение), СокрЛП(Строка(ЭлементОтбора.Значение)), "Пусто");
		ИначеЕсли ЭлементОтбора.ВидСравнения = ВидСравнения.МеньшеИлиРавно Тогда
			СтрокаОтборов = СтрокаОтборов + ЭлементОтбора.Представление + " <= "+ ?(ЗначениеЗаполнено(ЭлементОтбора.Значение), СокрЛП(Строка(ЭлементОтбора.Значение)), "Пусто");
		ИначеЕсли ЭлементОтбора.ВидСравнения = ВидСравнения.Интервал Тогда
			СтрокаОтборов = СтрокаОтборов + ?(ЗначениеЗаполнено(ЭлементОтбора.ЗначениеС), СокрЛП(Строка(ЭлементОтбора.ЗначениеС)), "...") + " < " + ЭлементОтбора.Представление + " < "+ ?(ЗначениеЗаполнено(ЭлементОтбора.ЗначениеПо), СокрЛП(Строка(ЭлементОтбора.ЗначениеПо)), "...");
		ИначеЕсли ЭлементОтбора.ВидСравнения = ВидСравнения.ИнтервалВключаяГраницы Тогда
			СтрокаОтборов = СтрокаОтборов + ?(ЗначениеЗаполнено(ЭлементОтбора.ЗначениеС), СокрЛП(Строка(ЭлементОтбора.ЗначениеС)), "...") + " <= " + ЭлементОтбора.Представление + " <= "+ ?(ЗначениеЗаполнено(ЭлементОтбора.ЗначениеПо), СокрЛП(Строка(ЭлементОтбора.ЗначениеПо)), "...");
		ИначеЕсли ЭлементОтбора.ВидСравнения = ВидСравнения.ИнтервалВключаяНачало Тогда
			СтрокаОтборов = СтрокаОтборов + ?(ЗначениеЗаполнено(ЭлементОтбора.ЗначениеС), СокрЛП(Строка(ЭлементОтбора.ЗначениеС)), "...") + " <= " + ЭлементОтбора.Представление + " < "+ ?(ЗначениеЗаполнено(ЭлементОтбора.ЗначениеПо), СокрЛП(Строка(ЭлементОтбора.ЗначениеПо)), "...");
		ИначеЕсли ЭлементОтбора.ВидСравнения = ВидСравнения.ИнтервалВключаяОкончание Тогда
			СтрокаОтборов = СтрокаОтборов + ?(ЗначениеЗаполнено(ЭлементОтбора.ЗначениеС), СокрЛП(Строка(ЭлементОтбора.ЗначениеС)), "...") + " < " + ЭлементОтбора.Представление + " <= "+ ?(ЗначениеЗаполнено(ЭлементОтбора.ЗначениеПо), СокрЛП(Строка(ЭлементОтбора.ЗначениеПо)), "...");
		КонецЕсли; 

	КонецЦикла; 
	
	Возврат СтрокаОтборов;

КонецФункции // СформироватьСтрокуОтборов()

// Функция формирует строку представления измерений построителя отчета
//
// Параметры
//  КоллекцияИзмерений - ИзмеренияПостроителяОтчета, коллекция измерений построителя отчета
//
// Возвращаемое значение:
//   Строка - представление измерений построителя отчета
//
Функция СформироватьСтрокуИзмерений(КоллекцияИзмерений) Экспорт

	Если ТипЗнч(КоллекцияИзмерений) <> Тип("ИзмеренияПостроителяОтчета") Тогда
		Возврат "";
	КонецЕсли; 
	
	СтрокаИзмерений = "";
	
	Для а = 0 По КоллекцияИзмерений.Количество() - 1 Цикл
		Если а > 0 Тогда
			СтрокаИзмерений = СтрокаИзмерений + ", ";
		КонецЕсли;
		СтрокаИзмерений = СтрокаИзмерений + КоллекцияИзмерений[а].Представление;
	КонецЦикла;
	
	Возврат СтрокаИзмерений;

КонецФункции // СформироватьСтрокуГруппировок()

// Функция формирует строку представления порядков построителя отчетов
//
// Параметры
//  КоллекцияПорядок - Порядок, коллекция порядков построителя отчета
//
// Возвращаемое значение:
//   Строка - представление порядков построителя отчета
//
Функция СформироватьСтрокуПорядка(КоллекцияПорядок) Экспорт

	Если ТипЗнч(КоллекцияПорядок) <> Тип("Порядок") Тогда
		Возврат "";
	КонецЕсли; 
	
	СтрокаПорядка = "";
	
	Для а = 0 По КоллекцияПорядок.Количество() - 1 Цикл
		Если а > 0 Тогда
			СтрокаПорядка = СтрокаПорядка + ", ";
		КонецЕсли;
		СтрокаПорядка = СтрокаПорядка + КоллекцияПорядок[а].Представление + " " + КоллекцияПорядок[а].Направление;
	КонецЦикла;
	
	Возврат СтрокаПорядка;

КонецФункции // СформироватьСтрокуПорядка()

// Процедура используется в формах настройки отчетов для выбора категории
// или для подбора категорий в список. Использование обусловлено тем,
// что Категории при выборе надо указывать владельца
//
// Параметры:
//	Элемент - элемент управления, в который выбирают категорию
//	Назначение - элемент ПВХ, назначение для категории, известное форме настройки
//	ФормаНастройки - сама форма
//	СтандартнаяОбработка - необходимый параметр процедуры - обработчика события
//
Процедура ОсуществитьВыборКатегории(Элемент, Назначение, ФормаНастройки, СтандартнаяОбработка) Экспорт

	Если ТипЗнч(Элемент.Значение) <> ТипЗнч(Новый СписокЗначений) Тогда

		СтандартнаяОбработка = Ложь;

		ФормаВыбораКатегории= Справочники.КатегорииОбъектов.ПолучитьФормуВыбора(, Элемент,);
		ФормаВыбораКатегории.РежимВыбора = Истина;
		ФормаВыбораКатегории.Отбор.НазначениеКатегории.Установить(Назначение);
		ФормаВыбораКатегории.Открыть();
		
	КонецЕсли;
КонецПроцедуры // ОсуществитьВыборКатегории()

// Процедура используется в формах настройки отчетов для выбора значения свойства
// или для подбора значений свойств в список. Использование обусловлено тем,
// что свойству при выборе надо указывать не только тип значения, но еще и владельца
//
// Параметры:
//	Элемент - элемент управления, в который выбирают свойство
//	Назначение - элемент ПВХ, назначение для свойства, известное форме настройки
//	ФормаНастройки - сама форма
//	СтандартнаяОбработка - необходимый параметр процедуры - обработчика события
//
Процедура ОсуществитьВыборСвойства(Элемент, Свойство, ФормаНастройки, СтандартнаяОбработка) Экспорт
// Ограничение списка свойств
	Если ТипЗнч(Элемент.Значение) <> Тип("СписокЗначений") Тогда

		Если Свойство.ТипЗначения.СодержитТип(Тип("СправочникСсылка.ЗначенияСвойствОбъектов")) Тогда
			Попытка
				Элемент.ВыборПоВладельцу = Свойство;
				СтандартнаяОбработка = Истина;
			Исключение
				МенеджерДанных = Новый("СправочникМенеджер."+Элемент.Значение.Метаданные().Имя);
				ФормаДанных = МенеджерДанных.ПолучитьФормуВыбора(, Элемент);
				ФормаДанных.РежимВыбора = Истина;
				ФормаДанных.МножественныйВыбор = Ложь;
				ФормаДанных.ЭлементыФормы.СправочникСписок.Значение.Отбор.Владелец.Значение = Свойство;
				ФормаДанных.ЭлементыФормы.СправочникСписок.Значение.Отбор.Владелец.Использование = Истина;
				ФормаДанных.Открыть();
				СтандартнаяОбработка = Ложь;
			КонецПопытки;
		Иначе
			СтандартнаяОбработка = истина;
		КонецЕсли;

	КонецЕсли;

КонецПроцедуры // ОсуществитьВыборСвойства()

// Функция определяет, доступен ли элемент отбора с указанным именем для изменения имени, удаления, переименования
// используется в формах настройки отчетов на базе Построителя Отчетов для того, чтобы не удалить в форме
// настройки отбор, связанный с "быстрым отбором", находящимся на основной форме.
//
// Параметры:
//	ИмяЭлементаОтбора               - строка, содержит имя элемента отбора.
//	СтруктураСвязиЭлементовСДанными - структура, возвращаемая в один из параметров методом 
//                                    отУстановитьСвязьПолейБыстрогоОтбораНаФорме
//
Функция ОтборСвязанСДанными(ИмяЭлементаОтбора, СтруктураСвязиЭлементовСДанными) Экспорт

	Если СтруктураСвязиЭлементовСДанными.Свойство("ФлажокНастройки"+ИмяЭлементаОтбора)
		ИЛИ СтруктураСвязиЭлементовСДанными.Свойство("ПолеВидаСравнения"+ИмяЭлементаОтбора)
		ИЛИ СтруктураСвязиЭлементовСДанными.Свойство("ПолеНастройки"+ИмяЭлементаОтбора)
		ИЛИ СтруктураСвязиЭлементовСДанными.Свойство("ПолеНастройкиС"+ИмяЭлементаОтбора)
		ИЛИ СтруктураСвязиЭлементовСДанными.Свойство("ПолеНастройкиПо"+ИмяЭлементаОтбора) Тогда

		Возврат Истина;

	Иначе

		Возврат Ложь;

	КонецЕсли;

КонецФункции //отОтборСвязанСДанными()
////////////////////////////////////////////////////////////////////////////////////////////////////
// ПРОЦЕДУРЫ РАБОТЫ С КОЛОНТИТУЛАМИ

// Чтение настроек колонтитулов из константы. Если константа не заполнена, то формируются пустые настройки.
//
// Параметры
//  Нет
//
// Возвращаемое значение:
//   Структура   – Настройки колонтитулов
//
Функция ПолучитьНастройкиКолонтитулов()

	Настройка = Константы.НастройкиКолонтитуловПоУмолчанию.Получить().Получить();
	
	Если ТипЗнч(Настройка) <> Тип("Структура") Тогда
		// Если константа не заполнена, то заполним структуру настройками пустых колонтитулов
		
		Настройка = Новый Структура;
		
		Верхний = Новый Структура;
		Нижний = Новый Структура;
		
		Верхний.Вставить("Выводить", Ложь);
		Верхний.Вставить("НачальнаяСтраница", 1);
		Верхний.Вставить("ТекстСлева",   "");
		Верхний.Вставить("ТекстВЦентре", "");
		Верхний.Вставить("ТекстСправа",  "");
		
		Нижний.Вставить("Выводить", Ложь);
		Нижний.Вставить("НачальнаяСтраница", 1);
		Нижний.Вставить("ТекстСлева",   "");
		Нижний.Вставить("ТекстВЦентре", "");
		Нижний.Вставить("ТекстСправа",  "");
		
		Настройка.Вставить("ВерхнийКолонтитул", Верхний);
		Настройка.Вставить("НижнийКолонтитул",  Нижний);
		
	Иначе
		// Если константа заполнена, но нет нужных нам полей, то заполним структуру настройками пустых колонтитулов
	
		Если Не Настройка.Свойство("ВерхнийКолонтитул") Тогда
			
			Верхний = Новый Структура;
			
			Верхний.Вставить("Выводить", Ложь);
			Верхний.Вставить("НачальнаяСтраница", 1);
			Верхний.Вставить("ТекстСлева",   "");
			Верхний.Вставить("ТекстВЦентре", "");
			Верхний.Вставить("ТекстСправа",  "");
			
			Настройка.Вставить("ВерхнийКолонтитул", Верхний);
			
		КонецЕсли;
		
		Если Не Настройка.Свойство("НижнийКолонтитул") Тогда
			
			Нижний = Новый Структура;
			
			Нижний.Вставить("Выводить", Ложь);
			Нижний.Вставить("НачальнаяСтраница", 1);
			Нижний.Вставить("ТекстСлева",   "");
			Нижний.Вставить("ТекстВЦентре", "");
			Нижний.Вставить("ТекстСправа",  "");
			
			Настройка.Вставить("НижнийКолонтитул",  Нижний);
			
		КонецЕсли;
		
	КонецЕсли;
	
	Возврат Настройка;

КонецФункции // ПолучитьНастройкиКолонтитулов()

// Запись настроек колонтитулов в константу
//
// Параметры
//  Настройка  – Структура – Настройка колонтитулов
//
Процедура ЗаписатьНастройкиКолонтитулов(Настройка)

	Константы.НастройкиКолонтитуловПоУмолчанию.Установить(Новый ХранилищеЗначения(Настройка));

КонецПроцедуры // ЗаписатьНастройкиКолонтитулов()

// Проставление в тексте вместо шаблонов, значений
//
// Параметры
//  Текст           – Строка – Исходный текст шаблона
//  НазваниеОтчета  – Строка – Название отчета
//  Пользователь    – Строка – Имя пользователя
//
// Возвращаемое значение:
//   Строка   – результурующий текст для колонтитула
//
Функция ЗаполнитьТекстКолонтитула(Текст, НазваниеОтчета, Пользователь)

	Результат = Текст;
	
	Результат = СтрЗаменить(Результат, "[&НазваниеОтчета]", НазваниеОтчета);
	Результат = СтрЗаменить(Результат, "[&Пользователь]", Пользователь);
	
	Возврат Результат;

КонецФункции // ЗаполнитьТекстКолонтитула()

// Установка колонтитулов для отчета
//
// Параметры
//  ТабличныйДокумент  – ТабличныйДокумент – Отчет, у которого необходимо установить колонтитулы
//  НазваниеОтчета     – Строка            – Название отчета для вывода в колонтитул
//  Пользователь       – Строка            – Имя пользователя для вывода в колонтитул
//
Процедура УстановитьКолонтитулыПоУмолчанию(ТабличныйДокумент, НазваниеОтчета, Пользователь) Экспорт

	Настройка = ПолучитьНастройкиКолонтитулов();
	
	ТабличныйДокумент.ВерхнийКолонтитул.Выводить          = Настройка.ВерхнийКолонтитул.Выводить;
	ТабличныйДокумент.ВерхнийКолонтитул.НачальнаяСтраница = Настройка.ВерхнийКолонтитул.НачальнаяСтраница;
	ТабличныйДокумент.ВерхнийКолонтитул.ВертикальноеПоложение = ВертикальноеПоложение.Низ;
	ТабличныйДокумент.ВерхнийКолонтитул.ТекстСлева   = ЗаполнитьТекстКолонтитула(Настройка.ВерхнийКолонтитул.ТекстСлева, НазваниеОтчета, Пользователь);
	ТабличныйДокумент.ВерхнийКолонтитул.ТекстВЦентре = ЗаполнитьТекстКолонтитула(Настройка.ВерхнийКолонтитул.ТекстВЦентре, НазваниеОтчета, Пользователь);
	ТабличныйДокумент.ВерхнийКолонтитул.ТекстСправа  = ЗаполнитьТекстКолонтитула(Настройка.ВерхнийКолонтитул.ТекстСправа, НазваниеОтчета, Пользователь);
	
	ТабличныйДокумент.НижнийКолонтитул.Выводить          = Настройка.НижнийКолонтитул.Выводить;
	ТабличныйДокумент.НижнийКолонтитул.НачальнаяСтраница = Настройка.НижнийКолонтитул.НачальнаяСтраница;
	ТабличныйДокумент.НижнийКолонтитул.ВертикальноеПоложение = ВертикальноеПоложение.Верх;
	ТабличныйДокумент.НижнийКолонтитул.ТекстСлева   = ЗаполнитьТекстКолонтитула(Настройка.НижнийКолонтитул.ТекстСлева, НазваниеОтчета, Пользователь);
	ТабличныйДокумент.НижнийКолонтитул.ТекстВЦентре = ЗаполнитьТекстКолонтитула(Настройка.НижнийКолонтитул.ТекстВЦентре, НазваниеОтчета, Пользователь);
	ТабличныйДокумент.НижнийКолонтитул.ТекстСправа  = ЗаполнитьТекстКолонтитула(Настройка.НижнийКолонтитул.ТекстСправа, НазваниеОтчета, Пользователь);
	
КонецПроцедуры // УстановитьКолонтитулы()

// Открыть форму настройки колонтитулов и по завершению работы записать настройки.
//
// Параметры
//  Нет
//
Процедура ОткрытьНастройкуКолонтитулов() Экспорт

	Настройка = ПолучитьНастройкиКолонтитулов();
	
	ФормаНастройки = ПолучитьОбщуюФорму("ФормаНастройкиКолонтитулов");
	
	Для каждого Элемент Из Настройка.ВерхнийКолонтитул Цикл
		ФормаНастройки.ВерхнийКолонтитул.Вставить(Элемент.Ключ, Элемент.Значение);
	КонецЦикла;
	Для каждого Элемент Из Настройка.НижнийКолонтитул Цикл
		ФормаНастройки.НижнийКолонтитул.Вставить(Элемент.Ключ, Элемент.Значение);
	КонецЦикла;
	
	Результат = ФормаНастройки.ОткрытьМодально();
	Результат = ?(Результат = Неопределено, Ложь, Результат);
	
	Если Результат Тогда
		
		Для каждого Элемент Из ФормаНастройки.ВерхнийКолонтитул Цикл
			Настройка.ВерхнийКолонтитул.Вставить(Элемент.Ключ, Элемент.Значение);
		КонецЦикла;
		Для каждого Элемент Из ФормаНастройки.НижнийКолонтитул Цикл
			Настройка.НижнийКолонтитул.Вставить(Элемент.Ключ, Элемент.Значение);
		КонецЦикла;
		
		ЗаписатьНастройкиКолонтитулов(Настройка);
		
	КонецЕсли;
	
КонецПроцедуры // ОткрытьНастройкуКолонтитулов()


#Если Клиент Тогда

Функция НайтиВладельцаПоФорме(ОтчетОбъект, ЭтаФорма, Элемент, ПолеОтбора, ПолеЗначения) Экспорт
	ЗначениеВладельца = Неопределено;
	Отбор = ТиповыеОтчеты.ПолучитьОтборИзФормы(ОтчетОбъект, ЭтаФорма, Элемент);
	Если Отбор.СтрокаОтбора.Поле = ПолеОтбора или ПолеОтбора.НайтиПоЗначению(Отбор.СтрокаОтбора.Поле) <> Неопределено тогда
		Отбор = ТиповыеОтчеты.ПолучитьОтборИзФормы(ОтчетОбъект, ЭтаФорма, ПолеЗначения);
		Если Отбор <> Неопределено тогда
			ЗначениеВладельца = Отбор.Значение;
		КонецЕсли;
		Параметр = ТиповыеОтчеты.ПолучитьПараметрИзФормы(ОтчетОбъект, ЭтаФорма, ПолеЗначения);
		Если ЗначениеВладельца = Неопределено и Параметр <> Неопределено тогда
			ЗначениеВладельца = Параметр.Значение;
		КонецЕсли;
		
		Если ТипЗнч(ЗначениеВладельца) = Тип("СписокЗначений") тогда
			Если ЗначениеВладельца.Количество() > 0 тогда
				ЗначениеВладельца = ЗначениеВладельца.Получить(0).Значение;
			КонецЕсли;
		ИначеЕсли ТипЗнч(ЗначениеВладельца) = Тип("ТаблицаЗначений") тогда
			Если ЗначениеВладельца.Количество() > 0 тогда
				ЗначениеВладельца = ЗначениеВладельца.Получить(0).Значение;
			КонецЕсли;
		КонецЕсли;
	КонецЕсли;
	Возврат ЗначениеВладельца;
КонецФункции

// Функция открывает диалог для настройки периода
//
// Параметры
//  ДатаНач - Дата, начало периода
//  ДатаКон - Дата, конец периода
//
// Возвращаемое значение:
//   Массив - массив с датами начала и окончания выбранного периода
//
Функция ВвестиПериод(ДатаНач, ДатаКон) Экспорт
	
	Период = Новый НастройкаПериода;

	Период.ВариантНастройки = ВариантНастройкиПериода.Интервал;
	Период.УстановитьПериод(НачалоДня(ДатаНач), ?(НачалоДня(ДатаКон) = Дата("00010101000000"), НачалоДня(ДатаКон), КонецДня(ДатаКон)));
	
	Если ДатаНач = Дата("00010101000000") Тогда
		Период.ВариантНачала = ВариантГраницыИнтервала.БезОграничения;
	ИначеЕсли НачалоДня(ДатаНач) = НачалоГода(ТекущаяДата()) Тогда
		Период.ВариантНачала = ВариантГраницыИнтервала.Год;
	ИначеЕсли НачалоДня(ДатаНач) = НачалоКвартала(ТекущаяДата()) Тогда
		Период.ВариантНачала = ВариантГраницыИнтервала.Квартал;
	ИначеЕсли НачалоДня(ДатаНач) = НачалоМесяца(ТекущаяДата()) Тогда
		Период.ВариантНачала = ВариантГраницыИнтервала.Месяц;
	ИначеЕсли НачалоДня(ДатаНач) = НачалоНедели(ТекущаяДата()) Тогда
		Период.ВариантНачала = ВариантГраницыИнтервала.Неделя;
	ИначеЕсли НачалоДня(ДатаНач) = НачалоДня(ТекущаяДата()) Тогда
		Период.ВариантНачала = ВариантГраницыИнтервала.РабочаяДата;
	Иначе
		Период.ДатаНачала        = ДатаНач;
		Период.ВариантНачала     = ВариантГраницыИнтервала.КонкретнаяДата;
	КонецЕсли; 

	Если ДатаКон = Дата("00010101000000") Тогда
		Период.ВариантОкончания = ВариантГраницыИнтервала.БезОграничения;
	ИначеЕсли КонецДня(ДатаКон) = КонецГода(ТекущаяДата()) Тогда
		Период.ВариантОкончания = ВариантГраницыИнтервала.Год;
	ИначеЕсли КонецДня(ДатаКон) = КонецКвартала(ТекущаяДата()) Тогда
		Период.ВариантОкончания = ВариантГраницыИнтервала.Квартал;
	ИначеЕсли КонецДня(ДатаКон) = КонецМесяца(ТекущаяДата()) Тогда
		Период.ВариантОкончания = ВариантГраницыИнтервала.Месяц;
	ИначеЕсли КонецДня(ДатаКон) = КонецНедели(ТекущаяДата()) Тогда
		Период.ВариантОкончания = ВариантГраницыИнтервала.Неделя;
	ИначеЕсли КонецДня(ДатаКон) = КонецДня(ТекущаяДата()) Тогда
		Период.ВариантОкончания = ВариантГраницыИнтервала.РабочаяДата;
	Иначе
		Период.ДатаОкончания    = ДатаКон;
		Период.ВариантОкончания = ВариантГраницыИнтервала.КонкретнаяДата;
	КонецЕсли; 

	Если НЕ Период.Редактировать() Тогда
		Возврат Неопределено;
	КонецЕсли;

	Если Период.ВариантНачала = ВариантГраницыИнтервала.БезОграничения Тогда
		ДатаНач = Дата("00010101000000");
	ИначеЕсли Период.ВариантНачала = ВариантГраницыИнтервала.Год Тогда
		ДатаНач = НачалоГода(ТекущаяДата());
	ИначеЕсли Период.ВариантНачала = ВариантГраницыИнтервала.Квартал Тогда
		ДатаНач = НачалоКвартала(ТекущаяДата());
	ИначеЕсли Период.ВариантНачала = ВариантГраницыИнтервала.Месяц Тогда
		ДатаНач = НачалоМесяца(ТекущаяДата());
	ИначеЕсли Период.ВариантНачала = ВариантГраницыИнтервала.Неделя Тогда
		ДатаНач = НачалоНедели(ТекущаяДата());
	ИначеЕсли Период.ВариантНачала = ВариантГраницыИнтервала.РабочаяДата Тогда
		ДатаНач = НачалоДня(ТекущаяДата());
	Иначе
		ДатаНач = НачалоДня(Период.ДатаНачала);
	КонецЕсли; 

	Если Период.ВариантОкончания = ВариантГраницыИнтервала.БезОграничения Тогда
		ДатаКон = Дата("00010101000000");
	ИначеЕсли Период.ВариантОкончания = ВариантГраницыИнтервала.Год Тогда
		ДатаКон = КонецГода(ТекущаяДата());
	ИначеЕсли Период.ВариантОкончания = ВариантГраницыИнтервала.Квартал Тогда
		ДатаКон = КонецКвартала(ТекущаяДата());
	ИначеЕсли Период.ВариантОкончания = ВариантГраницыИнтервала.Месяц Тогда
		ДатаКон = КонецМесяца(ТекущаяДата());
	ИначеЕсли Период.ВариантОкончания = ВариантГраницыИнтервала.Неделя Тогда
		ДатаКон = КонецНедели(ТекущаяДата());
	ИначеЕсли Период.ВариантОкончания = ВариантГраницыИнтервала.РабочаяДата Тогда
		ДатаКон = КонецДня(ТекущаяДата());
	Иначе
		ДатаКон = ?((Период.ДатаОкончания = Дата("000101010000")), Период.ДатаОкончания,(КонецДня(Период.ДатаОкончания)));
	КонецЕсли; 
	
	МассивВозврата = Новый Массив;

	МассивВозврата.Добавить(ДатаНач);
	МассивВозврата.Добавить(ДатаКон);

	Возврат МассивВозврата;
	
КонецФункции // ВвестиПериод()

#КонецЕсли


 // Процедура меняет название полей, содержащих название организации, на учереждение
 //
 Процедура ЗаменитьНазваниеПолейСхемыКомпоновкиДанных(СхемаКомпоновкиДанных) Экспорт
	Для каждого НаборДанных из СхемаКомпоновкиДанных.НаборыДанных Цикл
		Для каждого Поле из НаборДанных.Поля Цикл
			Поле.Заголовок = ОбщегоНазначения.ПреобразоватьСтрокуИнтерфейса(Поле.Заголовок);
		КонецЦикла;
	КонецЦикла;
	Для каждого Поле из СхемаКомпоновкиДанных.ВычисляемыеПоля Цикл
		Поле.Заголовок = ОбщегоНазначения.ПреобразоватьСтрокуИнтерфейса(Поле.Заголовок);
	КонецЦикла;
	Для каждого Параметр из СхемаКомпоновкиДанных.Параметры Цикл
		Параметр.Заголовок = ОбщегоНазначения.ПреобразоватьСтрокуИнтерфейса(Параметр.Заголовок);
	КонецЦикла;
	Параметр = СхемаКомпоновкиДанных.НастройкиПоУмолчанию.ПараметрыВывода.НайтиЗначениеПараметра(Новый ПараметрКомпоновкиДанных("Title"));
	Параметр.Значение = ОбщегоНазначения.ПреобразоватьСтрокуИнтерфейса(Параметр.Значение);
Конецпроцедуры

////////////////////////////////////////////////////////////////////////////////
// ПРОЦЕДУРЫ И ФУНКЦИИ РАБОТЫ С НАСТРОЙКАМИ

// Функция формирует структуру с данными отбора
//
// Параметры
//  Отбор - Отбор
//
// Возвращаемое значение:
//   Структура
//
Функция ПолучитьСтруктуруОтбора(Отбор) Экспорт

	СтруктураОтбора = Новый Структура();
	Для каждого ЭлементОтбора Из Отбор Цикл
		СтрктураЭлементаОтбора = Новый Структура;
		СтрктураЭлементаОтбора.Вставить("ВидСравнения" , ЭлементОтбора.ВидСравнения);
		СтрктураЭлементаОтбора.Вставить("Значение"     , ЭлементОтбора.Значение);
		СтрктураЭлементаОтбора.Вставить("ЗначениеПо"   , ЭлементОтбора.ЗначениеПо);
		СтрктураЭлементаОтбора.Вставить("ЗначениеС"    , ЭлементОтбора.ЗначениеС);
		СтрктураЭлементаОтбора.Вставить("Имя"          , ЭлементОтбора.Имя);
		СтрктураЭлементаОтбора.Вставить("Использование", ЭлементОтбора.Использование);
		СтрктураЭлементаОтбора.Вставить("Представление", ЭлементОтбора.Представление);
		СтрктураЭлементаОтбора.Вставить("ПутьКДанным"  , ЭлементОтбора.ПутьКДанным);
		СтрктураЭлементаОтбора.Вставить("ТипЗначения"  , ЭлементОтбора.ТипЗначения);
		СтруктураОтбора.Вставить("Отбор" + Строка(Отбор.Индекс(ЭлементОтбора)), СтрктураЭлементаОтбора);
	КонецЦикла; 

	Возврат СтруктураОтбора;
	
КонецФункции // ПолучитьСтруктуруОтбора()

Процедура ДобавитьВТекстСВойстваОбщие(Текст, Знач ТекстПоляСвойств, ЗаменятьСвойстваОбщие="//СВОЙСТВА_ОБЩИЕ") Экспорт
	
	ТекстПоляСвойств=ТекстПоляСвойств+",";
	ТекстПсевдонимыСвойств = "";
	
	Пока Найти(ТекстПоляСвойств, "КАК")>0 Цикл
		
		// Псевдоним поля свойства находится между КАК и ,
		ПсевдонимПоляСвойства = Сред(ТекстПоляСвойств, Найти(ТекстПоляСвойств, "КАК")+4);
		
		ПсевдонимПоляСвойства = Лев(ПсевдонимПоляСвойства, Найти(ПсевдонимПоляСвойства, ",")-1);
		
		ТекстПсевдонимыСвойств = ТекстПсевдонимыСвойств + ", " + ПсевдонимПоляСвойства;
		
		ТекстПоляСвойств = Сред(ТекстПоляСвойств, Найти(ТекстПоляСвойств, "КАК") + СтрДлина(ПсевдонимПоляСвойства)+2)
		
	КонецЦикла;
	
	Текст = СтрЗаменить(Текст, ЗаменятьСвойстваОбщие, ТекстПсевдонимыСвойств);
	
КонецПроцедуры // ДобавитьВТекстСВойстваОбщие()

// Процедура заполнения начальных настроек по макету для универсального отчета или отчета на базе универсального
Процедура ЗаполнитьНачальныеНастройкиПоМакету(МакетПараметрыОтчетов, СтруктураПредставлениеПолей, МассивОтбора, Контекст, ТипОтчета) Экспорт

	ИмяРегистра = Контекст.ИмяРегистра;
	ПОстроительОтчета = Контекст.ПостроительОтчета;

	Контекст.Показатели.Очистить();

	//Очистим отбор
	Пока ПостроительОтчета.Отбор.Количество()>0 Цикл
		ПостроительОтчета.Отбор.Удалить(0);
	КонецЦикла; 

	//Очистим порядок
	Пока ПостроительОтчета.Порядок.Количество()>0 Цикл
		ПостроительОтчета.Порядок.Удалить(0);
	КонецЦикла; 

	ТекстПоляЗапроса = "";
	ТекстПоляИтоговЗапроса = "";
	ТекстПоляПоказатели = "";
	ТекстПоляИтогов = "";
	ТекстВыводимыеПоляЗапроса = "";
	ТекстПоляУпорядочивания = "";
	ТекстПоляИзмерений = "";

	ТекстВыводимыеПоляПериоды = "";
	ТекстПоляИтоговПериоды = "";

	ТекстИсточникиСведений ="";
	ТекстПоляКатегорий = "";
	ТекстПоляГруппировки = "";

	Если НЕ ЗначениеЗаполнено(Контекст.мНазваниеОтчета) И Не ПустаяСтрока(ИмяРегистра) Тогда

		Контекст.мНазваниеОтчета = Метаданные.РегистрыНакопления[ИмяРегистра].Представление() + ?(ТипОтчета = "ОстаткиИОбороты", ": остатки и обороты", "");

	КонецЕсли; 

	ОбластьПоказатели = МакетПараметрыОтчетов.ПолучитьОбласть("Показатели");

	ОбластьПоказателиВысота = ОбластьПоказатели.ВысотаТаблицы;

	ВидРегистра = Метаданные.РегистрыНакопления[ИмяРегистра].ВидРегистра;

	МассивИзмеренийКолонки = Новый Массив;
	
	МассивВыбранныеПоляПоУмолчанию = Новый Массив;
	
	МассивИзмеренияСтрокиПоУмолчанию = Новый Массив;
	
	
	Если (ТипОтчета = "СписокКроссТаблица") или (ТипОтчета = "Диаграмма") Тогда

		Если ВидРегистра = Метаданные.СвойстваОбъектов.ВидРегистраНакопления.Остатки Тогда
			ТипПоляРегистра="Остаток";

			// Отчеты по остаткам - на дату
			Контекст.мРежимВводаПериода = 1;
			
		ИначеЕсли ВидРегистра = Метаданные.СвойстваОбъектов.ВидРегистраНакопления.Обороты Тогда
			ТипПоляРегистра="Оборот";

			Контекст.мРежимВводаПериода = 0;
		КонецЕсли;
	КонецЕсли;

	Для НСтр = 1 По ОбластьПоказателиВысота Цикл

		// Добавляем строки, если возможен вывод не только оборотов, но и остатков
		Если НЕ Булево(СокрЛП(ОбластьПоказатели.Область(НСтр, 4).Текст)) Тогда

			ИмяПоля           = СокрЛП(ОбластьПоказатели.Область(НСтр, 1).Текст);
			ПредставлениеПоля = СокрЛП(ОбластьПоказатели.Область(НСтр, 2).Текст);
			ОписаниеПоля      = СокрЛП(ОбластьПоказатели.Область(НСтр, 3).Текст);
			ВклПоУмолчанию    = Булево(СокрЛП(ОбластьПоказатели.Область(НСтр, 5).Текст));
			ФорматнаяСтрока   = СокрЛП(ОбластьПоказатели.Область(НСтр, 6).Текст);
			СтрИзмерения      = СокрЛП(ОбластьПоказатели.Область(НСтр, 7).Текст);
			СтдВалюта         = СокрЛП(ОбластьПоказатели.Область(НСтр, 8).Текст);

			Если Врег(СтдВалюта) = "УПР" Тогда
				ПредставлениеПоля = ПредставлениеПоля + " в " +глЗначениеПеременной("ВалютаУправленческогоУчета");
			ИначеЕсли Врег(СтдВалюта) = "РЕГЛ" Тогда
				ПредставлениеПоля = ПредставлениеПоля + " в " +глЗначениеПеременной("ВалютаРегламентированногоУчета");
			ИначеЕсли Врег(СтдВалюта) = "МСФО" Тогда
				ПредставлениеПоля = ПредставлениеПоля + " в " +глЗначениеПеременной("ВалютаМеждународногоУчета");
			КонецЕсли;

			Контекст.мСтруктураСвязиПоказателейИИзмерений.Вставить(ИмяПоля, Новый Структура(СтрИзмерения));

			Если ПустаяСтрока(ОписаниеПоля) Тогда
				ОписаниеПоля = ИмяПоля;
			КонецЕсли;

			Если (ТипОтчета = "СписокКроссТаблица") Или (ТипОтчета = "Диаграмма") Тогда
				ТекстПоляПоказатели = ТекстПоляПоказатели + ",
				|	" + СтрЗаменить("СУММА("+ОписаниеПоля+")","#", ТипПоляРегистра) + " КАК " + ИмяПоля;

				ТекстПоляИтоговЗапроса = ТекстПоляИтоговЗапроса + ",
				|	СУММА(" + ИмяПоля + ")";

				ТекстПоляУпорядочивания = ТекстПоляУпорядочивания + ",
				|	" + ИмяПоля;

				СтруктураПредставлениеПолей.Вставить(ИмяПоля, ПредставлениеПоля);
			ИначеЕсли ТипОтчета = "ОстаткиИОбороты" Тогда

				ТекстПоляПоказатели = ТекстПоляПоказатели + ",
				|	" + СтрЗаменить("СУММА("+ОписаниеПоля+")","#", "НачальныйОстаток") + " КАК " + ИмяПоля + "НачальныйОстаток,
				|	" + СтрЗаменить("СУММА("+ОписаниеПоля+")","#", "КонечныйОстаток")  + " КАК " + ИмяПоля + "КонечныйОстаток,
				|	" + СтрЗаменить("СУММА("+ОписаниеПоля+")","#", "Приход") 		  + " КАК " + ИмяПоля + "Приход,
				|	" + СтрЗаменить("СУММА("+ОписаниеПоля+")","#", "Расход") 		  + " КАК " + ИмяПоля + "Расход";

				ТекстПоляИтоговЗапроса = ТекстПоляИтоговЗапроса + ",
				|	СУММА(" + ИмяПоля + "НачальныйОстаток),
				|	СУММА(" + ИмяПоля + "КонечныйОстаток),
				|	СУММА(" + ИмяПоля + "Приход),
				|	СУММА(" + ИмяПоля + "Расход)";

				ТекстПоляУпорядочивания = ТекстПоляУпорядочивания + ",
				|	" + ИмяПоля + "НачальныйОстаток,
				|	" + ИмяПоля + "КонечныйОстаток,
				|	" + ИмяПоля + "Приход,
				|	" + ИмяПоля + "Расход";

				СтруктураПредставлениеПолей.Вставить(ИмяПоля+"НачальныйОстаток", ПредставлениеПоля + " нач.ост.");
				СтруктураПредставлениеПолей.Вставить(ИмяПоля+"КонечныйОстаток", ПредставлениеПоля + " кон.ост." );
				СтруктураПредставлениеПолей.Вставить(ИмяПоля+"Приход", ПредставлениеПоля+" приход");
				СтруктураПредставлениеПолей.Вставить(ИмяПоля+"Расход", ПредставлениеПоля+" расход");
			КОнецЕсли;

			// Показатели заносятся в специальную таблицу 
			СтрПоказатели = Контекст.мТаблицаПоказатели.Добавить();
			СтрПоказатели.ИмяПоля           = ИмяПоля;
			СтрПоказатели.ПредставлениеПоля = ПредставлениеПоля;
			СтрПоказатели.ФорматнаяСтрока   = ФорматнаяСтрока;

			// ... и добавляются в список
			Показатель = Контекст.Показатели.Добавить();
			Показатель.Имя           = ИмяПоля;
			Показатель.Представление = ПредставлениеПоля;
			Показатель.Использование = ВклПоУмолчанию;

		КонецЕсли; 
	КонецЦикла;

	ОбластьГруппировки = МакетПараметрыОтчетов.ПолучитьОбласть("Группировки");

	ОбластьГруппировкиВысота = ОбластьГруппировки.ВысотаТаблицы;

	ОписаниеТиповКатегории = Новый ОписаниеТипов("СправочникСсылка.КатегорииОбъектов");

	Запрос = Новый Запрос;

	Запрос.Текст = "";

	ТаблицаПолей = Новый ТаблицаЗначений;
	ТаблицаПолей.Колонки.Добавить("ПутьКДанным");  // описание поля запроса поля, для которого добавляются свойства и
	                                               // категории. Используется в условии соединения с регистром сведений,
	                                               // хранящим значения свойств или категорий
	ТаблицаПолей.Колонки.Добавить("Представление");// представление поля, для которого добавляются свойства и категории. 
	ТаблицаПолей.Колонки.Добавить("Назначение");   // назначение свойств/категорий объектов для данного поля
//	ТаблицаПолей.Колонки.Добавить("ТипЗначения");  // тип значения поля, для которого добавляются свойства и категории.
	                                               // Не используется.
	ТаблицаПолей.Колонки.Добавить("НетКатегорий"); // признак НЕиспользования категорий для объекта

	Для НСтр = 1 По ОбластьГруппировкиВысота Цикл

		// Добавляем строки, если возможен вывод не только оборотов но и остатков.
		Если НЕ Булево(СокрЛП(ОбластьГруппировки.Область(НСтр, 4).Текст)) Тогда

			ИмяПоля           = СокрЛП(ОбластьГруппировки.Область(НСтр, 1).Текст);
			ПредставлениеПоля = СокрЛП(ОбластьГруппировки.Область(НСтр, 2).Текст);
			ОписаниеПоля      = СокрЛП(ОбластьГруппировки.Область(НСтр, 3).Текст);
			ВклПоУмолчанию    = Булево(СокрЛП(ОбластьГруппировки.Область(НСтр, 5).Текст));
			Если (ТипОтчета = "Диаграмма") Тогда
				РассчитыватьИтоги = Булево(СокрЛП(ОбластьГруппировки.Область(НСтр, 6).Текст));
				РассчитыватьИтогиПоИерархии = Булево(СокрЛП(ОбластьГруппировки.Область(НСтр, 7).Текст));
				ВклВОтбор    = Булево(СокрЛП(ОбластьГруппировки.Область(НСтр, 13).Текст));
			Иначе
				ФорматнаяСтрока   = СокрЛП(ОбластьГруппировки.Область(НСтр, 6).Текст);
				РассчитыватьИтоги = Булево(СокрЛП(ОбластьГруппировки.Область(НСтр, 7).Текст));
				РассчитыватьИтогиПоИерархии = Булево(СокрЛП(ОбластьГруппировки.Область(НСтр, 8).Текст));
				ВклВОтбор    = Булево(СокрЛП(ОбластьГруппировки.Область(НСтр, 11).Текст));
			КонецЕсли;
			
			Если (ТипОтчета = "СписокКроссТаблица") Или (ТипОтчета = "Диаграмма") Тогда
				ИтогВКолонке      = Булево(СокрЛП(ОбластьГруппировки.Область(НСтр, 9).Текст));
			КонецЕсли;


			Если НЕ ПустаяСтрока(ФорматнаяСтрока) Тогда
				Контекст.СтруктураФорматаПолей.Вставить(ИмяПоля, ФорматнаяСтрока);
			КонецЕсли;

			Если ПустаяСтрока(ОписаниеПоля) Тогда
				ОписаниеПоля = ИмяПоля;
			КонецЕсли;

			// Для итогов
			ТекстПоляИтогов = ТекстПоляИтогов + ",
			|	" + ОписаниеПоля + ".* КАК " + ИмяПоля;

			// Для списка всех полей
			ТекстВыводимыеПоляЗапроса = ТекстВыводимыеПоляЗапроса + ",
			|	" + ОписаниеПоля + ".* КАК " + ИмяПоля;

			Если ВклПоУмолчанию Тогда // добавим сразу в список полей

				МассивВыбранныеПоляПоУмолчанию.Добавить(ИмяПоля);

				Если РассчитыватьИтоги Тогда // добавим сразу в итоги

					МассивИзмеренияСтрокиПоУмолчанию.Добавить(ИмяПоля);

				КонецЕсли;

				Если (ТипОтчета = "СписокКроссТаблица") Или (ТипОтчета = "Диаграмма") Тогда
					Если ИтогВКолонке Тогда
						МассивИзмеренийКолонки.Добавить(ИмяПоля);
					КонецЕсли;
				КонецЕсли;

			КонецЕсли; 

			Если ВклВОтбор Тогда

				МассивОтбора.Добавить(ИмяПоля);

			КонецЕсли;

			СтруктураПредставлениеПолей.Вставить(ИмяПоля, ПредставлениеПоля);

			СтрНазначение = СокрЛП(ОбластьГруппировки.Область(НСтр, 10).Текст);

			Индекс = Нстр-1;

			Если Не ПустаяСтрока(СтрНазначение) Тогда
				Назначение = ПланыВидовХарактеристик.НазначенияСвойствКатегорийОбъектов[Лев(СтрНазначение, Найти(СтрНазначение+",", ",")-1)];
			Иначе
				Назначение = Неопределено;
			КонецЕсли;

			Если Контекст.ИспользоватьСвойстваИКатегории И Назначение <> Неопределено Тогда

				НоваяСтрока = ТаблицаПолей.Добавить();
				НоваяСтрока.ПутьКДанным = ОписаниеПоля;
				НоваяСтрока.Представление = ПредставлениеПоля;
				НоваяСтрока.Назначение = Назначение;

			КонецЕсли;

		КонецЕсли;
	КонецЦикла;

	// Предопределенные группировки по стандартным периодам
	
	ТекстПоляГде = Сред(ТекстВыводимыеПоляЗапроса, 2);

	Если ((ВидРегистра = Метаданные.СвойстваОбъектов.ВидРегистраНакопления.Обороты) И ((ТипОтчета = "СписокКроссТаблица")ИЛИ(ТипОтчета = "Диаграмма"))) ИЛИ (ТипОтчета = "ОстаткиИОбороты") Тогда

		// Для списка всех полей
		ТекстПоляИтоговПериоды = ТекстПоляИтоговПериоды + ",
		|	НачалоПериода(Период, День) КАК ПериодДень ,
		|	НачалоПериода(Период, Неделя) КАК ПериодНеделя ,
		|	НачалоПериода(Период, Декада) КАК ПериодДекада ,
		|	НачалоПериода(Период, Месяц) КАК ПериодМесяц ,
		|	НачалоПериода(Период, Квартал) КАК ПериодКвартал ,
		|	НачалоПериода(Период, Полугодие) КАК ПериодПолугодие ,
		|	НачалоПериода(Период, Год) КАК ПериодГод";

		ТекстВыводимыеПоляПериоды = ТекстВыводимыеПоляПериоды + ",
		|	НачалоПериода(Период, День) КАК ПериодДень ,
		|	НачалоПериода(Период, Неделя) КАК ПериодНеделя ,
		|	НачалоПериода(Период, Декада) КАК ПериодДекада ,
		|	НачалоПериода(Период, Месяц) КАК ПериодМесяц ,
		|	НачалоПериода(Период, Квартал) КАК ПериодКвартал ,
		|	НачалоПериода(Период, Полугодие) КАК ПериодПолугодие ,
		|	НачалоПериода(Период, Год) КАК ПериодГод";

		СтруктураПредставлениеПолей.Вставить("Период", "Период");
		СтруктураПредставлениеПолей.Вставить("ПериодДень", "По дням");
		СтруктураПредставлениеПолей.Вставить("ПериодНеделя", "По неделям");
		СтруктураПредставлениеПолей.Вставить("ПериодДекада", "По декадам");
		СтруктураПредставлениеПолей.Вставить("ПериодМесяц", "По месяцам");
		СтруктураПредставлениеПолей.Вставить("ПериодКвартал", "По кварталам");
		СтруктураПредставлениеПолей.Вставить("ПериодПолугодие", "По полугодиям");
		СтруктураПредставлениеПолей.Вставить("ПериодГод", "По годам");

		// Для списка всех полей
		ТекстВыводимыеПоляЗапроса = ТекстВыводимыеПоляЗапроса + ",
		|	Период ,
		|	Регистратор.* КАК Регистратор";

		СтруктураПредставлениеПолей.Вставить("Регистратор", "Документ движения (Регистратор)");
	КонецЕсли;

	Текст = 
	"ВЫБРАТЬ РАЗРЕШЕННЫЕ //РАЗЛИЧНЫЕ" 
	+ Сред(ТекстПоляЗапроса + ТекстПоляПоказатели,2) 
	+ Символы.ПС + "{ВЫБРАТЬ " + Сред(ТекстВыводимыеПоляЗапроса+ТекстПоляПоказатели+"
	|	//СВОЙСТВА
	|"+ТекстВыводимыеПоляПериоды, 2) + "}"
	;
	
	Если (ВидРегистра = Метаданные.СвойстваОбъектов.ВидРегистраНакопления.Обороты И ((ТипОтчета = "СписокКроссТаблица")ИЛИ(ТипОтчета = "Диаграмма"))) Тогда
		Текст =  Текст +
		"
		|ИЗ РегистрНакопления." + ИмяРегистра + ".Обороты(&ДатаНач, &ДатаКон, {&Периодичность}, ";

		СтруктураПредставлениеПолей.Вставить("Периодичность", "Периодичность разворота итогов");

	ИначеЕсли (ВидРегистра = Метаданные.СвойстваОбъектов.ВидРегистраНакопления.Остатки И ((ТипОтчета = "СписокКроссТаблица")ИЛИ(ТипОтчета = "Диаграмма"))) Тогда
		Текст =  Текст +
		"
		|ИЗ РегистрНакопления." + ИмяРегистра + ".Остатки(&ДатаКон, ";
	ИначеЕсли ТипОтчета = "ОстаткиИОбороты" Тогда
		Текст = Текст+
		"
		|ИЗ РегистрНакопления." + ИмяРегистра + ".ОстаткиИОбороты(&ДатаНач, &ДатаКон, {&Периодичность}";

		СтруктураПредставлениеПолей.Вставить("Периодичность", "Периодичность разворота итогов");

		Текст = Текст + ", ";

		// Пропуск - неиспользуемый параметр дополнения
		Текст = Текст + ", ";
	КонецЕсли;

	Текст = Текст + "{"+ТекстПоляГде+"}) КАК ТаблицаРегистра
	|//СОЕДИНЕНИЯ";

	Если Не ПустаяСтрока(ТекстПоляГруппировки) Тогда

		Текст = Текст + Символы.ПС + "СГРУППИРОВАТЬ ПО " + Сред(ТекстПоляГруппировки, 2) + "
		|//СГРУППИРОВАТЬПО
		|";

	КонецЕсли; 

	// Отбор
	Текст = Текст + Символы.ПС + "{ГДЕ " + Сред(ТекстВыводимыеПоляЗапроса, 2) + "
	|//СВОЙСТВА
	|//КАТЕГОРИИ
	|}";

	// Порядок
	Текст = Текст + Символы.ПС + "{УПОРЯДОЧИТЬ ПО " + Сред(ТекстВыводимыеПоляЗапроса+ТекстПоляУпорядочивания, 2) + "
	|//СВОЙСТВА
	|}";

	Если Не ПустаяСтрока(ТекстПоляИтогов) Тогда 
		Текст = Текст + Символы.ПС +  
		"{ИТОГИ ПО " + Сред(ТекстПоляИтогов+ТекстПоляИтоговПериоды, 2) + "
		|//СВОЙСТВА
		|}";
	КонецЕсли;

	Текст = Текст + Символы.ПС +  
	"ИТОГИ  " + Сред(ТекстПоляИтоговЗапроса, 2) + Символы.ПС + 
	"ПО ОБЩИЕ " + ТекстПоляИзмерений;

	// Автоупорядочивание
	Текст = Текст + Символы.ПС + "АВТОУПОРЯДОЧИВАНИЕ ";
	
	ТекстПоляКатегорий = "";
	ТекстПоляСвойств = "";
	
	Если Контекст.ИспользоватьСвойстваИКатегории = Истина Тогда

		ДобавитьВТекстСвойстваИКатегории(ТаблицаПолей, Текст, СтруктураПредставлениеПолей, 
				Контекст.мСоответствиеНазначений, ПостроительОтчета.Параметры
				,, ТекстПоляКатегорий, ТекстПоляСвойств,,,,,,Контекст.мСтруктураДляОтбораПоКатегориям);

	КонецЕсли;

	ПостроительОтчета.Текст = Текст;
	
	Для каждого Элемент Из МассивВыбранныеПоляПоУмолчанию Цикл
	
		ПостроительОтчета.ВыбранныеПоля.Добавить(Элемент);
	
	КонецЦикла;
	
	Для каждого Элемент Из МассивИзмеренияСтрокиПоУмолчанию Цикл
	
		ПостроительОтчета.ИзмеренияСтроки.Добавить(Элемент);
	
	КонецЦикла;

	Для Каждого Показатель из Контекст.мТаблицаПоказатели Цикл
		Если (ТипОтчета = "СписокКроссТаблица") Или (ТипОтчета = "Диаграмма") Тогда

			ОбработкаПоказателейУдалитьИзДоступныхПолей(Показатель.ИмяПоля, ПостроительОтчета);

		ИначеЕсли ТипОтчета = "ОстаткиИОбороты" Тогда

			ОбработкаПоказателейУдалитьИзДоступныхПолей(Показатель.ИмяПоля + "НачальныйОстаток", ПостроительОтчета);
			ОбработкаПоказателейУдалитьИзДоступныхПолей(Показатель.ИмяПоля + "КонечныйОстаток", ПостроительОтчета);
			ОбработкаПоказателейУдалитьИзДоступныхПолей(Показатель.ИмяПоля + "Приход", ПостроительОтчета);
			ОбработкаПоказателейУдалитьИзДоступныхПолей(Показатель.ИмяПоля + "Расход", ПостроительОтчета);

		КонецЕсли;
	КонецЦикла;

	Если Контекст.ИспользоватьСвойстваИКатегории = Истина Тогда

		УстановитьТипыЗначенийСвойствИКатегорийДляОтбора(ПостроительОтчета, ТекстПоляКатегорий, ТекстПоляСвойств, Контекст.мСоответствиеНазначений, СтруктураПредставлениеПолей);
		
	КонецЕсли;

	Если (ТипОтчета = "СписокКроссТаблица") ИЛИ (ТипОтчета = "Диаграмма") Тогда
		Для каждого Элемент Из МассивИзмеренийКолонки Цикл

			Измерение = ПостроительОтчета.ИзмеренияСтроки.Найти(Элемент);
			Если Измерение <> Неопределено Тогда
				ПостроительОтчета.ИзмеренияСтроки.Удалить(Измерение);
			КонецЕсли;

			ПостроительОтчета.ИзмеренияКолонки.Добавить(Элемент);
		
		КонецЦикла; 
	КонецЕсли;

КонецПроцедуры // ЗаполнитьНачальныеНастройкиПоМакету()

////////////////////////////////////////////////////////////////////////////////
// ПРОЦЕДУРЫ И ФУНКЦИИ РАБОТЫ С ПЕРИОДАМИ

// Повторяем поведение переключателя на кнопках из меню
//
// Параметры: 
//  Отчет - объект отчета. 
//  ФормаОтчета - основная форма отчета, чья панель заполняется
//
// Возвращаемое значение:
//  Нет.
//
Процедура ПометитьКнопкиОтображения(Отчет, ФормаОтчета) Экспорт
	
	ВариантОтображения = Отчет.ВариантОтображения;
	Отображение			= ФормаОтчета.ЭлементыФормы.КоманднаяПанельФормы.Кнопки.ПодменюОтображение.Кнопки;
	ОтображениеВПодменю	= ФормаОтчета.ЭлементыФормы.КоманднаяПанельФормы.Кнопки.Подменю.Кнопки.ПодменюОтображение.Кнопки;

	Отображение.ОтображениеТаблица.Пометка			= ВариантОтображения = Перечисления.ВариантыОтображенияОтчетов.Таблица;
	Отображение.ОтображениеДиаграмма.Пометка		= ВариантОтображения = Перечисления.ВариантыОтображенияОтчетов.Диаграмма;
	Отображение.ОтображениеСводнаяТаблица.Пометка	= ВариантОтображения = Перечисления.ВариантыОтображенияОтчетов.СводнаяТаблица;
	
	ОтображениеВПодменю.ОтображениеТаблица.Пометка			= ВариантОтображения = Перечисления.ВариантыОтображенияОтчетов.Таблица;
	ОтображениеВПодменю.ОтображениеДиаграмма.Пометка		= ВариантОтображения = Перечисления.ВариантыОтображенияОтчетов.Диаграмма;
	ОтображениеВПодменю.ОтображениеСводнаяТаблица.Пометка	= ВариантОтображения = Перечисления.ВариантыОтображенияОтчетов.СводнаяТаблица;
	
КонецПроцедуры // ПометитьКнопкиОтображения

// Процедура обслуживает интерфейс справок-расчетов:
// если период формирования отчета находится в рамках одного месяца, то
// процедура дает доступность кнопкам "Заголовок" и "Подпись"
Процедура КонтрольДоступностиЗаголовкаИПодписей(ДатаНачала, ДатаКонца, КнопкаЗаголовок, КнопкаПодпись) Экспорт	
	
	ДоступностьКнопок = (НачалоДня(ДатаНачала) = НачалоМесяца(ДатаКонца) И КонецДня(ДатаКонца) = КонецМесяца(ДатаНачала));

	КнопкаЗаголовок.Доступность = ДоступностьКнопок;
	КнопкаПодпись.Доступность   = ДоступностьКнопок;
	
КонецПроцедуры

// функция возвращает ложь, если в списке установлена хотя бы одна пометка,
// и истина, если в списке нет ни одной пометки
Функция ВСпискеНеУстановленыПометки(ТекущийСписок) Экспорт
	
	Для ТекущийИндекс = 0 По ТекущийСписок.Количество()- 1 Цикл
		ТекущееЗначение = ТекущийСписок.Получить(ТекущийИндекс);
		Если ТекущееЗначение.Пометка Тогда
			Возврат Ложь;
		КонецЕсли;
	КонецЦикла;
	Возврат Истина;

КонецФункции

////////////////////////////////////////////////////////////////////////////////
// ПРОЦЕДУРЫ И ФУНКЦИИ ЗАПОЛНЕНИЯ ДОКУМЕНТОВ ДАННЫМИ ОТЧЕТА

// Процедура переносит строки из дерева значений в таблицу значений.
// Переносятся только строки самого нижнего уровня - т.е. те, у которых нет вложенных строк.
// Процедура вызывает сама себя рекурсивно.
//
// Параметры:
//  СтрокиДерева 		- строки обрабатываемого дерева значений;
//  ДанныеДляЗаполнения - результирующая таблица значений.
// Необходимые колонки результирующей таблицы должны быть предварительно созданы.
Процедура ДобавитьДетальныеЗаписиВТаблицу(СтрокиДерева, ДанныеДляЗаполнения)
	
	Для Каждого Строка Из СтрокиДерева Цикл
		
		Если Строка.Строки.Количество()>0 Тогда
			ДобавитьДетальныеЗаписиВТаблицу(Строка.Строки, ДанныеДляЗаполнения);
		Иначе
			НоваяСтрока = ДанныеДляЗаполнения.Добавить();
			ЗаполнитьЗначенияСвойств(НоваяСтрока, Строка);
		КонецЕсли;
		
	КонецЦикла;
	
КонецПроцедуры

// Отключает использование всех элементов структуры настройки компоновки, 
// не поддерживаемых для выгрузки в универсальную коллекцию значений. 
// Не поддерживается вывод таблиц, диаграмм и вложенных отчетов в универсальную коллекцию значений.
//
// Параметры
//		НастройкиКомпоновки: модифицируемые настройки, типы: 
//			НастройкиКомпоновкиДанных, ГруппировкаКомпоновкиДанных
//
// Процедура вызывает сама себя рекурсивно для обхода дерева структуры настроек компоновки.
Процедура ОтключитьЗапрещенныеДляВыводаВКоллекциюСтруктуры(НастройкиКомпоновки)
	
	Для Каждого ЭлементСтруктуры Из НастройкиКомпоновки.Структура Цикл
		Если ЭлементСтруктуры.Использование Тогда
			Если 	ТипЗнч(ЭлементСтруктуры) = Тип("ТаблицаКомпоновкиДанных")
				ИЛИ ТипЗнч(ЭлементСтруктуры) = Тип("ДиаграммаКомпоновкиДанных")
				ИЛИ ТипЗнч(ЭлементСтруктуры) = Тип("НастройкиВложенногоОбъектаКомпоновкиДанных")
				Тогда
				ЭлементСтруктуры.Использование = Ложь;
			Иначе
				ОтключитьЗапрещенныеДляВыводаВКоллекциюСтруктуры(ЭлементСтруктуры);
			КонецЕсли;
		КонецЕсли;
	КонецЦикла;
	
КонецПроцедуры

// Получает данные для заполнения табличной части с помощью отчета, формируемого по настройке.
// Используется во внешних обработках заполнения табличных частей.
//
// Параметры
//  ИсточникЗаполнения 	- сохраненная настройка отчета, в соответствии с которой подготавливаются данные
//  ЗаполняемыеПоля 	- структура, содержащая перечень полей для заполнения
//
// Возвращаемое значение
//  таблица значений, содержащая данные, полученные отчетом.
//  Если по указанной настройке формирование такой таблицы невозможно, то возвращается Неопределено.
Функция ПолучитьДанныеОтчетаЗаполнения(ИсточникЗаполнения, ЗаполняемыеПоля, НачалоПериода = Неопределено, КонецПериода = Неопределено) Экспорт
	
	//Умеем заполнять только данными отчета. Поэтому настройка должна иметь соответствующий тип.
	Если ИсточникЗаполнения.ТипНастройки <> Перечисления.ТипыНастроек.НастройкиОтчета Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	//Получим настройки отчета.
	СтруктураНастроек = ИсточникЗаполнения.ХранилищеНастроек.Получить();
	Если СтруктураНастроек = Неопределено Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	ЭтоПроизвольныйОтчет = (ТипЗнч(ИсточникЗаполнения.НастраиваемыйОбъект) = Тип("СправочникСсылка.ПроизвольныеОтчеты"));
	
	Если ЭтоПроизвольныйОтчет Тогда
		
		ОтчетОбъект = Отчеты.ПроизвольныйОтчет.Создать();
		ОтчетОбъект.УстановитьПроизвольныйОтчет(ИсточникЗаполнения.НастраиваемыйОбъект, ИсточникЗаполнения);
		
		СхемаКомпоновки = ОтчетОбъект.СхемаКомпоновкиДанных;
		КомпоновщикНастроек = ОтчетОбъект.КомпоновщикНастроек;
		
	Иначе	
		
		//Получим название отчета и сам отчет.
		ИмяМетаданных    = СтрЗаменить(ИсточникЗаполнения.НастраиваемыйОбъект, "ОтчетОбъект.", "");
		МетаданныеОтчета = Метаданные.Отчеты.Найти(ИмяМетаданных);
		Если МетаданныеОтчета = Неопределено Тогда
			Возврат Неопределено;
		КонецЕсли;
	
		//Получим объект отчета.
		ОтчетОбъект = Отчеты[ИмяМетаданных].Создать();
		
		Если МетаданныеОтчета.Реквизиты.Найти("СохраненнаяНастройка") <> Неопределено Тогда
			ОтчетОбъект.СохраненнаяНастройка = ИсточникЗаполнения;
		КонецЕсли;
		
		СхемаКомпоновки = ОтчетОбъект.СхемаКомпоновкиДанных;
	
		Настройки = СтруктураНастроек.НастройкиКомпоновщика;
		
		//СтруктураНастроек.НастройкиКомпоновщика - содержит "общие" настройки структуры,
		//СтруктураНастроек.ЗначенияНастроекПанелиПользователя...НастройкиКомпоновщика - настройки, 
		//которые задаются на панели пользователя.
		КомпоновщикНастроек = ОтчетОбъект.КомпоновщикНастроек;
		КомпоновщикНастроек.Инициализировать(Новый ИсточникДоступныхНастроекКомпоновкиДанных(СхемаКомпоновки));
		КомпоновщикНастроек.ЗагрузитьНастройки(Настройки);
		
		ЗаполнитьЗначенияСвойств(ОтчетОбъект, СтруктураНастроек);
		
		Если МетаданныеОтчета.Реквизиты.Найти("ОтрицательноеКрасным") <> Неопределено
		 И МетаданныеОтчета.Реквизиты.Найти("РасширеннаяНастройка") <> Неопределено Тогда
		 
			//Позовем типовую доработку настроек компоновки.
			//Она нужна, чтобы применить настройки, которые задаются на панели пользователя,
			//в т.ч. отборы, параметры и период.
			ТиповыеОтчеты.ДоработатьТиповойОтчетПередВыводом(ОтчетОбъект);
			
		КонецЕсли;
		
		//Позовем доработку, если она предусмотрена конкретным отчетом.
		Попытка
			ОтчетОбъект.ДоработатьКомпоновщикПередВыводом();
		Исключение
		КонецПопытки;
		
	КонецЕсли; 
	
	// Если период отчета задан в параметрах функции, то применим его.
	// Если не задан - то период определяется настройкой отчета.
	Если НачалоПериода <> Неопределено И КонецПериода <> Неопределено Тогда

		КоллекцияЗначенийПараметров = КомпоновщикНастроек.Настройки.ПараметрыДанных.Элементы;

		ЗначениеПараметраНачалоПериода = КоллекцияЗначенийПараметров.Найти("НачалоПериода");
		Если ЗначениеПараметраНачалоПериода <> Неопределено Тогда
			ЗначениеПараметраНачалоПериода.Значение      = НачалоДня(НачалоПериода);
			ЗначениеПараметраНачалоПериода.Использование = Истина;
		КонецЕсли;

		ЗначениеПараметраКонецПериода = КоллекцияЗначенийПараметров.Найти("КонецПериода");
		Если ЗначениеПараметраКонецПериода <> Неопределено Тогда
			ЗначениеПараметраКонецПериода.Значение       = КонецДня(КонецПериода);
			ЗначениеПараметраКонецПериода.Использование  = Истина;
		КонецЕсли;

	КонецЕсли;
	
	//Не поддерживается вывод таблиц, диаграмм и вложенных отчетов в универсальную коллекцию значений.
	ОтключитьЗапрещенныеДляВыводаВКоллекциюСтруктуры(КомпоновщикНастроек.Настройки);
	
	//Все отборы могут быть заданы в настройках отчета.
	//Т.е. для разных значений отборов используются разные сохраненные настройки.
	//Возможны другие варианты:
	
	//Применим отборы, определяемые реквизитами документа
	//Посмотрим, есть ли у нас отборы с выключенным использованием.
	//Именно такие отборы рассматриваются как команда "возьми из документа".
	//Для Каждого ЗначениеОтбора Из КомпоновщикНастроек.Настройки.Отбор.Элементы Цикл
	//	Если ЗначениеОтбора.Использование = Ложь Тогда
	//		//Проверим, есть ли такой реквизит в шапке
	//		ИмяРеквизита = "" + ЗначениеОтбора.ЛевоеЗначение;
	//		Если Отборы.Свойство(ИмяРеквизита)<>Неопределено Тогда
	//			//Установим отбор
	//			ЗначениеОтбора.ВидСравнения 	= ВидСравненияКомпоновкиДанных.Равно;
	//			ЗначениеОтбора.ПравоеЗначение 	= Отборы[ИмяРеквизита];
	//			ЗначениеОтбора.Использование	= Истина;
	//		КонецЕсли;
	//	КонецЕсли;
	//КонецЦикла;
	
	//Другой вариант - применяем все отборы, которые заданы в обработке заполнения
	//Для Каждого Отбор Из Отборы Цикл
	//	ПолеКомпоновки = Новый ПолеКомпоновкиДанных(Отбор.Ключ);
	//	Если КомпоновщикНастроек.Настройки.ДоступныеПоляОтбора.НайтиПоле(Новый ПолеКомпоновкиДанных(Отбор.Ключ))<>Неопределено Тогда
	//		ЗначениеОтбора = КомпоновщикНастроек.Настройки.Отбор.Элементы.Добавить(Тип("ЭлементОтбораКомпоновкиДанных"));
	//		ЗначениеОтбора.ВидСравнения 	= ВидСравненияКомпоновкиДанных.Равно;
	//		ЗначениеОтбора.ЛевоеЗначение	= ПолеКомпоновки;
	//		ЗначениеОтбора.ПравоеЗначение 	= Отбор.Значение;
	//		ЗначениеОтбора.Использование	= Истина;
	//	КонецЕсли;
	//КонецЦикла;
	
	//Отключим вывод итогов, так как в результирующем дереве значений их тяжело отличить от "не-итоговых" записей.
	Параметр = КомпоновщикНастроек.Настройки.ПараметрыВывода.Элементы.Найти("VerticalOverallPlacement");
	Если Параметр<>Неопределено Тогда
		Параметр.Значение 		= РасположениеИтоговКомпоновкиДанных.Нет;
		Параметр.Использование 	= Истина;
	КонецЕсли;
	
	ДанныеОтчета = Новый ДеревоЗначений();
	
	Если ЭтоПроизвольныйОтчет Тогда
		Если НЕ ОтчетОбъект.СформироватьОтчет(ДанныеОтчета) Тогда
			Возврат Неопределено;
		КонецЕсли;
	Иначе
		КомпоновщикМакета 	= Новый КомпоновщикМакетаКомпоновкиДанных();
		//ДанныеРасшифровки	= Неопределено;
		//Пятым параметром укажем, что макет компоновки будет применяться для вывода в коллекцию значений.
		МакетКомпоновки 	= КомпоновщикМакета.Выполнить(
								СхемаКомпоновки, 
								КомпоновщикНастроек.ПолучитьНастройки(), , , 
								Тип("ГенераторМакетаКомпоновкиДанныхДляКоллекцииЗначений"));
		
		//Подготовим процессор компоновки.
		ПроцессорКомпоновки = Новый ПроцессорКомпоновкиДанных();
		ПроцессорКомпоновки.Инициализировать(МакетКомпоновки);
		
		//Получим данные отчета.
		ПроцессорВывода = Новый ПроцессорВыводаРезультатаКомпоновкиДанныхВКоллекциюЗначений;
		ПроцессорВывода.ОтображатьПроцентВывода = Ложь;
		ПроцессорВывода.УстановитьОбъект(ДанныеОтчета);
		ПроцессорВывода.Вывести(ПроцессорКомпоновки, Ложь);
	КонецЕсли;

	ДанныеДляЗаполнения = Новый ТаблицаЗначений;
	Для Каждого Колонка Из ДанныеОтчета.Колонки Цикл
		Если ДанныеДляЗаполнения.Колонки.Найти(Колонка.Имя) = Неопределено Тогда 
			//Ситуация, когда в дереве две колонки с одинаковым именем может быть, когда макет компоновки содержит
			//несколько группировок подряд.
			//В этом случае вероятно заполнение будет некорректным. 
			//Поэтому макет компоновки должен содержать только одну группировку.
			ДанныеДляЗаполнения.Колонки.Добавить(Колонка.Имя, Колонка.ТипЗначения);
		КонецЕсли;
	КонецЦикла;
	
	//Перенесем данные в таблицу.
	ДобавитьДетальныеЗаписиВТаблицу(ДанныеОтчета.Строки, ДанныеДляЗаполнения);
	
	//Не обязательно имя реквизита должно совпадать с именем заполняемой колонки.
	//Это допущение сделано для того, чтобы можно было использовать пользовательские поля.
	//Допущение такое: 
	//	если в скомпонованных данных не будет колонки с именем ресурса, 
	//	то будет взято пользовательское поле с заголовком, совпадающим с именем поля (после удаления пробелов). 
	
	//Поищем пользовательские поля, пригодные для заполнения полей нашей табличной части.
	ПользовательскиеПоля = Новый Структура();
	Для Каждого ПользовательскоеПоле Из КомпоновщикНастроек.Настройки.ПользовательскиеПоля.Элементы Цикл
		
		//имя пользовательского поля имеет вид UserFields.FieldN (N - номер)
		ПутьКДанным = СтрЗаменить(ПользовательскоеПоле.ПутьКДанным,".","");
		Если ДанныеДляЗаполнения.Колонки.Найти(ПутьКДанным)<>Неопределено Тогда
			//Это поле использовано.
			//По заголовку поля попробуем определить, для чего оно использовано.
			//Из заголовка удалим пробелы.
			ИмяПоля = ПользовательскоеПоле.Заголовок;
			СпецСимволы = " ";
			Для нс = 1 По СтрДлина(СпецСимволы) Цикл
				ИмяПоля = СтрЗаменить(ИмяПоля, Сред(СпецСимволы, нс, 1), "");
			КонецЦикла;
			
			Если НЕ ПользовательскиеПоля.Свойство(ИмяПоля) Тогда //еще не было такого пользовательского поля
				Если ЗаполняемыеПоля.Свойство(ИмяПоля) Тогда //такое поле есть в реквизитах для заполнения
					Если ДанныеДляЗаполнения.Колонки.Найти(ИмяПоля)=Неопределено Тогда 
						//Другого источника, кроме пользовательских полей для этого поля нет.
						//Будем использовать данные пользовательского поля.
						ПользовательскиеПоля.Вставить(ИмяПоля, ПутьКДанным);
					КонецЕсли;
				КонецЕсли;
			КонецЕсли;
			
		КонецЕсли;
	КонецЦикла;
	
	//Перенесем значения пользовательских полей в предназначенные для них колонки.
	Для Каждого ПользовательскоеПоле Из ПользовательскиеПоля Цикл
		НоваяКолонка = ДанныеДляЗаполнения.Колонки.Добавить(ПользовательскоеПоле.Ключ);
	КонецЦикла;
	
	Для Каждого ДанныеСтроки Из ДанныеДляЗаполнения Цикл
		Для Каждого ПользовательскоеПоле Из ПользовательскиеПоля Цикл
			ДанныеСтроки[ПользовательскоеПоле.Ключ] = ДанныеСтроки[ПользовательскоеПоле.Значение];
		КонецЦикла;
	КонецЦикла;
	
	Возврат ДанныеДляЗаполнения;
	
КонецФункции